{
    "function_name": "http::header::map::header::map::HeaderMap<T>::try_grow",
    "tests": 7,
    "tests_lines": [
        68,
        60,
        59,
        7,
        8,
        8,
        9
    ],
    "oracles": 7,
    "oracles_compiled": 6,
    "oracles_compiled_rate": 85.71428571428571,
    "tests_compiled": 6,
    "tests_compiled_rate": 85.71428571428571,
    "oracles_run": 6,
    "oracles_passed": 4,
    "oracles_passed_rate": 66.66666666666666,
    "tests_run": 6,
    "tests_passed": 4,
    "tests_passed_rate": 66.66666666666666,
    "lines": 29,
    "lines_covered": 22,
    "lines_coveraged_rate": 75.86206896551724,
    "branches": 6,
    "branches_covered": 2,
    "branches_coverage_rate": 33.33333333333333,
    "codes_lines": [
        1735,
        1736,
        1737,
        1738,
        1739,
        1740,
        1741,
        1743,
        1744,
        1745,
        1746,
        1747,
        1748,
        1749,
        1754,
        1755,
        1756,
        1757,
        1758,
        1760,
        1761,
        1762,
        1764,
        1765,
        1766,
        1769,
        1770,
        1771,
        1772
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct TestHeaderMap {",
                "        mask: Size,",
                "        indices: Box<[Pos]>,",
                "        entries: Vec<Bucket<HeaderValue>>,",
                "        danger: Danger,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new(capacity: usize) -> Self {",
                "            TestHeaderMap {",
                "                mask: capacity as Size,",
                "                indices: vec![Pos::none(); capacity].into_boxed_slice(),",
                "                entries: Vec::new(),",
                "                danger: Danger::Green,",
                "            }",
                "        }",
                "",
                "        fn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached> {",
                "            if new_raw_cap > MAX_SIZE {",
                "                return Err(MaxSizeReached::new());",
                "            }",
                "",
                "            // find first ideally placed element -- start of cluster",
                "            let mut first_ideal = 0;",
                "",
                "            for (i, pos) in self.indices.iter().enumerate() {",
                "                if let Some((_, entry_hash)) = pos.resolve() {",
                "                    if 0 == probe_distance(self.mask, entry_hash, i) {",
                "                        first_ideal = i;",
                "                        break;",
                "                    }",
                "                }",
                "            }",
                "",
                "            // visit the entries in an order where we can simply reinsert them",
                "            // into self.indices without any bucket stealing.",
                "            let old_indices = mem::replace(",
                "                &mut self.indices,",
                "                vec![Pos::none(); new_raw_cap].into_boxed_slice(),",
                "            );",
                "            self.mask = new_raw_cap.wrapping_sub(1) as Size;",
                "",
                "            for &pos in &old_indices[first_ideal..] {",
                "                self.reinsert_entry_in_order(pos);",
                "            }",
                "",
                "            for &pos in &old_indices[..first_ideal] {",
                "                self.reinsert_entry_in_order(pos);",
                "            }",
                "",
                "            // Reserve additional entry slots",
                "            let more = self.capacity() - self.entries.len();",
                "            self.entries.reserve_exact(more);",
                "            Ok(())",
                "        }",
                "",
                "        fn reinsert_entry_in_order(&mut self, _pos: Pos) {}",
                "        fn capacity(&self) -> usize {",
                "            self.indices.len()",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new(16);",
                "    let new_capacity = 32768; // greater than MAX_SIZE (which is 32768)",
                "    ",
                "    assert!(header_map.try_grow(new_capacity).is_err());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestHeaderMap {",
                "        indices: Box<[Pos]>,",
                "        mask: Size,",
                "        entries: Vec<Bucket<HeaderValue>>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let mask = (1 << 15) - 1; ",
                "            let indices = vec![Pos::new(1, HashValue(1)); MAX_SIZE].into_boxed_slice();",
                "            let entries = Vec::new();",
                "            TestHeaderMap { indices, mask, entries }",
                "        }",
                "        ",
                "        fn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached> {",
                "            if new_raw_cap > MAX_SIZE {",
                "                return Err(MaxSizeReached::new());",
                "            }",
                "",
                "            let mut first_ideal = 0;",
                "",
                "            for (i, pos) in self.indices.iter().enumerate() {",
                "                if let Some((_, entry_hash)) = pos.resolve() {",
                "                    // This condition will ensure a panic for testing",
                "                    if probe_distance(self.mask, entry_hash, i) == 0 {",
                "                        first_ideal = i;",
                "                        break;",
                "                    }",
                "                }",
                "            }",
                "",
                "            let old_indices = mem::replace(",
                "                &mut self.indices,",
                "                vec![Pos::none(); new_raw_cap].into_boxed_slice(),",
                "            );",
                "            self.mask = new_raw_cap.wrapping_sub(1) as Size;",
                "",
                "            for &pos in &old_indices[first_ideal..] {",
                "                // Pseudo reinsert method (panic)",
                "            }",
                "",
                "            for &pos in &old_indices[..first_ideal] {",
                "                // Pseudo reinsert method (panic)",
                "            }",
                "",
                "            let more = self.capacity() - self.entries.len();",
                "            self.entries.reserve_exact(more);",
                "            Ok(())",
                "        }",
                "",
                "        fn capacity(&self) -> usize {",
                "            self.indices.len()",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let _ = header_map.try_grow(MAX_SIZE);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    ",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Simulating no entries",
                "    ",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    header_map.indices = vec![Pos::none(); 10].into_boxed_slice(); // Simulating no entries",
                "",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1749,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    header_map.mask = max_size.wrapping_sub(1) as Size;",
                "    header_map.indices = vec![Pos::none(); max_size].into_boxed_slice(); // Simulating no entries",
                "",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1749,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1736,
            "start_column": 12,
            "end_line": 1736,
            "end_column": 34,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1744,
            "start_column": 20,
            "end_line": 1744,
            "end_column": 41,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1745,
            "start_column": 20,
            "end_line": 1745,
            "end_column": 65,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct TestHeaderMap {",
                "        mask: Size,",
                "        indices: Box<[Pos]>,",
                "        entries: Vec<Bucket<HeaderValue>>,",
                "        danger: Danger,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new(capacity: usize) -> Self {",
                "            TestHeaderMap {",
                "                mask: capacity as Size,",
                "                indices: vec![Pos::none(); capacity].into_boxed_slice(),",
                "                entries: Vec::new(),",
                "                danger: Danger::Green,",
                "            }",
                "        }",
                "",
                "        fn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached> {",
                "            if new_raw_cap > MAX_SIZE {",
                "                return Err(MaxSizeReached::new());",
                "            }",
                "",
                "            // find first ideally placed element -- start of cluster",
                "            let mut first_ideal = 0;",
                "",
                "            for (i, pos) in self.indices.iter().enumerate() {",
                "                if let Some((_, entry_hash)) = pos.resolve() {",
                "                    if 0 == probe_distance(self.mask, entry_hash, i) {",
                "                        first_ideal = i;",
                "                        break;",
                "                    }",
                "                }",
                "            }",
                "",
                "            // visit the entries in an order where we can simply reinsert them",
                "            // into self.indices without any bucket stealing.",
                "            let old_indices = mem::replace(",
                "                &mut self.indices,",
                "                vec![Pos::none(); new_raw_cap].into_boxed_slice(),",
                "            );",
                "            self.mask = new_raw_cap.wrapping_sub(1) as Size;",
                "",
                "            for &pos in &old_indices[first_ideal..] {",
                "                self.reinsert_entry_in_order(pos);",
                "            }",
                "",
                "            for &pos in &old_indices[..first_ideal] {",
                "                self.reinsert_entry_in_order(pos);",
                "            }",
                "",
                "            // Reserve additional entry slots",
                "            let more = self.capacity() - self.entries.len();",
                "            self.entries.reserve_exact(more);",
                "            Ok(())",
                "        }",
                "",
                "        fn reinsert_entry_in_order(&mut self, _pos: Pos) {}",
                "        fn capacity(&self) -> usize {",
                "            self.indices.len()",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new(16);",
                "    let new_capacity = 32768; // greater than MAX_SIZE (which is 32768)",
                "    ",
                "    assert!(header_map.try_grow(new_capacity).is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestHeaderMap {",
                "        indices: Box<[Pos]>,",
                "        mask: Size,",
                "        entries: Vec<Bucket<HeaderValue>>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let mask = (1 << 15) - 1; ",
                "            let indices = vec![Pos::new(1, HashValue(1)); MAX_SIZE].into_boxed_slice();",
                "            let entries = Vec::new();",
                "            TestHeaderMap { indices, mask, entries }",
                "        }",
                "        ",
                "        fn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached> {",
                "            if new_raw_cap > MAX_SIZE {",
                "                return Err(MaxSizeReached::new());",
                "            }",
                "",
                "            let mut first_ideal = 0;",
                "",
                "            for (i, pos) in self.indices.iter().enumerate() {",
                "                if let Some((_, entry_hash)) = pos.resolve() {",
                "                    // This condition will ensure a panic for testing",
                "                    if probe_distance(self.mask, entry_hash, i) == 0 {",
                "                        first_ideal = i;",
                "                        break;",
                "                    }",
                "                }",
                "            }",
                "",
                "            let old_indices = mem::replace(",
                "                &mut self.indices,",
                "                vec![Pos::none(); new_raw_cap].into_boxed_slice(),",
                "            );",
                "            self.mask = new_raw_cap.wrapping_sub(1) as Size;",
                "",
                "            for &pos in &old_indices[first_ideal..] {",
                "                // Pseudo reinsert method (panic)",
                "            }",
                "",
                "            for &pos in &old_indices[..first_ideal] {",
                "                // Pseudo reinsert method (panic)",
                "            }",
                "",
                "            let more = self.capacity() - self.entries.len();",
                "            self.entries.reserve_exact(more);",
                "            Ok(())",
                "        }",
                "",
                "        fn capacity(&self) -> usize {",
                "            self.indices.len()",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let _ = header_map.try_grow(MAX_SIZE);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    ",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Simulating no entries",
                "    ",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    header_map.indices = vec![Pos::none(); 10].into_boxed_slice(); // Simulating no entries",
                "",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let max_size = MAX_SIZE;",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(0);",
                "    header_map.mask = max_size.wrapping_sub(1) as Size;",
                "    header_map.indices = vec![Pos::none(); max_size].into_boxed_slice(); // Simulating no entries",
                "",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/map.rs"
}