{
    "function_name": "http::header::map::header::map::HeaderMap<T>::remove_found",
    "tests": 2,
    "tests_lines": [
        100,
        18
    ],
    "oracles": 2,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 1,
    "tests_compiled_rate": 50.0,
    "oracles_run": 1,
    "oracles_passed": 0,
    "oracles_passed_rate": 0.0,
    "tests_run": 1,
    "tests_passed": 0,
    "tests_passed_rate": 0.0,
    "lines": 37,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 14,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        1552,
        1553,
        1554,
        1555,
        1556,
        1557,
        1560,
        1563,
        1564,
        1565,
        1566,
        1567,
        1569,
        1570,
        1571,
        1572,
        1576,
        1577,
        1578,
        1579,
        1580,
        1584,
        1585,
        1586,
        1587,
        1588,
        1589,
        1590,
        1591,
        1592,
        1593,
        1594,
        1597,
        1600,
        1602,
        1604,
        1605
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    struct TestHeaderMap {",
                "        mask: Size,",
                "        indices: Box<[Pos]>,",
                "        entries: Vec<Bucket<TestHeaderValue>>,",
                "        extra_values: Vec<ExtraValue<TestHeaderValue>>,",
                "        danger: Danger,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            Self {",
                "                mask: 15,",
                "                indices: Box::new([Pos::none(); 16]),",
                "                entries: Vec::new(),",
                "                extra_values: Vec::new(),",
                "                danger: Danger::Green,",
                "            }",
                "        }",
                "",
                "        fn add_entry(&mut self, hash: HashValue, key: HeaderName, value: TestHeaderValue) {",
                "            let entry = Bucket {",
                "                hash,",
                "                key,",
                "                value,",
                "                links: None,",
                "            };",
                "            self.entries.push(entry);",
                "            let pos = self.entries.len() - 1;",
                "            self.indices[pos] = Pos::new(pos, hash);",
                "        }",
                "",
                "        fn remove_found(&mut self, probe: usize, found: usize) -> Bucket<TestHeaderValue> {",
                "            // implementation of the remove_found function goes here",
                "            // (the one provided in the context)",
                "            self.indices[probe] = Pos::none();",
                "            let entry = self.entries.swap_remove(found);",
                "",
                "            // correct index that points to the entry that had to swap places",
                "            if let Some(entry) = self.entries.get(found) {",
                "                let mut probe = desired_pos(self.mask, entry.hash);",
                "                ",
                "                probe_loop!(probe < self.indices.len(), {",
                "                    if let Some((i, _)) = self.indices[probe].resolve() {",
                "                        if i >= self.entries.len() {",
                "                            self.indices[probe] = Pos::new(found, entry.hash);",
                "                            break;",
                "                        }",
                "                    }",
                "                });",
                "",
                "                // Update links",
                "                if let Some(links) = entry.links {",
                "                    self.extra_values[links.next].prev = Link::Entry(found);",
                "                    self.extra_values[links.tail].next = Link::Entry(found);",
                "                }",
                "            }",
                "",
                "            if !self.entries.is_empty() {",
                "                let mut last_probe = probe;",
                "                let mut probe = probe + 1;",
                "",
                "                probe_loop!(probe < self.indices.len(), {",
                "                    if let Some((_, entry_hash)) = self.indices[probe].resolve() {",
                "                        if probe_distance(self.mask, entry_hash, probe) > 0 {",
                "                            self.indices[last_probe] = self.indices[probe];",
                "                            self.indices[probe] = Pos::none();",
                "                        } else {",
                "                            break;",
                "                        }",
                "                    } else {",
                "                        break;",
                "                    }",
                "",
                "                    last_probe = probe;",
                "                });",
                "            }",
                "",
                "            entry",
                "        }",
                "    }",
                "",
                "    let mut map = TestHeaderMap::new();",
                "    // Add sample entries for testing",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    map.add_entry(HashValue(1), key1.clone(), TestHeaderValue);",
                "    ",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    map.add_entry(HashValue(2), key2.clone(), TestHeaderValue);",
                "",
                "    assert_eq!(map.entries.len(), 2);",
                "    ",
                "    // Test removal of the first entry (found index 0)",
                "    let removed_entry = map.remove_found(0, 0);",
                "    assert_eq!(removed_entry.key, key1);",
                "",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert!(map.indices[0].is_none());",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1560,
            "start_column": 16,
            "end_line": 1560,
            "end_column": 27,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1566,
            "start_column": 24,
            "end_line": 1566,
            "end_column": 36,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1567,
            "start_column": 24,
            "end_line": 1567,
            "end_column": 47,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1576,
            "start_column": 20,
            "end_line": 1576,
            "end_column": 31,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1584,
            "start_column": 12,
            "end_line": 1584,
            "end_column": 36,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1589,
            "start_column": 24,
            "end_line": 1589,
            "end_column": 45,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1590,
            "start_column": 24,
            "end_line": 1590,
            "end_column": 72,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    struct TestHeaderMap {",
                "        mask: Size,",
                "        indices: Box<[Pos]>,",
                "        entries: Vec<Bucket<TestHeaderValue>>,",
                "        extra_values: Vec<ExtraValue<TestHeaderValue>>,",
                "        danger: Danger,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            Self {",
                "                mask: 15,",
                "                indices: Box::new([Pos::none(); 16]),",
                "                entries: Vec::new(),",
                "                extra_values: Vec::new(),",
                "                danger: Danger::Green,",
                "            }",
                "        }",
                "",
                "        fn add_entry(&mut self, hash: HashValue, key: HeaderName, value: TestHeaderValue) {",
                "            let entry = Bucket {",
                "                hash,",
                "                key,",
                "                value,",
                "                links: None,",
                "            };",
                "            self.entries.push(entry);",
                "            let pos = self.entries.len() - 1;",
                "            self.indices[pos] = Pos::new(pos, hash);",
                "        }",
                "",
                "        fn remove_found(&mut self, probe: usize, found: usize) -> Bucket<TestHeaderValue> {",
                "            // implementation of the remove_found function goes here",
                "            // (the one provided in the context)",
                "            self.indices[probe] = Pos::none();",
                "            let entry = self.entries.swap_remove(found);",
                "",
                "            // correct index that points to the entry that had to swap places",
                "            if let Some(entry) = self.entries.get(found) {",
                "                let mut probe = desired_pos(self.mask, entry.hash);",
                "                ",
                "                probe_loop!(probe < self.indices.len(), {",
                "                    if let Some((i, _)) = self.indices[probe].resolve() {",
                "                        if i >= self.entries.len() {",
                "                            self.indices[probe] = Pos::new(found, entry.hash);",
                "                            break;",
                "                        }",
                "                    }",
                "                });",
                "",
                "                // Update links",
                "                if let Some(links) = entry.links {",
                "                    self.extra_values[links.next].prev = Link::Entry(found);",
                "                    self.extra_values[links.tail].next = Link::Entry(found);",
                "                }",
                "            }",
                "",
                "            if !self.entries.is_empty() {",
                "                let mut last_probe = probe;",
                "                let mut probe = probe + 1;",
                "",
                "                probe_loop!(probe < self.indices.len(), {",
                "                    if let Some((_, entry_hash)) = self.indices[probe].resolve() {",
                "                        if probe_distance(self.mask, entry_hash, probe) > 0 {",
                "                            self.indices[last_probe] = self.indices[probe];",
                "                            self.indices[probe] = Pos::none();",
                "                        } else {",
                "                            break;",
                "                        }",
                "                    } else {",
                "                        break;",
                "                    }",
                "",
                "                    last_probe = probe;",
                "                });",
                "            }",
                "",
                "            entry",
                "        }",
                "    }",
                "",
                "    let mut map = TestHeaderMap::new();",
                "    // Add sample entries for testing",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    map.add_entry(HashValue(1), key1.clone(), TestHeaderValue);",
                "    ",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    map.add_entry(HashValue(2), key2.clone(), TestHeaderValue);",
                "",
                "    assert_eq!(map.entries.len(), 2);",
                "    ",
                "    // Test removal of the first entry (found index 0)",
                "    let removed_entry = map.remove_found(0, 0);",
                "    assert_eq!(removed_entry.key, key1);",
                "",
                "    assert_eq!(map.entries.len(), 1);",
                "    assert!(map.indices[0].is_none());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/map.rs"
}