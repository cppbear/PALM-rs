{
    "function_name": "serde_json::read::<read::StrRead<'a> as read::Read<'a>>::peek",
    "tests": 2,
    "tests_lines": [
        88,
        88
    ],
    "oracles": 2,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 1,
    "tests_compiled_rate": 50.0,
    "oracles_run": 1,
    "oracles_passed": 1,
    "oracles_passed_rate": 100.0,
    "tests_run": 1,
    "tests_passed": 1,
    "tests_passed_rate": 100.0,
    "lines": 3,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        688,
        689,
        690
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "   struct TestRead<'a> {",
                "       delegate: SliceRead<'a>,",
                "   }",
                "",
                "   impl<'a> TestRead<'a> {",
                "       fn new(slice: &'a [u8]) -> Self {",
                "           Self {",
                "               delegate: SliceRead {",
                "                   slice,",
                "                   index: 0,",
                "                   #[cfg(feature = \"raw_value\")]",
                "                   raw_buffering_start_index: 0,",
                "               },",
                "           }",
                "       }",
                "   }",
                "",
                "   impl<'a> private::Sealed for TestRead<'a> {}",
                "   impl<'a> Read<'a> for TestRead<'a> {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            if self.delegate.index < self.delegate.slice.len() {",
                "                let byte = self.delegate.slice[self.delegate.index];",
                "                self.delegate.index += 1;",
                "                Ok(Some(byte))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            if self.delegate.index < self.delegate.slice.len() {",
                "                Ok(Some(self.delegate.slice[self.delegate.index]))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn discard(&mut self) {}",
                "",
                "       fn position(&self) -> Position {",
                "           Position { line: 0, column: self.delegate.index }",
                "       }",
                "       ",
                "       fn peek_position(&self) -> Position {",
                "           Position { line: 0, column: self.delegate.index }",
                "        }",
                "",
                "        fn byte_offset(&self) -> usize {",
                "            self.delegate.index",
                "        }",
                "",
                "        fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, [u8]>> {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn ignore_str(&mut self) -> Result<()> {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn decode_hex_escape(&mut self) -> Result<u16> {",
                "            unimplemented!()",
                "        }",
                "",
                "        #[cfg(feature = \"raw_value\")]",
                "        fn begin_raw_buffering(&mut self) {}",
                "",
                "        #[cfg(feature = \"raw_value\")]",
                "        fn end_raw_buffering<V>(&mut self, _visitor: V) -> Result<V::Value>",
                "        where",
                "            V: Visitor<'a>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn set_failed(&mut self, _failed: &mut bool) {}",
                "    }",
                "",
                "    let mut reader = TestRead::new(&[]);",
                "    let result = reader.peek();",
                "    assert_eq!(result.unwrap(), None);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "   struct TestRead<'a> {",
                "       delegate: SliceRead<'a>,",
                "   }",
                "",
                "   impl<'a> TestRead<'a> {",
                "       fn new(slice: &'a [u8]) -> Self {",
                "           Self {",
                "               delegate: SliceRead {",
                "                   slice,",
                "                   index: 0,",
                "                   #[cfg(feature = \"raw_value\")]",
                "                   raw_buffering_start_index: 0,",
                "               },",
                "           }",
                "       }",
                "   }",
                "",
                "   impl<'a> private::Sealed for TestRead<'a> {}",
                "   impl<'a> Read<'a> for TestRead<'a> {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            if self.delegate.index < self.delegate.slice.len() {",
                "                let byte = self.delegate.slice[self.delegate.index];",
                "                self.delegate.index += 1;",
                "                Ok(Some(byte))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            if self.delegate.index < self.delegate.slice.len() {",
                "                Ok(Some(self.delegate.slice[self.delegate.index]))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn discard(&mut self) {}",
                "",
                "       fn position(&self) -> Position {",
                "           Position { line: 0, column: self.delegate.index }",
                "       }",
                "       ",
                "       fn peek_position(&self) -> Position {",
                "           Position { line: 0, column: self.delegate.index }",
                "        }",
                "",
                "        fn byte_offset(&self) -> usize {",
                "            self.delegate.index",
                "        }",
                "",
                "        fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, [u8]>> {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn ignore_str(&mut self) -> Result<()> {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn decode_hex_escape(&mut self) -> Result<u16> {",
                "            unimplemented!()",
                "        }",
                "",
                "        #[cfg(feature = \"raw_value\")]",
                "        fn begin_raw_buffering(&mut self) {}",
                "",
                "        #[cfg(feature = \"raw_value\")]",
                "        fn end_raw_buffering<V>(&mut self, _visitor: V) -> Result<V::Value>",
                "        where",
                "            V: Visitor<'a>,",
                "        {",
                "            unimplemented!()",
                "        }",
                "",
                "        fn set_failed(&mut self, _failed: &mut bool) {}",
                "    }",
                "",
                "    let mut reader = TestRead::new(&[]);",
                "    let result = reader.peek();",
                "    assert_eq!(result.unwrap(), None);",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/read.rs"
}