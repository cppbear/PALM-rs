{
    "function_name": "serde_json::read::<read::StrRead<'a> as read::Read<'a>>::next",
    "tests": 3,
    "tests_lines": [
        48,
        42,
        48
    ],
    "oracles": 3,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 33.33333333333333,
    "tests_compiled": 1,
    "tests_compiled_rate": 33.33333333333333,
    "oracles_run": 1,
    "oracles_passed": 1,
    "oracles_passed_rate": 100.0,
    "tests_run": 1,
    "tests_passed": 1,
    "tests_passed_rate": 100.0,
    "lines": 3,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        683,
        684,
        685
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "   struct TestRead {",
                "       data: Vec<u8>,",
                "       index: usize,",
                "   }",
                "   ",
                "   impl private::Sealed for TestRead {}",
                "   ",
                "   impl TestRead {",
                "       fn new(data: Vec<u8>) -> Self {",
                "            TestRead { data, index: 0 }",
                "        }",
                "    }",
                "",
                "   impl Read<'static> for TestRead {  ",
                "       const should_early_return_if_failed: bool = false;  ",
                " ",
                "       fn next(&mut self) -> Result<Option<u8>> {  ",
                "           if self.index < self.data.len() {  ",
                "               let byte = self.data[self.index];  ",
                "               self.index += 1;  ",
                "               Ok(Some(byte))  ",
                "           } else {  ",
                "               Ok(None)  ",
                "           }  ",
                "       }  ",
                " ",
                "       fn peek(&mut self) -> Result<Option<u8>> { unimplemented!() }  ",
                "       fn discard(&mut self) {}  ",
                "      fn position(&self) -> Position { unimplemented!() }  ",
                "      fn peek_position(&self) -> Position { unimplemented!() }  ",
                "      fn byte_offset(&self) -> usize { self.index }  ",
                "       fn parse_str<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { unimplemented!() }  ",
                "       fn parse_str_raw<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { unimplemented!() }  ",
                "       fn ignore_str(&mut self) -> Result<()> { unimplemented!() }  ",
                "       fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }  ",
                "     // fn begin_raw_buffering(&mut self) {}  ",
                "",
                "       fn set_failed(&mut self, _: &mut bool) {}  ",
                "    }",
                "",
                "    let mut reader = TestRead::new(vec![1, 2, 3]);",
                "    ",
                "    assert_eq!(reader.next().unwrap(), Some(1));",
                "    assert_eq!(reader.next().unwrap(), Some(2));",
                "    assert_eq!(reader.next().unwrap(), Some(3));",
                "    assert_eq!(reader.next().unwrap(), None);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "   struct TestRead {",
                "       data: Vec<u8>,",
                "       index: usize,",
                "   }",
                "   ",
                "   impl private::Sealed for TestRead {}",
                "   ",
                "   impl TestRead {",
                "       fn new(data: Vec<u8>) -> Self {",
                "            TestRead { data, index: 0 }",
                "        }",
                "    }",
                "",
                "   impl Read<'static> for TestRead {  ",
                "       const should_early_return_if_failed: bool = false;  ",
                " ",
                "       fn next(&mut self) -> Result<Option<u8>> {  ",
                "           if self.index < self.data.len() {  ",
                "               let byte = self.data[self.index];  ",
                "               self.index += 1;  ",
                "               Ok(Some(byte))  ",
                "           } else {  ",
                "               Ok(None)  ",
                "           }  ",
                "       }  ",
                " ",
                "       fn peek(&mut self) -> Result<Option<u8>> { unimplemented!() }  ",
                "       fn discard(&mut self) {}  ",
                "      fn position(&self) -> Position { unimplemented!() }  ",
                "      fn peek_position(&self) -> Position { unimplemented!() }  ",
                "      fn byte_offset(&self) -> usize { self.index }  ",
                "       fn parse_str<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { unimplemented!() }  ",
                "       fn parse_str_raw<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { unimplemented!() }  ",
                "       fn ignore_str(&mut self) -> Result<()> { unimplemented!() }  ",
                "       fn decode_hex_escape(&mut self) -> Result<u16> { unimplemented!() }  ",
                "     // fn begin_raw_buffering(&mut self) {}  ",
                "",
                "       fn set_failed(&mut self, _: &mut bool) {}  ",
                "    }",
                "",
                "    let mut reader = TestRead::new(vec![1, 2, 3]);",
                "    ",
                "    assert_eq!(reader.next().unwrap(), Some(1));",
                "    assert_eq!(reader.next().unwrap(), Some(2));",
                "    assert_eq!(reader.next().unwrap(), Some(3));",
                "    assert_eq!(reader.next().unwrap(), None);",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/read.rs"
}