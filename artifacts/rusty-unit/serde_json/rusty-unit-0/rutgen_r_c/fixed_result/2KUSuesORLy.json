{
    "function_name": "serde_json::read::<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape",
    "tests": 3,
    "tests_lines": [
        49,
        49,
        49
    ],
    "oracles": 3,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 33.33333333333333,
    "tests_compiled": 1,
    "tests_compiled_rate": 33.33333333333333,
    "oracles_run": 1,
    "oracles_passed": 1,
    "oracles_passed_rate": 100.0,
    "tests_run": 1,
    "tests_passed": 1,
    "tests_passed_rate": 100.0,
    "lines": 3,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        729,
        730,
        731
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct MockSliceRead<'a> {",
                "        slice: &'a [u8],",
                "        index: usize,",
                "    }",
                "",
                "    impl<'a> MockSliceRead<'a> {",
                "        fn new(slice: &'a [u8]) -> Self {",
                "            Self { slice, index: 0 }",
                "        }",
                "",
                "       fn decode_hex_escape(&mut self) -> Result<u16> {",
                "           if self.index + 2 > self.slice.len() {",
                "               return Err(Error::syntax(ErrorCode::InvalidEscape, 0, 0));",
                "           }",
                "           let hex_str = core::str::from_utf8(&self.slice[self.index..self.index + 2]).map_err(|_| Error::syntax(ErrorCode::InvalidEscape, 0, 0))?;",
                "           self.index += 2;",
                "           u16::from_str_radix(hex_str, 16).map_err(|_| Error::syntax(ErrorCode::InvalidEscape, 0, 0)).map(|n| n as u16)",
                "        }",
                "    }",
                "",
                "   struct MockStrRead<'a> {",
                "       delegate: MockSliceRead<'a>,",
                "   }",
                "   ",
                "   impl<'a> private::Sealed for MockStrRead<'a> {}",
                "   impl<'a> Read<'a> for MockStrRead<'a> {",
                "       const should_early_return_if_failed: bool = false;",
                "       fn next(&mut self) -> Result<Option<u8>> { unimplemented!() }",
                "       fn peek(&mut self) -> Result<Option<u8>> { unimplemented!() }",
                "       fn discard(&mut self) { }",
                "       fn position(&self) -> Position { unimplemented!() }",
                "       fn peek_position(&self) -> Position { unimplemented!() }",
                "       fn byte_offset(&self) -> usize { self.delegate.index }",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> { unimplemented!() }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, [u8]>> { unimplemented!() }",
                "       fn ignore_str(&mut self) -> Result<()> { unimplemented!() }",
                "       fn decode_hex_escape(&mut self) -> Result<u16> {",
                "           self.delegate.decode_hex_escape()",
                "       }",
                "       fn set_failed(&mut self, _failed: &mut bool) { }",
                "   }",
                "   ",
                "  let mut mock_read = MockStrRead {  ",
                "      delegate: MockSliceRead::new(b\"1A\"),  ",
                "  };  ",
                "  ",
                "  let _result = mock_read.decode_hex_escape().unwrap();  ",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct MockSliceRead<'a> {",
                "        slice: &'a [u8],",
                "        index: usize,",
                "    }",
                "",
                "    impl<'a> MockSliceRead<'a> {",
                "        fn new(slice: &'a [u8]) -> Self {",
                "            Self { slice, index: 0 }",
                "        }",
                "",
                "       fn decode_hex_escape(&mut self) -> Result<u16> {",
                "           if self.index + 2 > self.slice.len() {",
                "               return Err(Error::syntax(ErrorCode::InvalidEscape, 0, 0));",
                "           }",
                "           let hex_str = core::str::from_utf8(&self.slice[self.index..self.index + 2]).map_err(|_| Error::syntax(ErrorCode::InvalidEscape, 0, 0))?;",
                "           self.index += 2;",
                "           u16::from_str_radix(hex_str, 16).map_err(|_| Error::syntax(ErrorCode::InvalidEscape, 0, 0)).map(|n| n as u16)",
                "        }",
                "    }",
                "",
                "   struct MockStrRead<'a> {",
                "       delegate: MockSliceRead<'a>,",
                "   }",
                "   ",
                "   impl<'a> private::Sealed for MockStrRead<'a> {}",
                "   impl<'a> Read<'a> for MockStrRead<'a> {",
                "       const should_early_return_if_failed: bool = false;",
                "       fn next(&mut self) -> Result<Option<u8>> { unimplemented!() }",
                "       fn peek(&mut self) -> Result<Option<u8>> { unimplemented!() }",
                "       fn discard(&mut self) { }",
                "       fn position(&self) -> Position { unimplemented!() }",
                "       fn peek_position(&self) -> Position { unimplemented!() }",
                "       fn byte_offset(&self) -> usize { self.delegate.index }",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> { unimplemented!() }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, [u8]>> { unimplemented!() }",
                "       fn ignore_str(&mut self) -> Result<()> { unimplemented!() }",
                "       fn decode_hex_escape(&mut self) -> Result<u16> {",
                "           self.delegate.decode_hex_escape()",
                "       }",
                "       fn set_failed(&mut self, _failed: &mut bool) { }",
                "   }",
                "   ",
                "  let mut mock_read = MockStrRead {  ",
                "      delegate: MockSliceRead::new(b\"1A\"),  ",
                "  };  ",
                "  ",
                "  let _result = mock_read.decode_hex_escape().unwrap();  ",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/read.rs"
}