{
    "function_name": "serde_json::read::<&mut R as read::Read<'de>>::position",
    "tests": 2,
    "tests_lines": [
        52,
        55
    ],
    "oracles": 2,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 1,
    "tests_compiled_rate": 50.0,
    "oracles_run": 1,
    "oracles_passed": 1,
    "oracles_passed_rate": 100.0,
    "tests_run": 1,
    "tests_passed": 1,
    "tests_passed_rate": 100.0,
    "lines": 3,
    "lines_covered": 3,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        778,
        779,
        780
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "  struct AnotherTestRead;",
                "  ",
                "  impl private::Sealed for AnotherTestRead {}",
                "  ",
                "   ",
                "   impl<'de> Read<'de> for AnotherTestRead {",
                "       const should_early_return_if_failed: bool = true;",
                "   ",
                "       fn next(&mut self) -> Result<Option<u8>> {",
                "           Ok(None)",
                "       }",
                "   ",
                "       fn peek(&mut self) -> Result<Option<u8>> {",
                "           Ok(None)",
                "       }",
                "   ",
                "       fn discard(&mut self) {}",
                "   ",
                "       fn position(&self) -> Position {",
                "           Position { line: 2, column: 5 }",
                "       }",
                "   ",
                "       fn peek_position(&self) -> Position {",
                "           Position { line: 2, column: 5 }",
                "       }",
                "   ",
                "       fn byte_offset(&self) -> usize {",
                "           10",
                "       }",
                "   ",
                "       fn parse_str<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn parse_str_raw<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn ignore_str(&mut self) -> Result<()> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn decode_hex_escape(&mut self) -> Result<u16> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn set_failed(&mut self, _: &mut bool) {}",
                "   }",
                "   ",
                "   let mut another_test_read = AnotherTestRead;",
                "   let pos = (&mut another_test_read).position();",
                "   assert_eq!(pos.line, 2);",
                "   assert_eq!(pos.column, 5);",
                "}"
            ],
            [
                778,
                779,
                780
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "  struct AnotherTestRead;",
                "  ",
                "  impl private::Sealed for AnotherTestRead {}",
                "  ",
                "   ",
                "   impl<'de> Read<'de> for AnotherTestRead {",
                "       const should_early_return_if_failed: bool = true;",
                "   ",
                "       fn next(&mut self) -> Result<Option<u8>> {",
                "           Ok(None)",
                "       }",
                "   ",
                "       fn peek(&mut self) -> Result<Option<u8>> {",
                "           Ok(None)",
                "       }",
                "   ",
                "       fn discard(&mut self) {}",
                "   ",
                "       fn position(&self) -> Position {",
                "           Position { line: 2, column: 5 }",
                "       }",
                "   ",
                "       fn peek_position(&self) -> Position {",
                "           Position { line: 2, column: 5 }",
                "       }",
                "   ",
                "       fn byte_offset(&self) -> usize {",
                "           10",
                "       }",
                "   ",
                "       fn parse_str<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn parse_str_raw<'s>(&'s mut self, _: &'s mut Vec<u8>) -> Result<Reference<'de, 's, [u8]>> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn ignore_str(&mut self) -> Result<()> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn decode_hex_escape(&mut self) -> Result<u16> {",
                "           unimplemented!()",
                "       }",
                "   ",
                "       fn set_failed(&mut self, _: &mut bool) {}",
                "   }",
                "   ",
                "   let mut another_test_read = AnotherTestRead;",
                "   let pos = (&mut another_test_read).position();",
                "   assert_eq!(pos.line, 2);",
                "   assert_eq!(pos.column, 5);",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/read.rs"
}