{
    "function_name": "serde_json::read::<read::SliceRead<'a> as read::Read<'a>>::ignore_str",
    "tests": 18,
    "tests_lines": [
        8,
        9,
        6,
        6,
        9,
        10,
        10,
        9,
        9,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7
    ],
    "oracles": 18,
    "oracles_compiled": 13,
    "oracles_compiled_rate": 72.22222222222221,
    "tests_compiled": 13,
    "tests_compiled_rate": 72.22222222222221,
    "oracles_run": 13,
    "oracles_passed": 11,
    "oracles_passed_rate": 84.61538461538461,
    "tests_run": 13,
    "tests_passed": 11,
    "tests_passed_rate": 84.61538461538461,
    "lines": 12,
    "lines_covered": 12,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        598,
        600,
        601,
        602,
        603,
        604,
        606,
        607,
        610,
        611,
        614,
        618
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let input = [b'\\\\', b'\"', b'\"']; // Valid escape sequence",
                "    let mut slice_read = SliceRead::new(&input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                606,
                607,
                610,
                611,
                618
            ]
        ],
        [
            [
                "{",
                "    let input = [b'\"']; // Just the ending quote",
                "    let mut slice_read = SliceRead::new(&input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                606,
                607,
                618
            ]
        ],
        [
            [
                "{",
                "    let slice = b\"Invalid\\x01String\\\"\"; // Contains a control character",
                "    let mut reader = SliceRead::new(slice);",
                "",
                "    let result = reader.ignore_str();",
                "",
                "    assert!(result.is_err());",
                "    // Assuming the error return value and related checks can be done accordingly",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                614,
                618
            ]
        ],
        [
            [
                "{",
                "    let slice = b\"Hello, World!\"; // No closing quote",
                "    let mut reader = SliceRead::new(slice);",
                "",
                "    let result = reader.ignore_str();",
                "",
                "    assert!(result.is_err());",
                "    // Assuming the error return value and related checks can be done accordingly",
                "}"
            ],
            [
                598,
                600,
                601,
                602,
                618
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\\\\\\"abc\\\"\"; // String with an escaped quote",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(slice_read.index, 6); // Index should be at the end of the input",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                606,
                607,
                610,
                611,
                618
            ]
        ],
        [
            [
                "{",
                "    let input = b\"abc\\x01\"; // String with a control character",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_err());",
                "    // Assert that the error matches the expected ControlCharacterWhileParsingString",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                614,
                618
            ]
        ],
        [
            [
                "{",
                "    let input = b\"abc\"; // Incomplete string, missing ending quote",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_err());",
                "    // Assert that the error matches the expected EofWhileParsingString",
                "}"
            ],
            [
                598,
                600,
                601,
                602,
                618
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\\\\\\"\\\\abc\\\\\\\"\"; // String with multiple escaped quotes",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(slice_read.index, 7); // Index should be at the end after processing multiple escapes",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                610,
                611,
                618
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\\\\\\"abc\"; // String with an escape but missing the closing quote",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_err());",
                "    // Check if the error corresponds to EofWhileParsingString",
                "}"
            ],
            [
                598,
                600,
                601,
                602,
                603,
                604,
                610,
                611,
                618
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\\\"\"; // the string contains a double quote",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(reader.index, 15); // Check that index has moved past the quote",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                606,
                607,
                618
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\\\\\\\"\"; // the string contains an escaped double quote",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(reader.index, 17); // Check that index has moved past the escaped quote",
                "}"
            ],
            [
                598,
                600,
                601,
                602,
                603,
                604,
                610,
                611,
                618
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\"; // the string is missing a closing double quote",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_err());",
                "    // Optionally check that the error is the expected one",
                "}"
            ],
            [
                598,
                600,
                601,
                602,
                618
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\\x01\"; // string contains a control character",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_err());",
                "    // Optionally check that the error is ControlCharacterWhileParsingString",
                "}"
            ],
            [
                598,
                600,
                601,
                603,
                604,
                614,
                618
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 601,
            "start_column": 16,
            "end_line": 601,
            "end_column": 46,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let input = [b'\\\\', b'\"', b'\"']; // Valid escape sequence",
                "    let mut slice_read = SliceRead::new(&input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input = [b'\"']; // Just the ending quote",
                "    let mut slice_read = SliceRead::new(&input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let slice = b\"Invalid\\x01String\\\"\"; // Contains a control character",
                "    let mut reader = SliceRead::new(slice);",
                "",
                "    let result = reader.ignore_str();",
                "",
                "    assert!(result.is_err());",
                "    // Assuming the error return value and related checks can be done accordingly",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let slice = b\"Hello, World!\"; // No closing quote",
                "    let mut reader = SliceRead::new(slice);",
                "",
                "    let result = reader.ignore_str();",
                "",
                "    assert!(result.is_err());",
                "    // Assuming the error return value and related checks can be done accordingly",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\\\\\\"abc\\\"\"; // String with an escaped quote",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(slice_read.index, 6); // Index should be at the end of the input",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"abc\\x01\"; // String with a control character",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_err());",
                "    // Assert that the error matches the expected ControlCharacterWhileParsingString",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"abc\"; // Incomplete string, missing ending quote",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_err());",
                "    // Assert that the error matches the expected EofWhileParsingString",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\\\\\\"\\\\abc\\\\\\\"\"; // String with multiple escaped quotes",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(slice_read.index, 7); // Index should be at the end after processing multiple escapes",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\\\\\\"abc\"; // String with an escape but missing the closing quote",
                "    let mut slice_read = SliceRead::new(input);",
                "    let result = slice_read.ignore_str();",
                "    assert!(result.is_err());",
                "    // Check if the error corresponds to EofWhileParsingString",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": true,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\\\"\"; // the string contains a double quote",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(reader.index, 15); // Check that index has moved past the quote",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\\\\\\\"\"; // the string contains an escaped double quote",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_ok());",
                "    assert_eq!(reader.index, 17); // Check that index has moved past the escaped quote",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": true,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\"; // the string is missing a closing double quote",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_err());",
                "    // Optionally check that the error is the expected one",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input_slice = b\"example string\\x01\"; // string contains a control character",
                "    let mut reader = SliceRead::new(input_slice);",
                "    let result = reader.ignore_str();",
                "    assert!(result.is_err());",
                "    // Optionally check that the error is ControlCharacterWhileParsingString",
                "}"
            ],
            [
                {
                    "start_line": 601,
                    "start_column": 16,
                    "end_line": 601,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/read.rs"
}