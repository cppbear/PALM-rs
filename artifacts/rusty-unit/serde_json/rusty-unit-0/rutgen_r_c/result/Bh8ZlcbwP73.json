{
    "function_name": "serde_json::read::read::SliceRead<'a>::parse_str_bytes",
    "tests": 19,
    "tests_lines": [
        14,
        17,
        17,
        11,
        17,
        18,
        10,
        15,
        91,
        91,
        3,
        11,
        11,
        6,
        9,
        18,
        18,
        18,
        12
    ],
    "oracles": 19,
    "oracles_compiled": 5,
    "oracles_compiled_rate": 26.31578947368421,
    "tests_compiled": 5,
    "tests_compiled_rate": 26.31578947368421,
    "oracles_run": 5,
    "oracles_passed": 0,
    "oracles_passed_rate": 0.0,
    "tests_run": 5,
    "tests_passed": 0,
    "tests_passed_rate": 0.0,
    "lines": 31,
    "lines_covered": 21,
    "lines_coveraged_rate": 67.74193548387096,
    "branches": 4,
    "branches_covered": 2,
    "branches_coverage_rate": 50.0,
    "codes_lines": [
        494,
        495,
        496,
        497,
        498,
        499,
        500,
        501,
        502,
        503,
        504,
        505,
        508,
        509,
        510,
        511,
        512,
        514,
        517,
        518,
        519,
        521,
        522,
        523,
        527,
        528,
        529,
        530,
        533,
        534,
        538
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let input: &[u8] = b\"invalid\\x01char\\\"\"; // Control character \\x01",
                "    let mut scratch = Vec::new();",
                "    let mut reader = SliceRead::new(input);",
                "    reader.index = 0; // Start from the beginning",
                "",
                "    let _result: Result<Reference<str>> = reader.parse_str_bytes(&mut scratch, false, |_, _| {",
                "        Ok(&\"\"[0..0]) // Dummy implementation for the assertion",
                "    });",
                "}"
            ],
            [
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                508,
                509,
                511,
                512,
                514,
                517,
                518,
                519,
                538
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello world\\\"\".to_vec(); // Mock input with no escape sequences",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let result = read.parse_str_bytes(&mut scratch, false, |_, borrowed| {",
                "        assert_eq!(borrowed, b\"hello world\");",
                "        Ok(borrowed)",
                "    });",
                "",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                508,
                509,
                511,
                512,
                514,
                517,
                518,
                519,
                538
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello\\\\nworld\\\"\".to_vec(); // Mock input with escape sequences",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let result = read.parse_str_bytes(&mut scratch, true, |_, borrowed| {",
                "        assert_eq!(borrowed, b\"hello\\nworld\");",
                "        Ok(borrowed)",
                "    });",
                "",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                508,
                509,
                511,
                512,
                514,
                517,
                518,
                519,
                538
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello\\x01world\\\"\".to_vec(); // Mock input with a control character",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let _ = read.parse_str_bytes(&mut scratch, false, |_, _| Ok(b\"unreachable\"));",
                "}"
            ],
            [
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                508,
                509,
                511,
                512,
                514,
                517,
                518,
                519,
                538
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello world\".to_vec(); // Mock input to trigger EOF",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let result = read.parse_str_bytes(&mut scratch, false, |_, _| Ok(b\"unreachable\"));",
                "",
                "    assert!(result.is_err());",
                "    // You can add further checks on the error if necessary.",
                "}"
            ],
            [
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                508,
                509,
                511,
                512,
                514,
                517,
                518,
                519,
                538
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 509,
            "start_column": 16,
            "end_line": 509,
            "end_column": 46,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 514,
            "start_column": 24,
            "end_line": 514,
            "end_column": 42,
            "positive": true,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let input: &[u8] = b\"invalid\\x01char\\\"\"; // Control character \\x01",
                "    let mut scratch = Vec::new();",
                "    let mut reader = SliceRead::new(input);",
                "    reader.index = 0; // Start from the beginning",
                "",
                "    let _result: Result<Reference<str>> = reader.parse_str_bytes(&mut scratch, false, |_, _| {",
                "        Ok(&\"\"[0..0]) // Dummy implementation for the assertion",
                "    });",
                "}"
            ],
            [
                {
                    "start_line": 509,
                    "start_column": 16,
                    "end_line": 509,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 514,
                    "start_column": 24,
                    "end_line": 514,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello world\\\"\".to_vec(); // Mock input with no escape sequences",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let result = read.parse_str_bytes(&mut scratch, false, |_, borrowed| {",
                "        assert_eq!(borrowed, b\"hello world\");",
                "        Ok(borrowed)",
                "    });",
                "",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 509,
                    "start_column": 16,
                    "end_line": 509,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 514,
                    "start_column": 24,
                    "end_line": 514,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello\\\\nworld\\\"\".to_vec(); // Mock input with escape sequences",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let result = read.parse_str_bytes(&mut scratch, true, |_, borrowed| {",
                "        assert_eq!(borrowed, b\"hello\\nworld\");",
                "        Ok(borrowed)",
                "    });",
                "",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 509,
                    "start_column": 16,
                    "end_line": 509,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 514,
                    "start_column": 24,
                    "end_line": 514,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello\\x01world\\\"\".to_vec(); // Mock input with a control character",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let _ = read.parse_str_bytes(&mut scratch, false, |_, _| Ok(b\"unreachable\"));",
                "}"
            ],
            [
                {
                    "start_line": 509,
                    "start_column": 16,
                    "end_line": 509,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 514,
                    "start_column": 24,
                    "end_line": 514,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut slice = b\"\\\"hello world\".to_vec(); // Mock input to trigger EOF",
                "    let mut scratch: Vec<u8> = Vec::new();",
                "    let mut read = SliceRead::new(&slice);",
                "    let result = read.parse_str_bytes(&mut scratch, false, |_, _| Ok(b\"unreachable\"));",
                "",
                "    assert!(result.is_err());",
                "    // You can add further checks on the error if necessary.",
                "}"
            ],
            [
                {
                    "start_line": 509,
                    "start_column": 16,
                    "end_line": 509,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 514,
                    "start_column": 24,
                    "end_line": 514,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/read.rs"
}