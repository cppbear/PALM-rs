{
  "name": "serde_json::de::de::Deserializer<R>::parse_object_colon",
  "name_with_impl": "serde_json::de::{impl#5}::parse_object_colon",
  "mod_info": {
    "name": "de",
    "loc": "src/lib.rs:418:1:418:12"
  },
  "visible": false,
  "loc": "src/de.rs:1059:5:1068:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.parse_whitespace() matches core::result::Result::Ok(val) is true\n",
        "// constraint: self.parse_whitespace() matches core::result::Result::Err(err) is true\n",
        "// constraint: self.parse_whitespace() matches core::result::Result::Ok(val) is false\n",
        "// constraint: self.parse_whitespace() matches core::result::Result::Err(err) is false\n",
        "// constraint: match $e {\n            core::result::Result::Ok(val) => val,\n            core::result::Result::Err(err) => return core::result::Result::Err(err),\n        } matches Some(_) is true\n",
        "// expected return value/type: Err(self.peek_error(ErrorCode::ExpectedColon))\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "fn test_parse_object_colon_success() {",
            "    struct TestParser {",
            "        input: Vec<u8>,",
            "        index: usize,",
            "    }",
            "",
            "    impl TestParser {",
            "        fn parse_whitespace(&mut self) -> Result<Option<u8>> {",
            "            if self.index < self.input.len() {",
            "                let b = self.input[self.index];",
            "                self.index += 1;",
            "                Ok(Some(b))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {",
            "            // Simulate eating a character (no-op for test)",
            "        }",
            "",
            "        fn peek_error(&self, code: ErrorCode) -> Error {",
            "            // Simulate returning a parsing error",
            "            Error::new(code)",
            "        }",
            "    }",
            "",
            "    // Expecting success, with ':' as the valid character after whitespace",
            "    let mut parser = TestParser { input: b\" :\".to_vec(), index: 0 };",
            "    let result = parser.parse_object_colon();",
            "    assert!(result.is_ok());",
            "}",
            "",
            "fn test_parse_object_colon_expected_colon_error() {",
            "    struct TestParser {",
            "        input: Vec<u8>,",
            "        index: usize,",
            "    }",
            "",
            "    impl TestParser {",
            "        fn parse_whitespace(&mut self) -> Result<Option<u8>> {",
            "            // Simulate valid whitespace followed by a non-colon character",
            "            if self.index < self.input.len() {",
            "                let b = self.input[self.index];",
            "                self.index += 1;",
            "                Ok(Some(b))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "        ",
            "        fn peek_error(&self, code: ErrorCode) -> Error {",
            "            Error::new(code)",
            "        }",
            "    }",
            "",
            "    // Using a non-colon character to trigger the expected error",
            "    let mut parser = TestParser { input: b\" a\".to_vec(), index: 0 };",
            "    let result = parser.parse_object_colon();",
            "    assert!(result.is_err());",
            "    assert_eq!(result.unwrap_err().code, ErrorCode::ExpectedColon);",
            "}",
            "",
            "fn test_parse_object_colon_eof_error() {",
            "    struct TestParser {",
            "        input: Vec<u8>,",
            "        index: usize,",
            "    }",
            "",
            "    impl TestParser {",
            "        fn parse_whitespace(&mut self) -> Result<Option<u8>> {",
            "            // Simulate end of input (like EOF)",
            "            if self.index < self.input.len() {",
            "                let b = self.input[self.index];",
            "                self.index += 1;",
            "                Ok(Some(b))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn peek_error(&self, code: ErrorCode) -> Error {",
            "            Error::new(code)",
            "        }",
            "    }",
            "",
            "    // Only whitespace followed by EOF",
            "    let mut parser = TestParser { input: b\" \".to_vec(), index: 0 };",
            "    let result = parser.parse_object_colon();",
            "    assert!(result.is_err());",
            "    assert_eq!(result.unwrap_err().code, ErrorCode::EofWhileParsingObject);",
            "}"
          ],
          "chain_tests": []
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.parse_whitespace() matches core::result::Result::Ok(val) is true\n",
        "// constraint: self.parse_whitespace() matches core::result::Result::Err(err) is true\n",
        "// constraint: self.parse_whitespace() matches  is true\n",
        "// constraint: match $e {\n            core::result::Result::Ok(val) => val,\n            core::result::Result::Err(err) => return core::result::Result::Err(err),\n        } matches Some(b':') is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "fn test_parse_object_colon_whitespace_ok_colon() {",
            "    struct Parser {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    impl Parser {",
            "        fn parse_whitespace(&mut self) -> Result<Option<u8>, ErrorCode> {",
            "            while self.position < self.input.len() && self.input[self.position].is_ascii_whitespace() {",
            "                self.position += 1;",
            "            }",
            "            if self.position < self.input.len() {",
            "                Ok(Some(self.input[self.position]))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "        ",
            "        fn eat_char(&mut self) {",
            "            self.position += 1;",
            "        }",
            "        ",
            "        fn peek_error(&self, error_code: ErrorCode) -> Error {",
            "            Error { code: error_code }",
            "        }",
            "        ",
            "        fn parse_object_colon(&mut self) -> Result<(), Error> {",
            "            match self.parse_whitespace()? {",
            "                Some(b':') => {",
            "                    self.eat_char();",
            "                    Ok(())",
            "                }",
            "                Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),",
            "                None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),",
            "            }",
            "        }",
            "    }",
            "",
            "    let mut parser = Parser { ",
            "        input: b\" : \".to_vec(), ",
            "        position: 0 ",
            "    };",
            "    assert_eq!(parser.parse_object_colon(), Ok(()));",
            "}",
            "",
            "fn test_parse_object_colon_whitespace_err() {",
            "    struct Parser {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    impl Parser {",
            "        fn parse_whitespace(&mut self) -> Result<Option<u8>, ErrorCode> {",
            "            while self.position < self.input.len() && self.input[self.position].is_ascii_whitespace() {",
            "                self.position += 1;",
            "            }",
            "            if self.position < self.input.len() {",
            "                Ok(Some(self.input[self.position]))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "        ",
            "        fn eat_char(&mut self) {",
            "            self.position += 1;",
            "        }",
            "        ",
            "        fn peek_error(&self, error_code: ErrorCode) -> Error {",
            "            Error { code: error_code }",
            "        }",
            "        ",
            "        fn parse_object_colon(&mut self) -> Result<(), Error> {",
            "            match self.parse_whitespace()? {",
            "                Some(b':') => {",
            "                    self.eat_char();",
            "                    Ok(())",
            "                }",
            "                Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),",
            "                None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),",
            "            }",
            "        }",
            "    }",
            "",
            "    let mut parser = Parser { ",
            "        input: b\" ; \".to_vec(), ",
            "        position: 0 ",
            "    };",
            "    assert_eq!(parser.parse_object_colon(), Err(Error { code: ErrorCode::ExpectedColon }));",
            "}",
            "",
            "fn test_parse_object_colon_eof() {",
            "    struct Parser {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "    ",
            "    impl Parser {",
            "        fn parse_whitespace(&mut self) -> Result<Option<u8>, ErrorCode> {",
            "            while self.position < self.input.len() && self.input[self.position].is_ascii_whitespace() {",
            "                self.position += 1;",
            "            }",
            "            if self.position < self.input.len() {",
            "                Ok(Some(self.input[self.position]))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "        ",
            "        fn eat_char(&mut self) {",
            "            self.position += 1;",
            "        }",
            "        ",
            "        fn peek_error(&self, error_code: ErrorCode) -> Error {",
            "            Error { code: error_code }",
            "        }",
            "        ",
            "        fn parse_object_colon(&mut self) -> Result<(), Error> {",
            "            match self.parse_whitespace()? {",
            "                Some(b':') => {",
            "                    self.eat_char();",
            "                    Ok(())",
            "                }",
            "                Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),",
            "                None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),",
            "            }",
            "        }",
            "    }",
            "",
            "    let mut parser = Parser { ",
            "        input: b\"\".to_vec(), ",
            "        position: 0 ",
            "    };",
            "    assert_eq!(parser.parse_object_colon(), Err(Error { code: ErrorCode::EofWhileParsingObject }));",
            "}"
          ],
          "chain_tests": []
        }
      ]
    }
  ]
}