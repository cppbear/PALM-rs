{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/de.rs\n// crate name is serde_json\nThe function to be tested is presented as follows:\n/// Deserialize an instance of type `T` from an I/O stream of JSON.\n///\n/// The content of the I/O stream is deserialized directly from the stream\n/// without being buffered in memory by serde_json.\n///\n/// When reading from a source against which short reads are not efficient, such\n/// as a [`File`], you will want to apply your own buffering because serde_json\n/// will not buffer the input. See [`std::io::BufReader`].\n///\n/// It is expected that the input stream ends after the deserialized object.\n/// If the stream does not end, such as in the case of a persistent socket connection,\n/// this function will not return. It is possible instead to deserialize from a prefix of an input\n/// stream without looking for EOF by managing your own [`Deserializer`].\n///\n/// Note that counter to intuition, this function is usually slower than\n/// reading a file completely into memory and then applying [`from_str`]\n/// or [`from_slice`] on it. See [issue #160].\n///\n/// [`File`]: std::fs::File\n/// [issue #160]: https://github.com/serde-rs/json/issues/160\n///\n/// # Example\n///\n/// Reading the contents of a file.\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// use std::error::Error;\n/// use std::fs::File;\n/// use std::io::BufReader;\n/// use std::path::Path;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn read_user_from_file<P: AsRef<Path>>(path: P) -> Result<User, Box<dyn Error>> {\n///     // Open the file in read-only mode with buffer.\n///     let file = File::open(path)?;\n///     let reader = BufReader::new(file);\n///\n///     // Read the JSON contents of the file as an instance of `User`.\n///     let u = serde_json::from_reader(reader)?;\n///\n///     // Return the `User`.\n///     Ok(u)\n/// }\n///\n/// fn main() {\n/// # }\n/// # fn fake_main() {\n///     let u = read_user_from_file(\"test.json\").unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// Reading from a persistent socket connection.\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// use std::error::Error;\n/// use std::io::BufReader;\n/// use std::net::{TcpListener, TcpStream};\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn read_user_from_stream(stream: &mut BufReader<TcpStream>) -> Result<User, Box<dyn Error>> {\n///     let mut de = serde_json::Deserializer::from_reader(stream);\n///     let u = User::deserialize(&mut de)?;\n///\n///     Ok(u)\n/// }\n///\n/// fn main() {\n/// # }\n/// # fn fake_main() {\n///     let listener = TcpListener::bind(\"127.0.0.1:4000\").unwrap();\n///\n///     for tcp_stream in listener.incoming() {\n///         let mut buffered = BufReader::new(tcp_stream.unwrap());\n///         println!(\"{:#?}\", read_user_from_stream(&mut buffered));\n///     }\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\npub fn from_reader<R, T>(rdr: R) -> Result<T>\nwhere\n    R: crate::io::Read,\n    T: de::DeserializeOwned,\n{\n    from_trait(read::IoRead::new(rdr))\n}\n",
  "depend_pt": ""
}