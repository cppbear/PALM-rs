{
    "function_name": "serde_json::de::de::Deserializer<R>::parse_ident",
    "tests": 59,
    "tests_lines": [
        17,
        24,
        24,
        31,
        31,
        13,
        13,
        13,
        16,
        16,
        19,
        22,
        22,
        13,
        13,
        14,
        14,
        15,
        15,
        17,
        17,
        13,
        13,
        15,
        15,
        26,
        27,
        28,
        29,
        25,
        25,
        35,
        17,
        20,
        23,
        26,
        12,
        12,
        12,
        14,
        14,
        16,
        16,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        17,
        13,
        13,
        13,
        13
    ],
    "oracles": 17,
    "oracles_compiled": 5,
    "oracles_compiled_rate": 29.411764705882355,
    "tests_compiled": 6,
    "tests_compiled_rate": 10.16949152542373,
    "oracles_run": 5,
    "oracles_passed": 5,
    "oracles_passed_rate": 100.0,
    "tests_run": 6,
    "tests_passed": 6,
    "tests_passed_rate": 100.0,
    "lines": 10,
    "lines_covered": 8,
    "lines_coveraged_rate": 80.0,
    "branches": 2,
    "branches_covered": 1,
    "branches_coverage_rate": 50.0,
    "codes_lines": [
        445,
        446,
        447,
        449,
        451,
        452,
        453,
        454,
        459,
        460
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"abcde\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'a', b'b', b'c', b'd', b'e'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"abcde\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'a', b'b', b'c', b'd', b'e'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                445,
                446,
                447,
                451,
                452,
                454,
                459,
                460
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"ABCDE\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'A', b'B', b'C', b'D', b'E'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"ABCDE\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'A', b'B', b'C', b'D', b'E'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                445,
                446,
                447,
                451,
                452,
                454,
                459,
                460
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"123\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'1', b'2', b'3'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer {",
                "    read: StrRead::new(\"123\"),",
                "    scratch: Vec::new(),",
                "    remaining_depth: 0,",
                "    };",
                "    let ident = [b'1', b'2', b'3'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                445,
                446,
                447,
                451,
                452,
                454,
                459,
                460
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"!@#\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'!', b'@', b'#'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"!@#\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'!', b'@', b'#'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                445,
                446,
                447,
                451,
                452,
                454,
                459,
                460
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"\\x00\\x01\\x02\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"\\x00\\x01\\x02\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                445,
                446,
                447,
                451,
                452,
                454,
                459,
                460
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"\\x00\\x01\\x02\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"\\x00\\x01\\x02\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert_eq!(result.unwrap(), ());",
                "}"
            ],
            [
                445,
                446,
                447,
                451,
                452,
                454,
                459,
                460
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 452,
            "start_column": 24,
            "end_line": 452,
            "end_column": 41,
            "positive": false,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"abcde\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'a', b'b', b'c', b'd', b'e'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"abcde\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'a', b'b', b'c', b'd', b'e'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 452,
                    "start_column": 24,
                    "end_line": 452,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"ABCDE\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'A', b'B', b'C', b'D', b'E'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"ABCDE\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'A', b'B', b'C', b'D', b'E'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 452,
                    "start_column": 24,
                    "end_line": 452,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"123\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'1', b'2', b'3'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer {",
                "    read: StrRead::new(\"123\"),",
                "    scratch: Vec::new(),",
                "    remaining_depth: 0,",
                "    };",
                "    let ident = [b'1', b'2', b'3'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 452,
                    "start_column": 24,
                    "end_line": 452,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"!@#\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'!', b'@', b'#'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"!@#\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'!', b'@', b'#'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 452,
                    "start_column": 24,
                    "end_line": 452,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"\\x00\\x01\\x02\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"\\x00\\x01\\x02\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 452,
                    "start_column": 24,
                    "end_line": 452,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut deserializer = Deserializer {",
                "        read: StrRead::new(\"\\x00\\x01\\x02\"),",
                "        scratch: Vec::new(),",
                "        remaining_depth: 0,",
                "    };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    deserializer.parse_ident(&ident);",
                "    let mut deserializer = Deserializer { read: StrRead::new(\"\\x00\\x01\\x02\"), scratch: Vec::new(), remaining_depth: 0 };",
                "    let ident = [b'\\x00', b'\\x01', b'\\x02'];",
                "    let result = deserializer.parse_ident(&ident);",
                "    assert_eq!(result.unwrap(), ());",
                "}"
            ],
            [
                {
                    "start_line": 452,
                    "start_column": 24,
                    "end_line": 452,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/de.rs"
}