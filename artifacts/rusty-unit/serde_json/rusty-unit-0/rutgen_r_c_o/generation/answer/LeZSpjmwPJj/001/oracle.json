[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn new(line: usize, column: usize) -> Self {",
          "            Self { line, column }",
          "        }",
          "    }",
          "",
          "    trait Read<'de> {",
          "        fn position(&self) -> Position;",
          "    }",
          "",
          "    impl<'de> Read<'de> for TestReader {",
          "        fn position(&self) -> Position {",
          "            Position {",
          "                line: self.line,",
          "                column: self.column,",
          "            }",
          "        }",
          "    }",
          "",
          "    let reader = TestReader::new(0, 0);",
          "    let reason = ErrorCode::ExpectedColon;",
          "    let _ = error(&reader, reason);",
          "}"
        ],
        "oracles": [
          [
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());"
          ],
          [
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.unwrap_err().err.line, 0);"
          ],
          [
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.unwrap_err().err.column, 0);"
          ],
          [
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.unwrap_err().err.code, ErrorCode::ExpectedColon);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    trait Read<'de> {",
            "        fn position(&self) -> Position;",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    trait Read<'de> {",
            "        fn position(&self) -> Position;",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.unwrap_err().err.line, 0);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    trait Read<'de> {",
            "        fn position(&self) -> Position;",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.unwrap_err().err.column, 0);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    trait Read<'de> {",
            "        fn position(&self) -> Position;",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(0, 0);",
            "    let reason = ErrorCode::ExpectedColon;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.unwrap_err().err.code, ErrorCode::ExpectedColon);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn new(line: usize, column: usize) -> Self {",
          "            Self { line, column }",
          "        }",
          "    }",
          "",
          "    impl<'de> Read<'de> for TestReader {",
          "        fn position(&self) -> Position {",
          "            Position {",
          "                line: self.line,",
          "                column: self.column,",
          "            }",
          "        }",
          "    }",
          "",
          "    let reader = TestReader::new(128, 256);",
          "    let reason = ErrorCode::TrailingComma;",
          "    let _ = error(&reader, reason);",
          "}"
        ],
        "oracles": [
          [
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());"
          ],
          [
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.err().unwrap().err.code, ErrorCode::TrailingComma);"
          ],
          [
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.err().unwrap().err.line, 128);"
          ],
          [
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.err().unwrap().err.column, 256);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.err().unwrap().err.code, ErrorCode::TrailingComma);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.err().unwrap().err.line, 128);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(128, 256);",
            "    let reason = ErrorCode::TrailingComma;",
            "    let result = error(&reader, reason);",
            "    assert_eq!(result.err().unwrap().err.column, 256);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn new(line: usize, column: usize) -> Self {",
          "            Self { line, column }",
          "        }",
          "    }",
          "",
          "    impl<'de> Read<'de> for TestReader {",
          "        fn position(&self) -> Position {",
          "            Position {",
          "                line: self.line,",
          "                column: self.column,",
          "            }",
          "        }",
          "    }",
          "",
          "    let reader = TestReader::new(64, 128);",
          "    let reason = ErrorCode::InvalidNumber;",
          "    let _ = error(&reader, reason);",
          "}"
        ],
        "oracles": [
          [
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());"
          ],
          [
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.err.line, 64);"
          ],
          [
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.err.column, 128);"
          ],
          [
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.err.code, ErrorCode::InvalidNumber);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.err.line, 64);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.err.column, 128);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(64, 128);",
            "    let reason = ErrorCode::InvalidNumber;",
            "    let result = error(&reader, reason);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.err.code, ErrorCode::InvalidNumber);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        line: usize,",
          "        column: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn new(line: usize, column: usize) -> Self {",
          "            Self { line, column }",
          "        }",
          "    }",
          "",
          "    impl<'de> Read<'de> for TestReader {",
          "        fn position(&self) -> Position {",
          "            Position {",
          "                line: self.line,",
          "                column: self.column,",
          "            }",
          "        }",
          "    }",
          "",
          "    let reader = TestReader::new(1, 1);",
          "    let reason = ErrorCode::EofWhileParsingObject;",
          "    let _ = error(&reader, reason);",
          "}"
        ],
        "oracles": [
          [
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());"
          ],
          [
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    if let Err(err) = result {",
            "    assert_eq!(err.err.line, 1);"
          ],
          [
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    if let Err(err) = result {",
            "    assert_eq!(err.err.column, 1);"
          ],
          [
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    if let Err(err) = result {",
            "    assert_eq!(err.err.code, reason);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    if let Err(err) = result {",
            "    assert_eq!(err.err.line, 1);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    if let Err(err) = result {",
            "    assert_eq!(err.err.column, 1);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        line: usize,",
            "        column: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            Self { line, column }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for TestReader {",
            "        fn position(&self) -> Position {",
            "            Position {",
            "                line: self.line,",
            "                column: self.column,",
            "            }",
            "        }",
            "    }",
            "",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let _ = error(&reader, reason);",
            "    let reader = TestReader::new(1, 1);",
            "    let reason = ErrorCode::EofWhileParsingObject;",
            "    let result = error(&reader, reason);",
            "    if let Err(err) = result {",
            "    assert_eq!(err.err.code, reason);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]