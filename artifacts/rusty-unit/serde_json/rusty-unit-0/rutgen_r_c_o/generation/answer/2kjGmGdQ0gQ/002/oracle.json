[
  {
    "uses": [
      "use std::collections::HashMap;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = 42;",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = 42;",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value = 42;",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"42\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = 42;",
            "    let result = to_string(&value);",
            "    let value = 42;",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let value = 42;",
            "    let result = to_string(&value);",
            "    let value = 42;",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"42\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = \"Hello, world!\";",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = \"Hello, world!\";",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value = \"Hello, world!\";",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"Hello, world!\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = \"Hello, world!\";",
            "    let result = to_string(&value);",
            "    let value = \"Hello, world!\";",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let value = \"Hello, world!\";",
            "    let result = to_string(&value);",
            "    let value = \"Hello, world!\";",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"Hello, world!\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = vec![1, 2, 3, 4, 5];",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = vec![1, 2, 3, 4, 5];",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value = vec![1, 2, 3, 4, 5];",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"[1,2,3,4,5]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = vec![1, 2, 3, 4, 5];",
            "    let result = to_string(&value);",
            "    let value = vec![1, 2, 3, 4, 5];",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let value = vec![1, 2, 3, 4, 5];",
            "    let result = to_string(&value);",
            "    let value = vec![1, 2, 3, 4, 5];",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"[1,2,3,4,5]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct Inner {",
          "        x: i32,",
          "        y: String,",
          "    }",
          "",
          "    #[derive(serde::Serialize)]",
          "    struct Outer {",
          "        a: Inner,",
          "        b: Vec<i32>,",
          "    }",
          "",
          "    let inner = Inner {",
          "        x: 10,",
          "        y: \"Inner String\".to_string(),",
          "    };",
          "",
          "    let outer = Outer {",
          "        a: inner,",
          "        b: vec![1, 2, 3],",
          "    };",
          "",
          "    let result = to_string(&outer);",
          "}"
        ],
        "oracles": [
          [
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"\\\"a\\\":\"));"
          ],
          [
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"\\\"b\\\":\"));"
          ],
          [
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"10\"));"
          ],
          [
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"\\\"Inner String\\\"\"));"
          ],
          [
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"[1,2,3]\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct Inner {",
            "        x: i32,",
            "        y: String,",
            "    }",
            "",
            "    #[derive(serde::Serialize)]",
            "    struct Outer {",
            "        a: Inner,",
            "        b: Vec<i32>,",
            "    }",
            "",
            "    let inner = Inner {",
            "        x: 10,",
            "        y: \"Inner String\".to_string(),",
            "    };",
            "",
            "    let outer = Outer {",
            "        a: inner,",
            "        b: vec![1, 2, 3],",
            "    };",
            "",
            "    let result = to_string(&outer);",
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct Inner {",
            "        x: i32,",
            "        y: String,",
            "    }",
            "",
            "    #[derive(serde::Serialize)]",
            "    struct Outer {",
            "        a: Inner,",
            "        b: Vec<i32>,",
            "    }",
            "",
            "    let inner = Inner {",
            "        x: 10,",
            "        y: \"Inner String\".to_string(),",
            "    };",
            "",
            "    let outer = Outer {",
            "        a: inner,",
            "        b: vec![1, 2, 3],",
            "    };",
            "",
            "    let result = to_string(&outer);",
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"\\\"a\\\":\"));",
            "}"
          ],
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct Inner {",
            "        x: i32,",
            "        y: String,",
            "    }",
            "",
            "    #[derive(serde::Serialize)]",
            "    struct Outer {",
            "        a: Inner,",
            "        b: Vec<i32>,",
            "    }",
            "",
            "    let inner = Inner {",
            "        x: 10,",
            "        y: \"Inner String\".to_string(),",
            "    };",
            "",
            "    let outer = Outer {",
            "        a: inner,",
            "        b: vec![1, 2, 3],",
            "    };",
            "",
            "    let result = to_string(&outer);",
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"\\\"b\\\":\"));",
            "}"
          ],
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct Inner {",
            "        x: i32,",
            "        y: String,",
            "    }",
            "",
            "    #[derive(serde::Serialize)]",
            "    struct Outer {",
            "        a: Inner,",
            "        b: Vec<i32>,",
            "    }",
            "",
            "    let inner = Inner {",
            "        x: 10,",
            "        y: \"Inner String\".to_string(),",
            "    };",
            "",
            "    let outer = Outer {",
            "        a: inner,",
            "        b: vec![1, 2, 3],",
            "    };",
            "",
            "    let result = to_string(&outer);",
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"10\"));",
            "}"
          ],
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct Inner {",
            "        x: i32,",
            "        y: String,",
            "    }",
            "",
            "    #[derive(serde::Serialize)]",
            "    struct Outer {",
            "        a: Inner,",
            "        b: Vec<i32>,",
            "    }",
            "",
            "    let inner = Inner {",
            "        x: 10,",
            "        y: \"Inner String\".to_string(),",
            "    };",
            "",
            "    let outer = Outer {",
            "        a: inner,",
            "        b: vec![1, 2, 3],",
            "    };",
            "",
            "    let result = to_string(&outer);",
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"\\\"Inner String\\\"\"));",
            "}"
          ],
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct Inner {",
            "        x: i32,",
            "        y: String,",
            "    }",
            "",
            "    #[derive(serde::Serialize)]",
            "    struct Outer {",
            "        a: Inner,",
            "        b: Vec<i32>,",
            "    }",
            "",
            "    let inner = Inner {",
            "        x: 10,",
            "        y: \"Inner String\".to_string(),",
            "    };",
            "",
            "    let outer = Outer {",
            "        a: inner,",
            "        b: vec![1, 2, 3],",
            "    };",
            "",
            "    let result = to_string(&outer);",
            "    let inner = Inner { x: 10, y: \"Inner String\".to_string() };",
            "    let outer = Outer { a: inner, b: vec![1, 2, 3] };",
            "    let result = to_string(&outer);",
            "    let string = result.unwrap();",
            "    assert!(string.contains(\"[1,2,3]\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::HashMap;",
          "",
          "    let mut map = HashMap::new();",
          "    map.insert(\"key1\", 100);",
          "    map.insert(\"key2\", 200);",
          "    let result = to_string(&map);",
          "}"
        ],
        "oracles": [
          [
            "    let map = HashMap::new();",
            "    map.insert(\"key1\", 100);",
            "    map.insert(\"key2\", 200);",
            "    let result = to_string(&map);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let map = HashMap::new();",
            "    map.insert(\"key1\", 100);",
            "    map.insert(\"key2\", 200);",
            "    let result = to_string(&map);",
            "    assert_eq!(result.unwrap(), r#\"{\"key1\":100,\"key2\":200}\"#);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use std::collections::HashMap;",
            "",
            "    let mut map = HashMap::new();",
            "    map.insert(\"key1\", 100);",
            "    map.insert(\"key2\", 200);",
            "    let result = to_string(&map);",
            "    let map = HashMap::new();",
            "    map.insert(\"key1\", 100);",
            "    map.insert(\"key2\", 200);",
            "    let result = to_string(&map);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    use std::collections::HashMap;",
            "",
            "    let mut map = HashMap::new();",
            "    map.insert(\"key1\", 100);",
            "    map.insert(\"key2\", 200);",
            "    let result = to_string(&map);",
            "    let map = HashMap::new();",
            "    map.insert(\"key1\", 100);",
            "    map.insert(\"key2\", 200);",
            "    let result = to_string(&map);",
            "    assert_eq!(result.unwrap(), r#\"{\"key1\":100,\"key2\":200}\"#);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    enum MyEnum {",
          "        VariantOne,",
          "        VariantTwo(i32),",
          "    }",
          "",
          "    let value = MyEnum::VariantTwo(10);",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = MyEnum::VariantTwo(10);",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value = MyEnum::VariantTwo(10);",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), r#\"{\"VariantTwo\":10}\"#);"
          ]
        ],
        "codes": [
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    enum MyEnum {",
            "        VariantOne,",
            "        VariantTwo(i32),",
            "    }",
            "",
            "    let value = MyEnum::VariantTwo(10);",
            "    let result = to_string(&value);",
            "    let value = MyEnum::VariantTwo(10);",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    enum MyEnum {",
            "        VariantOne,",
            "        VariantTwo(i32),",
            "    }",
            "",
            "    let value = MyEnum::VariantTwo(10);",
            "    let result = to_string(&value);",
            "    let value = MyEnum::VariantTwo(10);",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), r#\"{\"VariantTwo\":10}\"#);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(serde::Serialize)]",
          "    struct OptionStruct {",
          "        optional: Option<String>,",
          "    }",
          "",
          "    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"{\\\"optional\\\":\\\"Some Value\\\"}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct OptionStruct {",
            "        optional: Option<String>,",
            "    }",
            "",
            "    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };",
            "    let result = to_string(&value);",
            "    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    #[derive(serde::Serialize)]",
            "    struct OptionStruct {",
            "        optional: Option<String>,",
            "    }",
            "",
            "    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };",
            "    let result = to_string(&value);",
            "    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"{\\\"optional\\\":\\\"Some Value\\\"}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = \"\";",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = \"\";",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value = \"\";",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = \"\";",
            "    let result = to_string(&value);",
            "    let value = \"\";",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let value = \"\";",
            "    let result = to_string(&value);",
            "    let value = \"\";",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: Vec<i32> = Vec::new();",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value: Vec<i32> = Vec::new();",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value: Vec<i32> = Vec::new();",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"[]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value: Vec<i32> = Vec::new();",
            "    let result = to_string(&value);",
            "    let value: Vec<i32> = Vec::new();",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let value: Vec<i32> = Vec::new();",
            "    let result = to_string(&value);",
            "    let value: Vec<i32> = Vec::new();",
            "    let result = to_string(&value);",
            "    assert_eq!(result.unwrap(), \"[]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";",
          "    let result = to_string(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";",
            "    let result = to_string(&value);",
            "    let string = result.unwrap();",
            "    assert_eq!(string, \"String with \\\"quotes\\\", newline \\n and backslash \\\\\".to_string());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";",
            "    let result = to_string(&value);",
            "    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";",
            "    let result = to_string(&value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";",
            "    let result = to_string(&value);",
            "    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";",
            "    let result = to_string(&value);",
            "    let string = result.unwrap();",
            "    assert_eq!(string, \"String with \\\"quotes\\\", newline \\n and backslash \\\\\".to_string());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]