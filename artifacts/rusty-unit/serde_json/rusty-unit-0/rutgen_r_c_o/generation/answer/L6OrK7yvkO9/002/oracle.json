[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "struct TestVisitor;",
      "",
      "impl de::Visitor<'static> for TestVisitor {",
      "    type Value = bool;",
      "",
      "    fn visit_bool(self, value: bool) -> Result<Self::Value> {",
      "        Ok(value)",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        input: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn next_char(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.input.len() {",
          "                let ch = self.input[self.position];",
          "                self.position += 1;",
          "                Ok(Some(ch))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn eat_char(&mut self) {}",
          "",
          "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
          "            let id_len = ident.len();",
          "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
          "                self.position += id_len;",
          "                Ok(())",
          "            } else {",
          "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        ",
          "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
          "            Ok(\"\")",
          "        }",
          "    }",
          "",
          "    let mut reader = TestReader {",
          "        input: b\"true\".to_vec(),",
          "        position: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer {",
          "        read: reader,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 0,",
          "    };",
          "",
          "    let _result = deserializer.deserialize_bool(TestVisitor);",
          "}"
        ],
        "oracles": [
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), true);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), false);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"true\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), true);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"true\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"false\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), false);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"true\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"false\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"true\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), true);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"true\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), false);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"true\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"true\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"true\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), true);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"true\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"true\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"false\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(result.unwrap(), false);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"true\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"true\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"false\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    reader.position = 0;",
            "    reader.input = b\"\".to_vec();",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        input: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn next_char(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.input.len() {",
          "                let ch = self.input[self.position];",
          "                self.position += 1;",
          "                Ok(Some(ch))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn eat_char(&mut self) {}",
          "",
          "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
          "            let id_len = ident.len();",
          "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
          "                self.position += id_len;",
          "                Ok(())",
          "            } else {",
          "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
          "            }",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        ",
          "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
          "            Ok(\"\")",
          "        }",
          "    }",
          "",
          "    let mut reader = TestReader {",
          "        input: b\"false\".to_vec(),",
          "        position: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer {",
          "        read: reader,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 0,",
          "    };",
          "",
          "    let _result = deserializer.deserialize_bool(TestVisitor);",
          "}"
        ],
        "oracles": [
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_ok() && result.unwrap() == true);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_ok() && result.unwrap() == false);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedSomeIdent);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedSomeIdent);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedDoubleQuote);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedDoubleQuote);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::EofWhileParsingValue);"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::EofWhileParsingValue);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_ok() && result.unwrap() == true);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_ok() && result.unwrap() == false);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedSomeIdent);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedSomeIdent);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedDoubleQuote);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::ExpectedDoubleQuote);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::EofWhileParsingValue);",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {",
            "            let id_len = ident.len();",
            "            if self.position + id_len <= self.input.len() && &self.input[self.position..self.position + id_len] == ident {",
            "                self.position += id_len;",
            "                Ok(())",
            "            } else {",
            "                Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "            }",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"false\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"invalid\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"terse\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\\\"extra\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let mut deserializer = Deserializer { read: reader, scratch: Vec::new(), remaining_depth: 0 };",
            "    let result = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(result.is_err() && result.err().unwrap().err == ErrorCode::EofWhileParsingValue);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        input: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn next_char(&mut self) -> Result<Option<u8>> {",
          "            if self.position < self.input.len() {",
          "                let ch = self.input[self.position];",
          "                self.position += 1;",
          "                Ok(Some(ch))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "",
          "        fn eat_char(&mut self) {}",
          "",
          "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
          "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        ",
          "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
          "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
          "        }",
          "    }",
          "",
          "    let mut reader = TestReader {",
          "        input: b\"notabool\".to_vec(),",
          "        position: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer {",
          "        read: reader,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 0,",
          "    };",
          "",
          "    let _result = deserializer.deserialize_bool(TestVisitor);",
          "}"
        ],
        "oracles": [
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(true));"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(false));"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(true));"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(false));"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"unknown\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"unknown\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());"
          ],
          [
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"unknown\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    deserializer.eat_char();",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(true));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(false));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(true));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert_eq!(value, Ok(false));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"unknown\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"unknown\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            if self.position < self.input.len() {",
            "                let ch = self.input[self.position];",
            "                self.position += 1;",
            "                Ok(Some(ch))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Err(Error::syntax(ErrorCode::ExpectedSomeIdent, 0, 0))",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Err(Error::syntax(ErrorCode::InvalidNumber, 0, 0))",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: b\"notabool\".to_vec(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"notabool\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"f\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"true\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"false\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"unknown\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"\".to_vec(), position: 0 };",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    let mut reader = TestReader { input: b\"t\".to_vec(), position: 0 };",
            "    deserializer.eat_char();",
            "    let value = deserializer.deserialize_bool(TestVisitor);",
            "    assert!(value.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct TestReader {",
          "        input: Vec<u8>,",
          "        position: usize,",
          "    }",
          "",
          "    impl TestReader {",
          "        fn next_char(&mut self) -> Result<Option<u8>> {",
          "            Ok(None)",
          "        }",
          "",
          "        fn eat_char(&mut self) {}",
          "",
          "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
          "            Ok(())",
          "        }",
          "",
          "        fn discard(&mut self) {}",
          "        ",
          "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
          "            Ok(\"\")",
          "        }",
          "    }",
          "",
          "    let mut reader = TestReader {",
          "        input: Vec::new(),",
          "        position: 0,",
          "    };",
          "",
          "    let mut deserializer = Deserializer {",
          "        read: reader,",
          "        scratch: Vec::new(),",
          "        remaining_depth: 0,",
          "    };",
          "",
          "    let _result = deserializer.deserialize_bool(TestVisitor);",
          "}"
        ],
        "oracles": [
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.next_char().is_err());"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.peek_error(ErrorCode::EofWhileParsingValue).is_err());"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(matches!(deserializer.deserialize_bool(TestVisitor), Err(_)));"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.de.eat_char().is_ok());"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.de.parse_ident(b\"alse\\\"\").is_ok());"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(matches!(deserializer.de.read.parse_str(&mut deserializer.scratch), Err(_)));"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    let peek_value: Result<Option<u8>, _> = Ok(Some(b't'));",
            "    assert!(peek_value.unwrap() == Some(b't'));"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    let peek_value: Result<Option<u8>, _> = Ok(Some(b't'));",
            "    let peek_value_false: Result<Option<u8>, _> = Ok(Some(b'f'));",
            "    assert!(peek_value_false.unwrap() == Some(b'f'));"
          ],
          [
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    let peek_value: Result<Option<u8>, _> = Ok(Some(b't'));",
            "    let peek_value_false: Result<Option<u8>, _> = Ok(Some(b'f'));",
            "    let peek_value_invalid: Result<Option<u8>, _> = Ok(Some(b'x'));",
            "    assert!(peek_value_invalid.unwrap() == Some(b'x'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.next_char().is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.peek_error(ErrorCode::EofWhileParsingValue).is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(matches!(deserializer.deserialize_bool(TestVisitor), Err(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.de.eat_char().is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(deserializer.de.parse_ident(b\"alse\\\"\").is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    assert!(matches!(deserializer.de.read.parse_str(&mut deserializer.scratch), Err(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    let peek_value: Result<Option<u8>, _> = Ok(Some(b't'));",
            "    assert!(peek_value.unwrap() == Some(b't'));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    let peek_value: Result<Option<u8>, _> = Ok(Some(b't'));",
            "    let peek_value_false: Result<Option<u8>, _> = Ok(Some(b'f'));",
            "    assert!(peek_value_false.unwrap() == Some(b'f'));",
            "}"
          ],
          [
            "{",
            "    struct TestReader {",
            "        input: Vec<u8>,",
            "        position: usize,",
            "    }",
            "",
            "    impl TestReader {",
            "        fn next_char(&mut self) -> Result<Option<u8>> {",
            "            Ok(None)",
            "        }",
            "",
            "        fn eat_char(&mut self) {}",
            "",
            "        fn parse_ident(&mut self, _ident: &[u8]) -> Result<()> {",
            "            Ok(())",
            "        }",
            "",
            "        fn discard(&mut self) {}",
            "        ",
            "        fn parse_str(&mut self, _scratch: &mut Vec<u8>) -> Result<&str> {",
            "            Ok(\"\")",
            "        }",
            "    }",
            "",
            "    let mut reader = TestReader {",
            "        input: Vec::new(),",
            "        position: 0,",
            "    };",
            "",
            "    let mut deserializer = Deserializer {",
            "        read: reader,",
            "        scratch: Vec::new(),",
            "        remaining_depth: 0,",
            "    };",
            "",
            "    let _result = deserializer.deserialize_bool(TestVisitor);",
            "    let reader = TestReader {",
            "    input: Vec::new(),",
            "    position: 0,",
            "    };",
            "    let mut deserializer = Deserializer {",
            "    read: reader,",
            "    scratch: Vec::new(),",
            "    remaining_depth: 0,",
            "    };",
            "    let peek_value: Result<Option<u8>, _> = Ok(Some(b't'));",
            "    let peek_value_false: Result<Option<u8>, _> = Ok(Some(b'f'));",
            "    let peek_value_invalid: Result<Option<u8>, _> = Ok(Some(b'x'));",
            "    assert!(peek_value_invalid.unwrap() == Some(b'x'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]