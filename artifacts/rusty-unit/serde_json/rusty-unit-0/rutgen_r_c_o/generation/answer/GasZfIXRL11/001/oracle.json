[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'n']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Unit, _)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Seq, _)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Str(_), _)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(false), _)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Map, _)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(true), _)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Unit, _)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Seq, _)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Str(_), _)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(false), _)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Map, _)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(true), _)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'n']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'f']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Unit, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Bool(true), &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Bool(false), &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Str(_, &Expected))));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[,']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Seq, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[,']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Map, &Expected)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Unit, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Bool(true), &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Bool(false), &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(_, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Str(_, &Expected))));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[,']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Seq, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'f']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[,']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, Error::invalid_type(Unexpected::Map, &Expected)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b't']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [],
        "codes": [],
        "can_compile": [],
        "repaired": []
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'-']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidNumber);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(deserializer.remaining_depth, 1);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unit));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Bool(true)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Bool(false)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unsigned(0)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unsigned(1)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unsigned(9)));"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::ExpectedSomeValue);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::ExpectedSomeValue);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.to_string().contains(\"expected a number, but found a string\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidNumber);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(deserializer.remaining_depth, 1);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unit));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Bool(true)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Bool(false)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unsigned(0)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unsigned(1)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::InvalidType(Unexpected::Unsigned(9)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::ExpectedSomeValue);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(error.code(), ErrorCode::ExpectedSomeValue);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_instance_of::<Error>());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'-']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'-']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'n']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b't']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'f']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'0']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'1']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'9']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'[']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'{']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer {",
            "    read: MockRead::new(&[b'\"']),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.to_string().contains(\"expected a number, but found a string\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'1']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(result.unwrap_err().code, ErrorCode::InvalidNumber);"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(result.unwrap_err().position.line, 1);"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(result.unwrap_err().position.column, 1);"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(deserializer.remaining_depth, 1);"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(deserializer.scratch.len(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'1']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'1']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(result.unwrap_err().code, ErrorCode::InvalidNumber);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'1']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(result.unwrap_err().position.line, 1);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'1']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(result.unwrap_err().position.column, 1);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'1']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(deserializer.remaining_depth, 1);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'1']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let result = deserializer.peek_invalid_type(&Expected);",
            "    assert_eq!(deserializer.scratch.len(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'\"']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Unit, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Seq, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Str(_), &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(false), &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Map, &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(true), &Expected)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'9']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Unit, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Seq, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Str(_), &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(false), &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Map, &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error, de::Error::invalid_type(Unexpected::Bool(true), &Expected)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'\"']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'9']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(error.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'[']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [],
        "codes": [],
        "can_compile": [],
        "repaired": []
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'{']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'3']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ],
          [
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'3']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'4']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'3']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: MockRead::new(&[b'{']),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 1,",
            "    };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'n']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'[']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'\"']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'f']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'{']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b't']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'-']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'0']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'1']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'2']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'3']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    let mut deserializer = Deserializer { read: MockRead::new(&[b'4']), scratch: Vec::new(), remaining_depth: 1 };",
            "    let error = deserializer.peek_invalid_type(&Expected);",
            "    assert!(matches!(error.kind(), ErrorCode::ExpectedSomeValue));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: MockRead::new(&[b'2']),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 1,",
          "    };",
          "    let error = deserializer.peek_invalid_type(&Expected);",
          "}"
        ],
        "oracles": [],
        "codes": [],
        "can_compile": [],
        "repaired": []
      }
    ]
  }
]