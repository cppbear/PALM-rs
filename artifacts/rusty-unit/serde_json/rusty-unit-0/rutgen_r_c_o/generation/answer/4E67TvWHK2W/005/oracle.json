[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::from(\"0.123\"),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 5,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "    let _ = deserializer.parse_decimal(true, 0, 0);",
          "}"
        ],
        "oracles": [
          [
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    assert_eq!(f64_value, 0.123);"
          ],
          [
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    assert!(deserializer_with_overflow.parse_decimal(true, u64::MAX, 0).is_err());"
          ],
          [
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    assert!(result_invalid.is_err());"
          ],
          [
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    assert_eq!(result_invalid.unwrap_err().err, ErrorCode::EofWhileParsingValue);"
          ],
          [
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    let deserializer_with_non_digit = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_non_digit = deserializer_with_non_digit.parse_decimal(true, 0, 0);",
            "    assert!(result_non_digit.is_err());"
          ],
          [
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    let deserializer_with_non_digit = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_non_digit = deserializer_with_non_digit.parse_decimal(true, 0, 0);",
            "    assert_eq!(result_non_digit.unwrap_err().err, ErrorCode::InvalidNumber);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    assert_eq!(f64_value, 0.123);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    assert!(deserializer_with_overflow.parse_decimal(true, u64::MAX, 0).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    assert!(result_invalid.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    assert_eq!(result_invalid.unwrap_err().err, ErrorCode::EofWhileParsingValue);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    let deserializer_with_non_digit = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_non_digit = deserializer_with_non_digit.parse_decimal(true, 0, 0);",
            "    assert!(result_non_digit.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let f64_value = result.unwrap();",
            "    let deserializer_with_overflow = Deserializer {",
            "    read: StrRead::from(\"0.1234567890123456789012345678901234567890\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let deserializer_with_invalid_number = Deserializer {",
            "    read: StrRead::from(\"0.\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_invalid = deserializer_with_invalid_number.parse_decimal(true, 0, 0);",
            "    let deserializer_with_non_digit = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result_non_digit = deserializer_with_non_digit.parse_decimal(true, 0, 0);",
            "    assert_eq!(result_non_digit.unwrap_err().err, ErrorCode::InvalidNumber);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::from(\"1234567890.123456\"),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 5,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    assert!(!overflow_condition);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    assert!(peek_result_ok);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    assert!(peek_result_ok_2);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    let digit_is_in_range = matches!(tri!(deserializer.peek_or_null()), Some(c) if (b'0'..=b'9').contains(&c));",
            "    assert!(digit_is_in_range);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    let digit_is_in_range = matches!(tri!(deserializer.peek_or_null()), Some(c) if (b'0'..=b'9').contains(&c));",
            "    let peek_result_err = deserializer.peek_or_null().is_err();",
            "    assert!(peek_result_err);"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    let digit_is_in_range = matches!(tri!(deserializer.peek_or_null()), Some(c) if (b'0'..=b'9').contains(&c));",
            "    let peek_result_err = deserializer.peek_or_null().is_err();",
            "    let final_result = deserializer.parse_decimal(true, significand, 0);",
            "    assert!(final_result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"1234567890.123456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"1234567890.123456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    assert!(!overflow_condition);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"1234567890.123456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    assert!(peek_result_ok);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"1234567890.123456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    assert!(peek_result_ok_2);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"1234567890.123456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    let digit_is_in_range = matches!(tri!(deserializer.peek_or_null()), Some(c) if (b'0'..=b'9').contains(&c));",
            "    assert!(digit_is_in_range);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"1234567890.123456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    let digit_is_in_range = matches!(tri!(deserializer.peek_or_null()), Some(c) if (b'0'..=b'9').contains(&c));",
            "    let peek_result_err = deserializer.peek_or_null().is_err();",
            "    assert!(peek_result_err);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"1234567890.123456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"1234567890.123456\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 1234567890, 0);",
            "    let significand = 1234567890;",
            "    let exponent_after_decimal_point = 0;",
            "    let overflow_condition = significand >= u64::MAX / 10;",
            "    let peek_result_ok = deserializer.peek_or_null().is_ok();",
            "    let peek_result_ok_2 = deserializer.peek().is_ok();",
            "    let digit_is_in_range = matches!(tri!(deserializer.peek_or_null()), Some(c) if (b'0'..=b'9').contains(&c));",
            "    let peek_result_err = deserializer.peek_or_null().is_err();",
            "    let final_result = deserializer.parse_decimal(true, significand, 0);",
            "    assert!(final_result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::from(\"0.456\"),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 5,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "    let _ = deserializer.parse_decimal(false, 0, 0);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert_eq!(deserializer.peek_or_null(), Ok(b'4'));"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert_eq!(deserializer.peek(), Ok(Some(b'4')));"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(tri!(deserializer.peek_or_null()), Ok(c) if c >= b'0' && c <= b'9'));"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(tri!(deserializer.peek_or_null()), Ok(c) if c >= b'0' && c <= b'9'));"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(!(overflow!(0 * 10 + 4, u64::MAX)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(deserializer.peek_or_null(), Err(_)));"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(deserializer.parse_decimal(false, 0, 0), Err(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(false, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert_eq!(deserializer.peek_or_null(), Ok(b'4'));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(false, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert_eq!(deserializer.peek(), Ok(Some(b'4')));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(false, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(tri!(deserializer.peek_or_null()), Ok(c) if c >= b'0' && c <= b'9'));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(false, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(tri!(deserializer.peek_or_null()), Ok(c) if c >= b'0' && c <= b'9'));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(false, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(!(overflow!(0 * 10 + 4, u64::MAX)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(false, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(deserializer.peek_or_null(), Err(_)));",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.456\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(false, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.456\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    assert!(matches!(deserializer.parse_decimal(false, 0, 0), Err(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::from(\"10000000000.1\"),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 5,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "    let _ = deserializer.parse_decimal(true, u64::MAX, 2);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"10000000000.1\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, u64::MAX, 2);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"10000000000.1\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, u64::MAX, 2);",
            "    assert_eq!(result.err().unwrap().err, ErrorCode::NumberOutOfRange);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"10000000000.1\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, u64::MAX, 2);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"10000000000.1\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, u64::MAX, 2);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"10000000000.1\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, u64::MAX, 2);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"10000000000.1\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, u64::MAX, 2);",
            "    assert_eq!(result.err().unwrap().err, ErrorCode::NumberOutOfRange);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::from(\"0.\"),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 5,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "    let result = deserializer.parse_decimal(true, 0, 0);",
          "    // The expected behavior leads to an error, which will need to be handled if checking the return.",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.peek_error(ErrorCode::InvalidNumber).err, error.err);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    // The expected behavior leads to an error, which will need to be handled if checking the return.",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    // The expected behavior leads to an error, which will need to be handled if checking the return.",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.\"), scratch: Vec::new(), remaining_depth: 5, #[cfg(feature = \"float_roundtrip\")] single_precision: false, #[cfg(feature = \"unbounded_depth\")] disable_recursion_limit: false, };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let error = result.unwrap_err();",
            "    assert_eq!(error.peek_error(ErrorCode::InvalidNumber).err, error.err);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::from(\"0.a\"),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 5,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "    let result = deserializer.parse_decimal(true, 0, 0);",
          "    // The expected behavior leads to an error, which will need to be handled if checking the return.",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert_eq!(result.unwrap_err().err, Error::peek_error(ErrorCode::InvalidNumber).err);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.a\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    // The expected behavior leads to an error, which will need to be handled if checking the return.",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.a\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    // The expected behavior leads to an error, which will need to be handled if checking the return.",
            "    let mut deserializer = Deserializer {",
            "    read: StrRead::from(\"0.a\"),",
            "    scratch: Vec::new(),",
            "    remaining_depth: 5,",
            "    #[cfg(feature = \"float_roundtrip\")]",
            "    single_precision: false,",
            "    #[cfg(feature = \"unbounded_depth\")]",
            "    disable_recursion_limit: false,",
            "    };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert_eq!(result.unwrap_err().err, Error::peek_error(ErrorCode::InvalidNumber).err);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut deserializer = Deserializer {",
          "        read: StrRead::from(\"0.123e12\"),",
          "        scratch: Vec::new(),",
          "        remaining_depth: 5,",
          "        #[cfg(feature = \"float_roundtrip\")]",
          "        single_precision: false,",
          "        #[cfg(feature = \"unbounded_depth\")]",
          "        disable_recursion_limit: false,",
          "    };",
          "    let _ = deserializer.parse_decimal(true, 0, 0);",
          "}"
        ],
        "oracles": [
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    assert!(overflow!(significand * 10 + 4, u64::MAX) == overflow_condition);"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    assert!(peek_result.is_ok());"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(peek_value == b'e');"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(deserializer.peek().is_ok());"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(c @ b'0'..=b'9' == tri!(deserializer.peek_or_null()));  // indicates we can parse digits"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(c @ b'0'..=b'9' == tri!(deserializer.peek_or_null()));  // confirms another digit parsing"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(significand * 10 + 4 < u64::MAX);"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(result.err().is_none());  // No errors expected on successful parsing"
          ],
          [
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert_eq!(result.unwrap(), 0.123e12);  // expected result value from parsing"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    assert!(overflow!(significand * 10 + 4, u64::MAX) == overflow_condition);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    assert!(peek_result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(peek_value == b'e');",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(deserializer.peek().is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(c @ b'0'..=b'9' == tri!(deserializer.peek_or_null()));  // indicates we can parse digits",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(c @ b'0'..=b'9' == tri!(deserializer.peek_or_null()));  // confirms another digit parsing",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(significand * 10 + 4 < u64::MAX);",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert!(result.err().is_none());  // No errors expected on successful parsing",
            "}"
          ],
          [
            "{",
            "    let mut deserializer = Deserializer {",
            "        read: StrRead::from(\"0.123e12\"),",
            "        scratch: Vec::new(),",
            "        remaining_depth: 5,",
            "        #[cfg(feature = \"float_roundtrip\")]",
            "        single_precision: false,",
            "        #[cfg(feature = \"unbounded_depth\")]",
            "        disable_recursion_limit: false,",
            "    };",
            "    let _ = deserializer.parse_decimal(true, 0, 0);",
            "    let mut deserializer = Deserializer { read: StrRead::from(\"0.123e12\"), scratch: Vec::new(), remaining_depth: 5, single_precision: false, disable_recursion_limit: false };",
            "    let result = deserializer.parse_decimal(true, 0, 0);",
            "    let significand = 123;",
            "    let exponent_after_decimal_point = -3;",
            "    let exponent = 0 + exponent_after_decimal_point;",
            "    let overflow_condition = false; // since significand * 10 + digit will not overflow",
            "    let peek_result = deserializer.peek_or_null();",
            "    let peek_value = peek_result.unwrap();",
            "    assert_eq!(result.unwrap(), 0.123e12);  // expected result value from parsing",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]