[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 98; // self::BB",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 98; // self::BB",
            "    for byte in 0..=255 {",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert_eq!(result, CharEscape::Backspace);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 98; // self::BB",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 98; // self::BB",
            "    for byte in 0..=255 {",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert_eq!(result, CharEscape::Backspace);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 9; // self::TT",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 9; // self::TT",
            "    for byte in 0..=255 {",
            "    assert_eq!(result, CharEscape::Tab);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 9; // self::TT",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 9; // self::TT",
            "    for byte in 0..=255 {",
            "    assert_eq!(result, CharEscape::Tab);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 10; // self::NN",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 10; // self::NN",
            "    assert_eq!(result, CharEscape::LineFeed);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 10; // self::NN",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 10; // self::NN",
            "    assert_eq!(result, CharEscape::LineFeed);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 12; // self::FF",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 12; // self::FF",
            "    let expected = CharEscape::FormFeed;",
            "    assert_eq!(result, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 12; // self::FF",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 12; // self::FF",
            "    let expected = CharEscape::FormFeed;",
            "    assert_eq!(result, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 13; // self::RR",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 13; // self::RR",
            "    assert_eq!(result, CharEscape::CarriageReturn);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 13; // self::RR",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 13; // self::RR",
            "    assert_eq!(result, CharEscape::CarriageReturn);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 34; // self::QU",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 34; // self::QU",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert_eq!(result, CharEscape::Quote);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 34; // self::QU",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 34; // self::QU",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert_eq!(result, CharEscape::Quote);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 92; // self::BS",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 0), CharEscape::ReverseSolidus);"
          ],
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 1), CharEscape::ReverseSolidus);"
          ],
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 255), CharEscape::ReverseSolidus);"
          ],
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 10), CharEscape::ReverseSolidus);"
          ],
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 100), CharEscape::ReverseSolidus);"
          ],
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 50), CharEscape::ReverseSolidus);"
          ],
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 200), CharEscape::ReverseSolidus);"
          ],
          [
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 42), CharEscape::ReverseSolidus);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 0), CharEscape::ReverseSolidus);",
            "}"
          ],
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 1), CharEscape::ReverseSolidus);",
            "}"
          ],
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 255), CharEscape::ReverseSolidus);",
            "}"
          ],
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 10), CharEscape::ReverseSolidus);",
            "}"
          ],
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 100), CharEscape::ReverseSolidus);",
            "}"
          ],
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 50), CharEscape::ReverseSolidus);",
            "}"
          ],
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 200), CharEscape::ReverseSolidus);",
            "}"
          ],
          [
            "{",
            "    let escape: u8 = 92; // self::BS",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 92; // self::BS",
            "    assert_eq!(CharEscape::from_escape_table(escape, 42), CharEscape::ReverseSolidus);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let escape: u8 = 117; // self::UU",
          "    for byte in 0..=255 {",
          "        let result = CharEscape::from_escape_table(escape, byte);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 117; // self::UU",
            "    for byte in 0..=255 {",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert_eq!(result, CharEscape::AsciiControl(byte));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 117; // self::UU",
            "    for byte in 0..=255 {",
            "        let result = CharEscape::from_escape_table(escape, byte);",
            "    }",
            "    let escape: u8 = 117; // self::UU",
            "    for byte in 0..=255 {",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert_eq!(result, CharEscape::AsciiControl(byte));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let escape: u8 = 255; // out of defined range",
          "    let byte: u8 = 0; // arbitrary value",
          "    let result = CharEscape::from_escape_table(escape, byte);",
          "}"
        ],
        "oracles": [
          [
            "    let escape: u8 = 255; // out of defined range",
            "    let byte: u8 = 0; // arbitrary value",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert!(matches!(result, CharEscape::Backspace) == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let escape: u8 = 255; // out of defined range",
            "    let byte: u8 = 0; // arbitrary value",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    let escape: u8 = 255; // out of defined range",
            "    let byte: u8 = 0; // arbitrary value",
            "    let result = CharEscape::from_escape_table(escape, byte);",
            "    assert!(matches!(result, CharEscape::Backspace) == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]