[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter(Vec<u8>);",
          "    impl io::Write for TestWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.0.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    struct TestFormatter;",
          "    impl Formatter for TestFormatter {",
          "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
          "            writer.write_all(fragment.as_bytes())?;",
          "            Ok(())",
          "        }",
          "        ",
          "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
          "            match escape {",
          "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
          "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
          "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
          "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
          "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
          "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
          "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
          "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
          "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
          "            }",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter(Vec::new());",
          "    let mut formatter = TestFormatter;",
          "    let value = \"Hello\\tWorld\"; // contains tab escape",
          "",
          "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    assert_eq!(writer.0, b\"Hello\\\\tWorld\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\nWorld\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\bWorld\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\\\\"World\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\\\\\World\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\fWorld\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\rWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\rWorld\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\rWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\0World\"; // Assuming '\\0' is treated as ASCII Control",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\u00World\"); // Replace with appropriate escape based on actual ASCII control handling"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\rWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\0World\"; // Assuming '\\0' is treated as ASCII Control",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    assert_eq!(writer.0, b\"Hello\\\\tWorld\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\nWorld\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\bWorld\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\\\\"World\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\\\\\World\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\fWorld\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\rWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\rWorld\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\rWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\0World\"; // Assuming '\\0' is treated as ASCII Control",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\u00World\"); // Replace with appropriate escape based on actual ASCII control handling",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\"; // contains tab escape",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\tWorld\";",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\bWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\\\World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\fWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\rWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\0World\"; // Assuming '\\0' is treated as ASCII Control",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter(Vec<u8>);",
          "    impl io::Write for TestWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.0.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    struct TestFormatter;",
          "    impl Formatter for TestFormatter {",
          "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
          "            writer.write_all(fragment.as_bytes())?;",
          "            Ok(())",
          "        }",
          "        ",
          "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
          "            match escape {",
          "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
          "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
          "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
          "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
          "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
          "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
          "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
          "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
          "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
          "            }",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter(Vec::new());",
          "    let mut formatter = TestFormatter;",
          "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
          "",
          "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\nWorld\\\\tTest\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\\\\tTab\\\\t\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Backspace\\\\b\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Newline\\\\n\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\\\\"World\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"FormFeed\\\\f\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"CarriageReturn\\\\r\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Escape\\\\\\\\Character\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"NoEscapes\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Unicode\\\\u\\\\x01\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\nWorld\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Tab\\\\tand newline\\\\n\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Test backspace\\\\b\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test form feed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Test form feed\\\\f\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test form feed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test carriage return\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Test carriage return\\\\r\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\nWorld\\\\tTest\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\\\\tTab\\\\t\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Backspace\\\\b\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Newline\\\\n\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\\\\"World\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"FormFeed\\\\f\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"CarriageReturn\\\\r\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Escape\\\\\\\\Character\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"NoEscapes\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Unicode\\\\u\\\\x01\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello\\\\nWorld\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Tab\\\\tand newline\\\\n\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Test backspace\\\\b\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test form feed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Test form feed\\\\f\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\"; // contains newline and tab escapes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\nWorld\\tTest\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\\tTab\\t\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\\"World\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Escape\\\\Character\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"NoEscapes\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Unicode\\u{0001}\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x0AWorld\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Tab\\tand newline\\n\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test form feed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Test carriage return\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Test carriage return\\\\r\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter(Vec<u8>);",
          "    impl io::Write for TestWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.0.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    struct TestFormatter;",
          "    impl Formatter for TestFormatter {",
          "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
          "            writer.write_all(fragment.as_bytes())?;",
          "            Ok(())",
          "        }",
          "        ",
          "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
          "            match escape {",
          "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
          "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
          "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
          "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
          "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
          "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
          "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
          "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
          "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
          "            }",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter(Vec::new());",
          "    let mut formatter = TestFormatter;",
          "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
          "",
          "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert_eq!(writer.0, b\"Hello\\\\u\\x01World\\\\u\\x02\");"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.len() > 0);"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'H'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'W'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'u'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'1'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'0'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'2'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'2'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));"
          ],
          [
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.count(b'\\\\') == 2);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert_eq!(writer.0, b\"Hello\\\\u\\x01World\\\\u\\x02\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.len() > 0);",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'H'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'W'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'u'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'1'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'0'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'2'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'2'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.contains(&b'\\\\'));",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello\\x01World\\x02\"; // contains control characters",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let value = \"Hello\\x01World\\x02\";",
            "    assert!(writer.0.count(b'\\\\') == 2);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestWriter(Vec<u8>);",
          "    impl io::Write for TestWriter {",
          "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
          "            self.0.extend_from_slice(buf);",
          "            Ok(buf.len())",
          "        }",
          "",
          "        fn flush(&mut self) -> io::Result<()> {",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    struct TestFormatter;",
          "    impl Formatter for TestFormatter {",
          "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
          "            writer.write_all(fragment.as_bytes())?;",
          "            Ok(())",
          "        }",
          "        ",
          "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
          "            match escape {",
          "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
          "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
          "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
          "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
          "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
          "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
          "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
          "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
          "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
          "            }",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = TestWriter(Vec::new());",
          "    let mut formatter = TestFormatter;",
          "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
          "",
          "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello \\\\\\\"World\\\\\\\"\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"No special chars\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\\\\tTabbed\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Line\\\\nFeed\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Backspace\\\\b\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"FormFeed\\\\f\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"CarriageReturn\\\\r\");"
          ],
          [
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Escape\\\\Solidus\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Escape\\\\\\\\Solidus\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Hello \\\\\\\"World\\\\\\\"\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"No special chars\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"\\\\tTabbed\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Line\\\\nFeed\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Backspace\\\\b\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"FormFeed\\\\f\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"CarriageReturn\\\\r\");",
            "}"
          ],
          [
            "{",
            "    struct TestWriter(Vec<u8>);",
            "    impl io::Write for TestWriter {",
            "        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {",
            "            self.0.extend_from_slice(buf);",
            "            Ok(buf.len())",
            "        }",
            "",
            "        fn flush(&mut self) -> io::Result<()> {",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    struct TestFormatter;",
            "    impl Formatter for TestFormatter {",
            "        fn write_string_fragment(&mut self, writer: &mut dyn io::Write, fragment: &str) -> io::Result<()> {",
            "            writer.write_all(fragment.as_bytes())?;",
            "            Ok(())",
            "        }",
            "        ",
            "        fn write_char_escape(&mut self, writer: &mut dyn io::Write, escape: CharEscape) -> io::Result<()> {",
            "            match escape {",
            "                CharEscape::Backspace => writer.write_all(b\"\\\\b\")?,",
            "                CharEscape::Tab => writer.write_all(b\"\\\\t\")?,",
            "                CharEscape::LineFeed => writer.write_all(b\"\\\\n\")?,",
            "                CharEscape::FormFeed => writer.write_all(b\"\\\\f\")?,",
            "                CharEscape::CarriageReturn => writer.write_all(b\"\\\\r\")?,",
            "                CharEscape::Quote => writer.write_all(b\"\\\\\\\"\")?,",
            "                CharEscape::ReverseSolidus => writer.write_all(b\"\\\\\\\\\")?,",
            "                CharEscape::Solidus => writer.write_all(b\"\\\\/\")?,",
            "                CharEscape::AsciiControl(byte) => writer.write_all(&[b'\\\\', b'u', byte])?,",
            "            }",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\"; // contains escaped quotes",
            "",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Hello \\\"World\\\"\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"No special chars\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"\\tTabbed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Line\\nFeed\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Backspace\\b\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"FormFeed\\f\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"CarriageReturn\\r\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    let mut writer = TestWriter(Vec::new());",
            "    let mut formatter = TestFormatter;",
            "    let value = \"Escape\\\\Solidus\";",
            "    format_escaped_str_contents(&mut writer, &mut formatter, value).unwrap();",
            "    assert_eq!(writer.0, b\"Escape\\\\\\\\Solidus\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]