[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'\"'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c', b'\\n']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c', b'\\n', b'\\r']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c', b'\\n', b'\\r', b'\\t']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c', b'\\n']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c', b'\\n', b'\\r']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"', b'\\\\', b'\\x08', b'\\x0c', b'\\n', b'\\r', b'\\t']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'\\\\'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    assert_eq!(scratch, vec![b'\\\\']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\"']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\x08']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\x0c']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\n']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\r']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\t']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'/']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    assert!(scratch.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    assert_eq!(scratch, vec![b'\\\\']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\"']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\x08']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\x0c']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\n']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\r']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'\\t']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    assert_eq!(scratch, vec![b'\\\\', b'/']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    assert_eq!(parse_escape(&mut read, validate, &mut scratch), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    assert!(scratch.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'b'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\x08']);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\x08']);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'f'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch[0], b'\\x0c');"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(read.is_empty());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(matches!(next_or_eof(&mut read), Err(ErrorCode::EofWhileParsingString)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch[0], b'\\x0c');",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(read.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(matches!(next_or_eof(&mut read), Err(ErrorCode::EofWhileParsingString)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'n'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\', b'/']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\', b'/']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(scratch.len() == 8);  // unchanged and length increased by read operation."
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\', b'/']);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\', b'/']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\', b'/']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(scratch.len() == 8);  // unchanged and length increased by read operation.",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n', b'\\x08', b'\\x0c', b'\\r', b'\\t', b'\"', b'\\\\', b'/']);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'r'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'/']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'/']);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\\\']);",
            "    assert_eq!(scratch, expected_scratch);"
          ],
          [
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'/']);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\\\']);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(scratch.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'/']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'/']);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\\\']);",
            "    assert_eq!(scratch, expected_scratch);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut expected_scratch = Vec::from([b'\\r']);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x08']);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\n']);",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\t']);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\x0c']);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\"']);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'/']);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    expected_scratch = Vec::from([b'\\\\']);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(scratch.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b't'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\t']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\b']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\r']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\x0c']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\\\']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'/']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![]);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\t']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\b']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\n']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\r']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\x0c']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\"']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'\\\\']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![b'/']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![]);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b't'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'b'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'n'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'r'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'f'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\"'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'\\\\'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'u'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch, vec![]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'/'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(result.is_ok(), true);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch[0], b'/');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(result.is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'/'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(scratch[0], b'/');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    assert_eq!(scratch, vec![b'u', b'1', b'2', b'3', b'4']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    assert!(parse_escape(&mut read_empty, validate, &mut scratch_empty).is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    assert_eq!(scratch_empty, vec![b'\"']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    assert!(parse_escape(&mut read_invalid, validate, &mut scratch_invalid).is_err());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    assert_eq!(scratch_invalid, Vec::new());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    assert_eq!(scratch_valid, vec![b'\\n']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    assert!(parse_escape(&mut read_backslash, validate, &mut scratch_backslash).is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    assert_eq!(scratch_backslash, vec![b'\\\\']);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    let mut scratch_utf8 = Vec::new();",
            "    let input_utf8 = vec![b'\\\\', b't', b' ', b'\\\\', b'n'];",
            "    let mut read_utf8 = &input_utf8[..];",
            "    assert!(parse_escape(&mut read_utf8, validate, &mut scratch_utf8).is_ok());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    let mut scratch_utf8 = Vec::new();",
            "    let input_utf8 = vec![b'\\\\', b't', b' ', b'\\\\', b'n'];",
            "    let mut read_utf8 = &input_utf8[..];",
            "    assert_eq!(scratch_utf8, vec![b'\\t', b' ', b'\\n']);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    assert_eq!(scratch, vec![b'u', b'1', b'2', b'3', b'4']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    assert!(parse_escape(&mut read_empty, validate, &mut scratch_empty).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    assert_eq!(scratch_empty, vec![b'\"']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    assert!(parse_escape(&mut read_invalid, validate, &mut scratch_invalid).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    assert_eq!(scratch_invalid, Vec::new());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    assert_eq!(scratch_valid, vec![b'\\n']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    assert!(parse_escape(&mut read_backslash, validate, &mut scratch_backslash).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    assert_eq!(scratch_backslash, vec![b'\\\\']);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    let mut scratch_utf8 = Vec::new();",
            "    let input_utf8 = vec![b'\\\\', b't', b' ', b'\\\\', b'n'];",
            "    let mut read_utf8 = &input_utf8[..];",
            "    assert!(parse_escape(&mut read_utf8, validate, &mut scratch_utf8).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'u', b'1', b'2', b'3', b'4'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    parse_escape(&mut read, validate, &mut scratch).unwrap();",
            "    let mut scratch_empty = Vec::new();",
            "    let input_empty = vec![b'\\\\', b'\"'];",
            "    let mut read_empty = &input_empty[..];",
            "    let mut scratch_invalid = Vec::new();",
            "    let input_invalid = vec![b'\\\\', b'x'];",
            "    let mut read_invalid = &input_invalid[..];",
            "    let mut scratch_valid = Vec::new();",
            "    let input_valid = vec![b'\\\\', b'n'];",
            "    let mut read_valid = &input_valid[..];",
            "    parse_escape(&mut read_valid, validate, &mut scratch_valid).unwrap();",
            "    let mut scratch_backslash = Vec::new();",
            "    let input_backslash = vec![b'\\\\', b'\\\\'];",
            "    let mut read_backslash = &input_backslash[..];",
            "    let mut scratch_utf8 = Vec::new();",
            "    let input_utf8 = vec![b'\\\\', b't', b' ', b'\\\\', b'n'];",
            "    let mut read_utf8 = &input_utf8[..];",
            "    assert_eq!(scratch_utf8, vec![b'\\t', b' ', b'\\n']);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut scratch = Vec::new();",
          "    let input = vec![b'\\\\', b'x'];",
          "    let mut read = &input[..];",
          "    let validate = true;",
          "    let _ = parse_escape(&mut read, validate, &mut scratch);",
          "}"
        ],
        "oracles": [
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(result.unwrap_err().code(), ErrorCode::InvalidEscape);"
          ],
          [
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(scratch.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert_eq!(result.unwrap_err().code(), ErrorCode::InvalidEscape);",
            "}"
          ],
          [
            "{",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let _ = parse_escape(&mut read, validate, &mut scratch);",
            "    let mut scratch = Vec::new();",
            "    let input = vec![b'\\\\', b'x'];",
            "    let mut read = &input[..];",
            "    let validate = true;",
            "    let result = parse_escape(&mut read, validate, &mut scratch);",
            "    assert!(scratch.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]