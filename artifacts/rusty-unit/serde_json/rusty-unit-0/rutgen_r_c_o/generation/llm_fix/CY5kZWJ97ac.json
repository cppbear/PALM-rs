{
  "name": "serde_json::value::value::Value::sort_all_objects",
  "name_with_impl": "serde_json::value::{impl#2}::sort_all_objects",
  "mod_info": {
    "name": "value",
    "loc": "src/lib.rs:426:1:426:15"
  },
  "visible": true,
  "loc": "src/value/mod.rs:875:5:889:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Value::Object(Map<String, Value>), Value::Array(Vec<Value>), Value::Null, Value::Bool(bool), Value::Number(Number), Value::String(String), and JSON structures nested up to 10 levels deep with varying sizes of objects and arrays (1-100 entries for objects and arrays).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Object(Map::new());",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut value = Value::Object(Map::new());",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let mut value = Value::Object(Map::new());",
                  "    assert_eq!(value.as_object().unwrap().map.len(), 0);"
                ],
                [
                  "    let mut value = Value::Object(Map::new());",
                  "    value.sort_all_objects();",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let mut value = Value::Object(Map::new());",
                  "    value.sort_all_objects();",
                  "    assert_eq!(value.as_object().unwrap().map.len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut value = Value::Object(Map::new());",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::new());",
                  "    assert!(value.is_object());",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Object(Map::new());",
                  "   value.sort_all_objects();",
                  "   let value = Value::Object(Map::new());",
                  "   assert_eq!(value.as_object().unwrap().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::new());",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::new());",
                  "    value.sort_all_objects();",
                  "    assert!(value.is_object());",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Object(Map::new());",
                  "   value.sort_all_objects();",
                  "   let mut value = Value::Object(Map::new());",
                  "   value.sort_all_objects();",
                  "   assert_eq!(value.as_object().unwrap().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                true,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Array(Vec::new());",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let value = Value::Array(Vec::new());",
                  "    assert!(value.is_array());"
                ],
                [
                  "    let value = Value::Array(Vec::new());",
                  "    assert_eq!(value.as_array(), Some(&Vec::new()));"
                ],
                [
                  "    let value = Value::Array(Vec::new());",
                  "    assert!(!value.is_object());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut value = Value::Array(Vec::new());",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(Vec::new());",
                  "    assert!(value.is_array());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(Vec::new());",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(Vec::new());",
                  "    assert_eq!(value.as_array(), Some(&Vec::new()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(Vec::new());",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(Vec::new());",
                  "    assert!(!value.is_object());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Object(Map::from([(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut value = Value::Object(Map::from([(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "    let map = value.as_object().unwrap();",
                  "    assert_eq!(map.map.len(), 1);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "    let map = value.as_object().unwrap();",
                  "    assert!(map.map.contains_key(\"b\"));"
                ],
                [
                  "    let mut value = Value::Object(Map::from([(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "    let map = value.as_object().unwrap();",
                  "    assert_eq!(map.map.get(\"b\").unwrap(), &Value::String(String::from(\"value\")));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut value = Value::Object(Map::from_iter([(String::from(\"b\"), Value::String(String::from(\"value\")))]));  ",
                  "   value.sort_all_objects();  ",
                  "   let mut value = Value::Object(Map::from_iter([(String::from(\"b\"), Value::String(String::from(\"value\")))]));  ",
                  "   assert!(value.is_object());  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "   value.sort_all_objects();",
                  "   let mut value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "  let map = value.as_object().unwrap();",
                  "   assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "  let mut value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value\")))]));  ",
                  "  value.sort_all_objects();  ",
                  "  let value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value\")))]));  ",
                  "  let map = value.as_object().unwrap();  ",
                  "  assert!(map.contains_key(\"b\"));  ",
                  "}"
                ],
                [
                  "{",
                  "  let mut value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "  value.sort_all_objects();",
                  "  let mut value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value\")))]));",
                  "  let map = value.as_object().unwrap();",
                  "   assert_eq!(map.get(\"b\").unwrap(), &Value::String(String::from(\"value\")));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Object(Map::from([",
                "        (String::from(\"b\"), Value::String(String::from(\"value_b\"))),",
                "        (String::from(\"a\"), Value::String(String::from(\"value_a\"))),",
                "    ]));",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "    let sorted_value = Value::Object(Map::from([ (String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))), ]));",
                  "    assert_eq!(value, sorted_value);"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "    let sorted_value = Value::Object(Map::from([ (String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))), ]));",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "    let sorted_value = Value::Object(Map::from([ (String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))), ]));",
                  "    assert!(value.as_object().is_some());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "    let sorted_value = Value::Object(Map::from([ (String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))), ]));",
                  "    assert!(!value.is_array());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "    let sorted_value = Value::Object(Map::from([ (String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))), ]));",
                  "    assert!(!value.is_string());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut value = Value::Object(Map::from_iter([",
                  "       (String::from(\"b\"), Value::String(String::from(\"value_b\"))),",
                  "       (String::from(\"a\"), Value::String(String::from(\"value_a\"))),",
                  "   ]));",
                  "   value.sort_all_objects();",
                  "   let value = Value::Object(Map::from_iter([ (String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "   let sorted_value = Value::Object(Map::from_iter([ (String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))), ]));",
                  "   assert_eq!(value, sorted_value);",
                  "}"
                ],
                [
                  "{",
                  "  let mut value = Value::Object(Map::from_iter(vec![",
                  "      (String::from(\"b\"), Value::String(String::from(\"value_b\"))),",
                  "      (String::from(\"a\"), Value::String(String::from(\"value_a\"))),",
                  "   ]));",
                  "  value.sort_all_objects();",
                  "  let expected_sorted_value = Value::Object(Map::from_iter(vec![(String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))),]));",
                  "  assert_eq!(value, expected_sorted_value);",
                  "  assert!(value.is_object());",
                  "}"
                ],
                [
                  "{",
                  "  let mut value = Value::Object(Map::from_iter(vec![",
                  "      (String::from(\"b\"), Value::String(String::from(\"value_b\"))),",
                  "      (String::from(\"a\"), Value::String(String::from(\"value_a\"))),",
                  "  ].into_iter()));",
                  "  value.sort_all_objects();",
                  "  let value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))),].into_iter()));",
                  "  assert_eq!(value, Value::Object(Map::from_iter(vec![(String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))),].into_iter())));",
                  "",
                  "}"
                ],
                [
                  "{",
                  "  let mut value = Value::Object(Map::from_iter(vec![",
                  "      (String::from(\"b\"), Value::String(String::from(\"value_b\"))),",
                  "      (String::from(\"a\"), Value::String(String::from(\"value_a\"))),",
                  "  ]));",
                  "  value.sort_all_objects();",
                  "  let value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "  let sorted_value = Value::Object(Map::from_iter(vec![(String::from(\"a\"), Value::String(String::from(\"value_a\"))), (String::from(\"b\"), Value::String(String::from(\"value_b\"))), ]));",
                  "  assert_eq!(value, sorted_value);",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Object(Map::from_iter([",
                  "       (String::from(\"b\"), Value::String(String::from(\"value_b\"))),",
                  "       (String::from(\"a\"), Value::String(String::from(\"value_a\"))),",
                  "   ]));",
                  "   value.sort_all_objects();",
                  "  let value = Value::Object(Map::from_iter([ (String::from(\"b\"), Value::String(String::from(\"value_b\"))), (String::from(\"a\"), Value::String(String::from(\"value_a\"))), ]));",
                  "  assert!(!value.is_string());",
                  "",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Object(Map::from([",
                "        (String::from(\"b\"), Value::Object(Map::from([(String::from(\"d\"), Value::Null)]))),",
                "        (String::from(\"a\"), Value::Object(Map::from([(String::from(\"c\"), Value::Bool(true))]))),",
                "    ]));",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([(String::from(\"d\"), Value::Null)]))), (String::from(\"a\"), Value::Object(Map::from([(String::from(\"c\"), Value::Bool(true))]))) ]));",
                  "    let object = value.as_object().unwrap();",
                  "    assert_eq!(object.keys().collect::<Vec<_>>(), vec![&String::from(\"a\"), &String::from(\"b\")]);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([(String::from(\"d\"), Value::Null)]))), (String::from(\"a\"), Value::Object(Map::from([(String::from(\"c\"), Value::Bool(true))]))) ]));",
                  "    let object = value.as_object().unwrap();",
                  "    assert!(object.get(&String::from(\"a\")).unwrap().as_object().unwrap().get(&String::from(\"c\")).unwrap().is_boolean());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([(String::from(\"d\"), Value::Null)]))), (String::from(\"a\"), Value::Object(Map::from([(String::from(\"c\"), Value::Bool(true))]))) ]));",
                  "    let object = value.as_object().unwrap();",
                  "    assert!(object.get(&String::from(\"b\")).unwrap().as_object().unwrap().get(&String::from(\"d\")).unwrap().is_null());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut value = Value::Object(Map::from_iter(vec![",
                  "       (String::from(\"b\"), Value::Object(Map::from_iter(vec![(String::from(\"d\"), Value::Null)]))),",
                  "       (String::from(\"a\"), Value::Object(Map::from_iter(vec![(String::from(\"c\"), Value::Bool(true))]))),",
                  "   ]));",
                  "   value.sort_all_objects();",
                  "   let mut value = Value::Object(Map::from_iter(vec![ (String::from(\"b\"), Value::Object(Map::from_iter(vec![(String::from(\"d\"), Value::Null)]))), (String::from(\"a\"), Value::Object(Map::from_iter(vec![(String::from(\"c\"), Value::Bool(true))]))) ]));",
                  "   let object = value.as_object().unwrap();",
                  "   assert_eq!(object.keys().collect::<Vec<_>>(), vec![&String::from(\"a\"), &String::from(\"b\")]);",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Object(Map::from_iter(vec![",
                  "       (String::from(\"b\"), Value::Object(Map::from_iter(vec![(String::from(\"d\"), Value::Null)]))),",
                  "       (String::from(\"a\"), Value::Object(Map::from_iter(vec![(String::from(\"c\"), Value::Bool(true))]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "   let mut value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::Object(Map::from_iter(vec![(String::from(\"d\"), Value::Null)]))), (String::from(\"a\"), Value::Object(Map::from_iter(vec![(String::from(\"c\"), Value::Bool(true))]))) ]));",
                  "    let object = value.as_object().unwrap();",
                  "    assert!(object.get(&String::from(\"a\")).unwrap().as_object().unwrap().get(&String::from(\"c\")).unwrap().is_boolean());",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Object(Map::from_iter(vec![",
                  "       (String::from(\"b\"), Value::Object(Map::from_iter(vec![(String::from(\"d\"), Value::Null)]))),",
                  "       (String::from(\"a\"), Value::Object(Map::from_iter(vec![(String::from(\"c\"), Value::Bool(true))]))),",
                  "   ]));",
                  "   value.sort_all_objects();",
                  "   let mut value = Value::Object(Map::from_iter(vec![(String::from(\"b\"), Value::Object(Map::from_iter(vec![(String::from(\"d\"), Value::Null)]))), (String::from(\"a\"), Value::Object(Map::from_iter(vec![(String::from(\"c\"), Value::Bool(true))]))) ]));",
                  "   let object = value.as_object().unwrap();",
                  "   assert!(object.get(&String::from(\"b\")).unwrap().as_object().unwrap().get(&String::from(\"d\")).unwrap().is_null());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Array(vec![",
                "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                "    ]);",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    assert!(value.is_array());"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    assert_eq!(arr.len(), 2);"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    assert!(arr[0].is_array());"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    assert!(arr[1].is_array());"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert_eq!(inner_arr_0.len(), 2);"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert!(inner_arr_0[0].is_string());"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert!(inner_arr_0[1].is_string());"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert_eq!(inner_arr_0[0].as_str(), Some(\"item_2\"));"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert_eq!(inner_arr_0[1].as_str(), Some(\"item_1\"));"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert_eq!(inner_arr_1.len(), 2);"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert!(inner_arr_1[0].is_string());"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert!(inner_arr_1[1].is_string());"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert_eq!(inner_arr_1[0].as_str(), Some(\"item_4\"));"
                ],
                [
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert_eq!(inner_arr_1[1].as_str(), Some(\"item_3\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    assert!(value.is_array());",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Array(vec![",
                  "       Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "       Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "   ]);",
                  "   value.sort_all_objects();",
                  "   let value = Value::Array(vec![",
                  "   Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "   Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "   ]);",
                  "   if let Some(arr) = value.as_array() {",
                  "       assert_eq!(arr.len(), 2);",
                  "   }",
                  "}"
                ],
                [
                  "{",
                  "   let mut value = Value::Array(vec![  ",
                  "       Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),  ",
                  "       Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),  ",
                  "   ]);  ",
                  "   value.sort_all_objects();  ",
                  "   let value = Value::Array(vec![  ",
                  "   Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),  ",
                  "   Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),  ",
                  "   ]);  ",
                  "   if let Some(arr) = value.as_array() {  ",
                  "       assert!(arr[0].is_array());  ",
                  "   }  // Added closing brace for the `if` statement.  ",
                  "}"
                ],
                [
                  "{  ",
                  "   let mut value = Value::Array(vec![  ",
                  "       Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),  ",
                  "       Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),  ",
                  "   ]);  ",
                  "   value.sort_all_objects();  ",
                  "   let value = Value::Array(vec![  ",
                  "   Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),  ",
                  "   Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),  ",
                  "   ]);  ",
                  "   if let Some(arr) = value.as_array() {  ",
                  "       assert!(arr[1].is_array());  ",
                  "   }  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert_eq!(inner_arr_0.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert!(inner_arr_0[0].is_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert!(inner_arr_0[1].is_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert_eq!(inner_arr_0[0].as_str(), Some(\"item_2\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    assert_eq!(inner_arr_0[1].as_str(), Some(\"item_1\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert_eq!(inner_arr_1.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert!(inner_arr_1[0].is_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert!(inner_arr_1[1].is_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert_eq!(inner_arr_1[0].as_str(), Some(\"item_4\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Array(vec![",
                  "        Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "        Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    value.sort_all_objects();",
                  "    let value = Value::Array(vec![",
                  "    Value::Array(vec![Value::String(String::from(\"item_2\")), Value::String(String::from(\"item_1\"))]),",
                  "    Value::Array(vec![Value::String(String::from(\"item_4\")), Value::String(String::from(\"item_3\"))]),",
                  "    ]);",
                  "    if let Some(arr) = value.as_array() {",
                  "    if let Some(inner_arr_0) = arr[0].as_array() {",
                  "    }",
                  "    if let Some(inner_arr_1) = arr[1].as_array() {",
                  "    assert_eq!(inner_arr_1[1].as_str(), Some(\"item_3\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1059:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1056 |     if let Some(inner_arr_0) = arr[0].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1057 |     assert_eq!(inner_arr_0.len(), 2);\n1058 | }\n     | - ...as it matches this but it has different indentation\n1059 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1059:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1056 |     if let Some(inner_arr_0) = arr[0].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1057 |     assert!(inner_arr_0[0].is_string());\n1058 | }\n     | - ...as it matches this but it has different indentation\n1059 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1059:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1056 |     if let Some(inner_arr_0) = arr[0].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1057 |     assert!(inner_arr_0[1].is_string());\n1058 | }\n     | - ...as it matches this but it has different indentation\n1059 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1059:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1056 |     if let Some(inner_arr_0) = arr[0].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1057 |     assert_eq!(inner_arr_0[0].as_str(), Some(\"item_2\"));\n1058 | }\n     | - ...as it matches this but it has different indentation\n1059 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1059:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1056 |     if let Some(inner_arr_0) = arr[0].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1057 |     assert_eq!(inner_arr_0[1].as_str(), Some(\"item_1\"));\n1058 | }\n     | - ...as it matches this but it has different indentation\n1059 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1061:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1058 |     if let Some(inner_arr_1) = arr[1].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1059 |     assert_eq!(inner_arr_1.len(), 2);\n1060 | }\n     | - ...as it matches this but it has different indentation\n1061 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1061:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1058 |     if let Some(inner_arr_1) = arr[1].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1059 |     assert!(inner_arr_1[0].is_string());\n1060 | }\n     | - ...as it matches this but it has different indentation\n1061 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1061:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1058 |     if let Some(inner_arr_1) = arr[1].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1059 |     assert!(inner_arr_1[1].is_string());\n1060 | }\n     | - ...as it matches this but it has different indentation\n1061 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1061:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1058 |     if let Some(inner_arr_1) = arr[1].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1059 |     assert_eq!(inner_arr_1[0].as_str(), Some(\"item_4\"));\n1060 | }\n     | - ...as it matches this but it has different indentation\n1061 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1061:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1045 | {\n     | - unclosed delimiter\n...\n1058 |     if let Some(inner_arr_1) = arr[1].as_array() {\n     |                                                  - this delimiter might not be properly closed...\n1059 |     assert_eq!(inner_arr_1[1].as_str(), Some(\"item_3\"));\n1060 | }\n     | - ...as it matches this but it has different indentation\n1061 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Object(Map::from([",
                "        (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                "        (String::from(\"a\"), Value::Object(Map::from([",
                "            (String::from(\"b\"), Value::Bool(true)),",
                "            (String::from(\"a\"), Value::Null)",
                "        ]))),",
                "    ]));",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    let obj = value.as_object().unwrap();",
                  "    assert_eq!(obj.keys().collect::<Vec<_>>(), vec![&String::from(\"a\"), &String::from(\"c\")]);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    let obj = value.as_object().unwrap();",
                  "    let inner_obj = match obj.get(&String::from(\"a\")) {",
                  "    Some(Value::Object(inner_map)) => inner_map,",
                  "    _ => panic!(\"Expected an object\"),",
                  "    };",
                  "    assert_eq!(inner_obj.keys().collect::<Vec<_>>(), vec![&String::from(\"a\"), &String::from(\"b\")]);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    let obj = value.as_object().unwrap();",
                  "    let inner_obj = match obj.get(&String::from(\"a\")) {",
                  "    Some(Value::Object(inner_map)) => inner_map,",
                  "    _ => panic!(\"Expected an object\"),",
                  "    };",
                  "    assert!(inner_obj.get(&String::from(\"a\")).is_some());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    let obj = value.as_object().unwrap();",
                  "    let inner_obj = match obj.get(&String::from(\"a\")) {",
                  "    Some(Value::Object(inner_map)) => inner_map,",
                  "    _ => panic!(\"Expected an object\"),",
                  "    };",
                  "    assert!(inner_obj.get(&String::from(\"b\")).is_some());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "  let mut value = Value::Object(Map::from_iter([  ",
                  "      (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),  ",
                  "      (String::from(\"a\"), Value::Object(Map::from_iter([  ",
                  "          (String::from(\"b\"), Value::Bool(true)),  ",
                  "          (String::from(\"a\"), Value::Null)  ",
                  "      ]))),  ",
                  "  ].iter().cloned()));  ",
                  "   value.sort_all_objects();  ",
                  "   let mut value = Value::Object(Map::from_iter([  ",
                  "   (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),  ",
                  "   (String::from(\"a\"), Value::Object(Map::from_iter([  ",
                  "   (String::from(\"b\"), Value::Bool(true)),  ",
                  "   (String::from(\"a\"), Value::Null)  ",
                  "   ])))  ",
                  "   ]));  ",
                  "   assert!(value.is_object());  ",
                  "}"
                ],
                [
                  "{",
                  "  let mut value = Value::Object(Map::from_iter(vec![",
                  "      (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "      (String::from(\"a\"), Value::Object(Map::from_iter(vec![",
                  "          (String::from(\"b\"), Value::Bool(true)),",
                  "          (String::from(\"a\"), Value::Null)",
                  "      ]))),",
                  "  ]));",
                  "   value.sort_all_objects();",
                  "   let mut value = Value::Object(Map::from_iter(vec![",
                  "   (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "   (String::from(\"a\"), Value::Object(Map::from_iter(vec![",
                  "   (String::from(\"b\"), Value::Bool(true)),",
                  "   (String::from(\"a\"), Value::Null)",
                  "   ])))",
                  "   ]));",
                  "   let obj = value.as_object().unwrap();",
                  "    assert_eq!(obj.keys().collect::<Vec<_>>(), vec![&String::from(\"a\"), &String::from(\"c\")]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Bool(true)),",
                  "            (String::from(\"a\"), Value::Null)",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    let obj = value.as_object().unwrap();",
                  "    let inner_obj = match obj.get(&String::from(\"a\")) {",
                  "    Some(Value::Object(inner_map)) => inner_map,",
                  "    _ => panic!(\"Expected an object\"),",
                  "    };",
                  "    assert_eq!(inner_obj.keys().collect::<Vec<_>>(), vec![&String::from(\"a\"), &String::from(\"b\")]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Bool(true)),",
                  "            (String::from(\"a\"), Value::Null)",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    let obj = value.as_object().unwrap();",
                  "    let inner_obj = match obj.get(&String::from(\"a\")) {",
                  "    Some(Value::Object(inner_map)) => inner_map,",
                  "    _ => panic!(\"Expected an object\"),",
                  "    };",
                  "    assert!(inner_obj.get(&String::from(\"a\")).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Bool(true)),",
                  "            (String::from(\"a\"), Value::Null)",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([",
                  "    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),",
                  "    (String::from(\"a\"), Value::Object(Map::from([",
                  "    (String::from(\"b\"), Value::Bool(true)),",
                  "    (String::from(\"a\"), Value::Null)",
                  "    ])))",
                  "    ]));",
                  "    let obj = value.as_object().unwrap();",
                  "    let inner_obj = match obj.get(&String::from(\"a\")) {",
                  "    Some(Value::Object(inner_map)) => inner_map,",
                  "    _ => panic!(\"Expected an object\"),",
                  "    };",
                  "    assert!(inner_obj.get(&String::from(\"b\")).is_some());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1047:71\n     |\n1047 |       (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),  \n     |                                                                       ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1047 |       (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),  \n     |                                                                       ++++++++++++++++++ +\n1047 |       (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),  \n     |                                                                       ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1055:68\n     |\n1055 |    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),  \n     |                                                                    ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1055 |    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),  \n     |                                                                    ++++++++++++++++++ +\n1055 |    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),  \n     |                                                                    ++++++++++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `serde_json` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.26\n   Compiling toml v0.8.22\n   Compiling trybuild v1.0.104\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1047:71\n     |\n1047 |       (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                       ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1047 |       (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                       ++++++++++++++++++ +\n1047 |       (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                       ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1055:68\n     |\n1055 |    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                    ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1055 |    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                    ++++++++++++++++++ +\n1055 |    (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                    ++++++++++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `serde_json` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:73\n     |\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                         ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                         ++++++++++++++++++ +\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                         ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1045:53\n     |\n1045 |           (String::from(\"a\"), Value::Object(Map::from([\n     |  ___________________________________________---------_^\n     | |                                           |\n     | |                                           arguments to this function are incorrect\n1046 | |             (String::from(\"b\"), Value::Bool(true)),\n1047 | |             (String::from(\"a\"), Value::Null)\n1048 | |         ]))),\n     | |_________^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n1045 | |         (String::from(\"a\"), Value::Object(Map::from([\n1046 | |             (String::from(\"b\"), Value::Bool(true)),\n1047 | |             (String::from(\"a\"), Value::Null)\n1048 | |         ]))),\n1049 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1052:69\n     |\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                     ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                     ++++++++++++++++++ +\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                     ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1053:49\n     |\n1053 |       (String::from(\"a\"), Value::Object(Map::from([\n     |  _______________________________________---------_^\n     | |                                       |\n     | |                                       arguments to this function are incorrect\n1054 | |     (String::from(\"b\"), Value::Bool(true)),\n1055 | |     (String::from(\"a\"), Value::Null)\n1056 | |     ])))\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1051:45\n     |\n1051 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1052 | |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n1053 | |     (String::from(\"a\"), Value::Object(Map::from([\n1054 | |     (String::from(\"b\"), Value::Bool(true)),\n1055 | |     (String::from(\"a\"), Value::Null)\n1056 | |     ])))\n1057 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 6 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:73\n     |\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                         ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                         ++++++++++++++++++ +\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                         ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1045:53\n     |\n1045 |           (String::from(\"a\"), Value::Object(Map::from([\n     |  ___________________________________________---------_^\n     | |                                           |\n     | |                                           arguments to this function are incorrect\n1046 | |             (String::from(\"b\"), Value::Bool(true)),\n1047 | |             (String::from(\"a\"), Value::Null)\n1048 | |         ]))),\n     | |_________^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n1045 | |         (String::from(\"a\"), Value::Object(Map::from([\n1046 | |             (String::from(\"b\"), Value::Bool(true)),\n1047 | |             (String::from(\"a\"), Value::Null)\n1048 | |         ]))),\n1049 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1052:69\n     |\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                     ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                     ++++++++++++++++++ +\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                     ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1053:49\n     |\n1053 |       (String::from(\"a\"), Value::Object(Map::from([\n     |  _______________________________________---------_^\n     | |                                       |\n     | |                                       arguments to this function are incorrect\n1054 | |     (String::from(\"b\"), Value::Bool(true)),\n1055 | |     (String::from(\"a\"), Value::Null)\n1056 | |     ])))\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1051:45\n     |\n1051 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1052 | |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n1053 | |     (String::from(\"a\"), Value::Object(Map::from([\n1054 | |     (String::from(\"b\"), Value::Bool(true)),\n1055 | |     (String::from(\"a\"), Value::Null)\n1056 | |     ])))\n1057 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 6 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:73\n     |\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                         ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                         ++++++++++++++++++ +\n1044 |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                         ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1045:53\n     |\n1045 |           (String::from(\"a\"), Value::Object(Map::from([\n     |  ___________________________________________---------_^\n     | |                                           |\n     | |                                           arguments to this function are incorrect\n1046 | |             (String::from(\"b\"), Value::Bool(true)),\n1047 | |             (String::from(\"a\"), Value::Null)\n1048 | |         ]))),\n     | |_________^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n1045 | |         (String::from(\"a\"), Value::Object(Map::from([\n1046 | |             (String::from(\"b\"), Value::Bool(true)),\n1047 | |             (String::from(\"a\"), Value::Null)\n1048 | |         ]))),\n1049 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1052:69\n     |\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n     |                                                                     ^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::PosInt(3) })])),\n     |                                                                     ++++++++++++++++++ +\n1052 |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: number::N::NegInt(3) })])),\n     |                                                                     ++++++++++++++++++ +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1053:49\n     |\n1053 |       (String::from(\"a\"), Value::Object(Map::from([\n     |  _______________________________________---------_^\n     | |                                       |\n     | |                                       arguments to this function are incorrect\n1054 | |     (String::from(\"b\"), Value::Bool(true)),\n1055 | |     (String::from(\"a\"), Value::Null)\n1056 | |     ])))\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1051:45\n     |\n1051 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1052 | |     (String::from(\"c\"), Value::Array(vec![Value::Number(Number { n: 3 })])),\n1053 | |     (String::from(\"a\"), Value::Object(Map::from([\n1054 | |     (String::from(\"b\"), Value::Bool(true)),\n1055 | |     (String::from(\"a\"), Value::Null)\n1056 | |     ])))\n1057 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 2]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 2]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 6 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = Map::new();",
                "    for i in 0..100 {",
                "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                "    }",
                "    let mut value = Value::Object(map);",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    assert_eq!(keys, (0..100).map(|i| format!(\"key_{}\", i)).collect::<Vec<_>>());"
                ],
                [
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_array() == false);"
                ],
                [
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_string() == false);"
                ],
                [
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_number() == false);"
                ],
                [
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_boolean() == false);"
                ],
                [
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_null() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    assert!(value.is_object());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    assert_eq!(keys, (0..100).map(|i| format!(\"key_{}\", i)).collect::<Vec<_>>());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_array() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_string() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_number() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_boolean() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "        map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    let mut map = Map::new();",
                  "    for i in 0..100 {",
                  "    map.insert(format!(\"key_{}\", 100 - i), Value::String(format!(\"value_{}\", i)));",
                  "    }",
                  "    let mut value = Value::Object(map);",
                  "    value.sort_all_objects();",
                  "    if let Some(object) = value.as_object() {",
                  "    let keys: Vec<_> = object.map.keys().cloned().collect();",
                  "    }",
                  "    assert!(value.is_null() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: this file contains an unclosed delimiter\n    --> src/value/mod.rs:1059:3\n     |\n1037 | mod llmtests {\n     |              - unclosed delimiter\n...\n1059 | }\n     |   ^\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1056:31\n     |\n1056 |     let keys: Vec<_> = object.map.keys().cloned().collect();\n     |                               ^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 1 previous error; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1056:31\n     |\n1056 |     let keys: Vec<_> = object.map.keys().cloned().collect();\n     |                               ^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 1 previous error; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1056:31\n     |\n1056 |     let keys: Vec<_> = object.map.keys().cloned().collect();\n     |                               ^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 1 previous error; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1056:31\n     |\n1056 |     let keys: Vec<_> = object.map.keys().cloned().collect();\n     |                               ^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 1 previous error; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1056:31\n     |\n1056 |     let keys: Vec<_> = object.map.keys().cloned().collect();\n     |                               ^^^ private field\n\nFor more information about this error, try `rustc --explain E0616`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 1 previous error; 1 warning emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Object(Map::from([",
                "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                "        (String::from(\"a\"), Value::Object(Map::from([",
                "            (String::from(\"b\"), Value::Object(Map::from([",
                "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                "            ]))),",
                "        ]))),",
                "    ]));",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    assert!(value.as_object().unwrap().map.len() == 2);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    assert!(value.as_object().unwrap().map.keys().collect::<Vec<&String>>() == vec![&String::from(\"a\"), &String::from(\"z\")]);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    assert!(inner_object.is_object());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    assert!(inner_map.map.len() == 1);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    assert!(inner_map.map.keys().collect::<Vec<&String>>() == vec![&String::from(\"b\")]);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    assert!(nested_object.is_object());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    assert!(nested_map.map.len() == 1);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    assert!(nested_map.map.keys().collect::<Vec<&String>>() == vec![&String::from(\"c\")]);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    assert!(value_c.is_string());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    assert!(value_c.as_str().unwrap() == \"nested\");"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.is_array());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.as_array().unwrap().len() == 1);"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.as_array().unwrap().get(0).unwrap().is_string());"
                ],
                [
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.as_array().unwrap().get(0).unwrap().as_str().unwrap() == \"end\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    assert!(value.is_object());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    assert!(value.as_object().unwrap().map.len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    assert!(value.as_object().unwrap().map.keys().collect::<Vec<&String>>() == vec![&String::from(\"a\"), &String::from(\"z\")]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    assert!(inner_object.is_object());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    assert!(inner_map.map.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    assert!(inner_map.map.keys().collect::<Vec<&String>>() == vec![&String::from(\"b\")]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    assert!(nested_object.is_object());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    assert!(nested_map.map.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    assert!(nested_map.map.keys().collect::<Vec<&String>>() == vec![&String::from(\"c\")]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    assert!(value_c.is_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    assert!(value_c.as_str().unwrap() == \"nested\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.is_array());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.as_array().unwrap().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.as_array().unwrap().get(0).unwrap().is_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])),",
                  "        (String::from(\"a\"), Value::Object(Map::from([",
                  "            (String::from(\"b\"), Value::Object(Map::from([",
                  "                (String::from(\"c\"), Value::String(String::from(\"nested\"))),",
                  "            ]))),",
                  "        ]))),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));",
                  "    let inner_object = value.as_object().unwrap().get(&String::from(\"a\")).unwrap();",
                  "    let inner_map = inner_object.as_object().unwrap();",
                  "    let nested_object = inner_map.get(&String::from(\"b\")).unwrap();",
                  "    let nested_map = nested_object.as_object().unwrap();",
                  "    let value_c = nested_map.get(&String::from(\"c\")).unwrap();",
                  "    let outer_array = value.as_object().unwrap().get(&String::from(\"z\")).unwrap();",
                  "    assert!(outer_array.as_array().unwrap().get(0).unwrap().as_str().unwrap() == \"end\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1052:214\n     |\n1052 | ...ue::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                        -^ unclosed delimiter                                          ^ mismatched closing delimiter\n     |                        |\n     |                        closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1052:203\n     |\n1052 | ...ap::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |             -                                  ^ unclosed delimiter                                                      ^ mismatched closing delimiter\n     |             |\n     |             closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `)`\n    --> src/value/mod.rs:1042:1\n     |\n1042 | {\n     | ^ unclosed delimiter\n...\n1052 |     let mut value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                                ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `]`\n    --> src/value/mod.rs:1037:14\n     |\n1037 | ...ts {\n     |       ^ unclosed delimiter\n...\n1052 | ...t value = Value::Object(Map::from([ (String::from(\"z\"), Value::Array(vec![Value::String(String::from(\"end\"))])), (String::from(\"a\"), Value::Object(Map::from([ (String::from(\"b\"), Value::Object(Map::from([ (String::from(\"c\"), Value::String(String::from(\"nested\"))), )])), )])), ) ]...\n     |                                                                                                                                                                                                                                                                                           ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/value/mod.rs:1052:291\n     |\n1052 | ... Value::String(String::from(\"nested\"))), )])), )])), ) ]));\n     |                                             --          - -^ unexpected closing delimiter\n     |                                             ||          | |\n     |                                             ||          | missing open `[` for this delimiter\n     |                                             ||          missing open `(` for this delimiter\n     |                                             |missing open `[` for this delimiter\n     |                                             missing open `(` for this delimiter\n\nerror: could not compile `serde_json` (lib test) due to 5 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut value = Value::Object(Map::from([",
                "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                "        (String::from(\"bool\"), Value::Bool(true)),",
                "        (String::from(\"null\"), Value::Null),",
                "    ]));",
                "    value.sort_all_objects();",
                "}"
              ],
              "oracles": [
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    assert!(value.is_object());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert_eq!(keys, vec![&String::from(\"bool\"), &String::from(\"null\"), &String::from(\"number\"), &String::from(\"string\")]);"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"number\").is_some());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"string\").is_some());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"bool\").is_some());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"null\").is_some());"
                ],
                [
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"nonexistent\").is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                  "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                  "        (String::from(\"bool\"), Value::Bool(true)),",
                  "        (String::from(\"null\"), Value::Null),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    assert!(value.is_object());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                  "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                  "        (String::from(\"bool\"), Value::Bool(true)),",
                  "        (String::from(\"null\"), Value::Null),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert_eq!(keys, vec![&String::from(\"bool\"), &String::from(\"null\"), &String::from(\"number\"), &String::from(\"string\")]);",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                  "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                  "        (String::from(\"bool\"), Value::Bool(true)),",
                  "        (String::from(\"null\"), Value::Null),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"number\").is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                  "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                  "        (String::from(\"bool\"), Value::Bool(true)),",
                  "        (String::from(\"null\"), Value::Null),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"string\").is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                  "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                  "        (String::from(\"bool\"), Value::Bool(true)),",
                  "        (String::from(\"null\"), Value::Null),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"bool\").is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                  "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                  "        (String::from(\"bool\"), Value::Bool(true)),",
                  "        (String::from(\"null\"), Value::Null),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"null\").is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut value = Value::Object(Map::from([",
                  "        (String::from(\"number\"), Value::Number(Number { n: 42 })),",
                  "        (String::from(\"string\"), Value::String(String::from(\"hello\"))),",
                  "        (String::from(\"bool\"), Value::Bool(true)),",
                  "        (String::from(\"null\"), Value::Null),",
                  "    ]));",
                  "    value.sort_all_objects();",
                  "    let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));",
                  "    let object = value.as_object().unwrap();",
                  "    let keys: Vec<&String> = object.map.keys().collect();",
                  "    assert!(object.get(\"nonexistent\").is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:60\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n     |                                                            ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })),\n     |                                                            ++++++++++++++++++  +\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })),\n     |                                                            ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n1045 | |         (String::from(\"string\"), Value::String(String::from(\"hello\"))),\n1046 | |         (String::from(\"bool\"), Value::Bool(true)),\n1047 | |         (String::from(\"null\"), Value::Null),\n1048 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:94\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::Stri...\n     |                                                                                              ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:41\n     |\n1050 | ...ct(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]...\n     |       --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |       |\n     |       arguments to this function are incorrect\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 4 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:60\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n     |                                                            ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })),\n     |                                                            ++++++++++++++++++  +\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })),\n     |                                                            ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n1045 | |         (String::from(\"string\"), Value::String(String::from(\"hello\"))),\n1046 | |         (String::from(\"bool\"), Value::Bool(true)),\n1047 | |         (String::from(\"null\"), Value::Null),\n1048 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:94\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::Stri...\n     |                                                                                              ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:41\n     |\n1050 | ...ct(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]...\n     |       --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |       |\n     |       arguments to this function are incorrect\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1052:37\n     |\n1052 |     let keys: Vec<&String> = object.map.keys().collect();\n     |                                     ^^^ private field\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 5 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:60\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n     |                                                            ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })),\n     |                                                            ++++++++++++++++++  +\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })),\n     |                                                            ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n1045 | |         (String::from(\"string\"), Value::String(String::from(\"hello\"))),\n1046 | |         (String::from(\"bool\"), Value::Bool(true)),\n1047 | |         (String::from(\"null\"), Value::Null),\n1048 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:94\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::Stri...\n     |                                                                                              ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:41\n     |\n1050 | ...ct(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]...\n     |       --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |       |\n     |       arguments to this function are incorrect\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1052:37\n     |\n1052 |     let keys: Vec<&String> = object.map.keys().collect();\n     |                                     ^^^ private field\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 5 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:60\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n     |                                                            ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })),\n     |                                                            ++++++++++++++++++  +\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })),\n     |                                                            ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n1045 | |         (String::from(\"string\"), Value::String(String::from(\"hello\"))),\n1046 | |         (String::from(\"bool\"), Value::Bool(true)),\n1047 | |         (String::from(\"null\"), Value::Null),\n1048 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:94\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::Stri...\n     |                                                                                              ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:41\n     |\n1050 | ...ct(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]...\n     |       --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |       |\n     |       arguments to this function are incorrect\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1052:37\n     |\n1052 |     let keys: Vec<&String> = object.map.keys().collect();\n     |                                     ^^^ private field\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 5 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling serde_json v1.0.140\n   Compiling target-triple v0.1.4\n   Compiling ref-cast v1.0.24\n   Compiling rustversion v1.0.20\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_stacker v0.1.12\n   Compiling serde_bytes v0.11.17\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:60\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n     |                                                            ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })),\n     |                                                            ++++++++++++++++++  +\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })),\n     |                                                            ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n1045 | |         (String::from(\"string\"), Value::String(String::from(\"hello\"))),\n1046 | |         (String::from(\"bool\"), Value::Bool(true)),\n1047 | |         (String::from(\"null\"), Value::Null),\n1048 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:94\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::Stri...\n     |                                                                                              ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:41\n     |\n1050 | ...ct(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]...\n     |       --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |       |\n     |       arguments to this function are incorrect\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1052:37\n     |\n1052 |     let keys: Vec<&String> = object.map.keys().collect();\n     |                                     ^^^ private field\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 5 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling toml_datetime v0.6.9\n   Compiling serde_spanned v0.6.8\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:60\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n     |                                                            ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })),\n     |                                                            ++++++++++++++++++  +\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })),\n     |                                                            ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n1045 | |         (String::from(\"string\"), Value::String(String::from(\"hello\"))),\n1046 | |         (String::from(\"bool\"), Value::Bool(true)),\n1047 | |         (String::from(\"null\"), Value::Null),\n1048 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:94\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::Stri...\n     |                                                                                              ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:41\n     |\n1050 | ...ct(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]...\n     |       --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |       |\n     |       arguments to this function are incorrect\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1052:37\n     |\n1052 |     let keys: Vec<&String> = object.map.keys().collect();\n     |                                     ^^^ private field\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 5 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling serde v1.0.219\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling target-triple v0.1.4\n   Compiling serde_json v1.0.140\n   Compiling rustversion v1.0.20\n   Compiling ref-cast v1.0.24\n   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\n   Compiling psm v0.1.26\n   Compiling stacker v0.1.21\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling serde_derive v1.0.219\n   Compiling ref-cast-impl v1.0.24\n   Compiling automod v1.0.15\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling serde_spanned v0.6.8\n   Compiling toml_datetime v0.6.9\n   Compiling serde_bytes v0.11.17\n   Compiling serde_stacker v0.1.12\n   Compiling toml_edit v0.22.25\n   Compiling toml v0.8.21\n   Compiling trybuild v1.0.104\nwarning: unused import: `ntest::timeout`\n    --> src/value/mod.rs:1039:8\n     |\n1039 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1044:60\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n     |                                                            ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })),\n     |                                                            ++++++++++++++++++  +\n1044 |         (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })),\n     |                                                            ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1043:45\n     |\n1043 |       let mut value = Value::Object(Map::from([\n     |  ___________________________________---------_^\n     | |                                   |\n     | |                                   arguments to this function are incorrect\n1044 | |         (String::from(\"number\"), Value::Number(Number { n: 42 })),\n1045 | |         (String::from(\"string\"), Value::String(String::from(\"hello\"))),\n1046 | |         (String::from(\"bool\"), Value::Bool(true)),\n1047 | |         (String::from(\"null\"), Value::Null),\n1048 | |     ]));\n     | |_____^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:94\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::Stri...\n     |                                                                                              ^^ expected `N`, found integer\n     |\nhelp: try wrapping the expression in a variant of `N`\n     |\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::PosInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n1050 |     let value = Value::Object(Map::from([ (String::from(\"number\"), Value::Number(Number { n: number::N::NegInt(42) })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]));\n     |                                                                                              ++++++++++++++++++  +\n\nerror[E0308]: mismatched types\n    --> src/value/mod.rs:1050:41\n     |\n1050 | ...ct(Map::from([ (String::from(\"number\"), Value::Number(Number { n: 42 })), (String::from(\"string\"), Value::String(String::from(\"hello\"))), (String::from(\"bool\"), Value::Bool(true)), (String::from(\"null\"), Value::Null), ]...\n     |       --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Map<String, Value>`, found `[(String, Value); 4]`\n     |       |\n     |       arguments to this function are incorrect\n     |\n     = note: expected struct `map::Map<std::string::String, value::Value>`\n                 found array `[(std::string::String, value::Value); 4]`\nnote: associated function defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:585:8\n     |\n585  |     fn from(value: T) -> Self;\n     |        ^^^^\n\nerror[E0616]: field `map` of struct `map::Map` is private\n    --> src/value/mod.rs:1052:37\n     |\n1052 |     let keys: Vec<&String> = object.map.keys().collect();\n     |                                     ^^^ private field\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `serde_json` (lib test) generated 1 warning\nerror: could not compile `serde_json` (lib test) due to 5 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}