{
  "name": "serde_json::read::push_wtf8_codepoint",
  "name_with_impl": "serde_json::read::push_wtf8_codepoint",
  "mod_info": {
    "name": "read",
    "loc": "src/lib.rs:434:1:434:10"
  },
  "visible": false,
  "loc": "src/read.rs:978:1:1021:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: n < 0x80 is true\n"
      ],
      "input_infer": "0..=127\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0, &mut scratch);",
                  "    assert_eq!(scratch[0], 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0, &mut scratch);",
                  "    assert_eq!(scratch[0], 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(65, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(65, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(65, &mut scratch);",
                  "    assert_eq!(scratch[0], 65);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(65, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(65, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(65, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(65, &mut scratch);",
                  "    assert_eq!(scratch[0], 65);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(127, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(127, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(127, &mut scratch);",
                  "    assert_eq!(scratch[0], 127);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(127, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(127, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(127, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(127, &mut scratch);",
                  "    assert_eq!(scratch[0], 127);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(10, &mut scratch);",
                "    push_wtf8_codepoint(20, &mut scratch);",
                "    push_wtf8_codepoint(30, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    assert_eq!(scratch[0], 10);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    assert_eq!(scratch[1], 20);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    assert_eq!(scratch[2], 30);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    assert_eq!(scratch.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    assert_eq!(scratch[0], 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    assert_eq!(scratch[1], 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(10, &mut scratch);",
                  "    push_wtf8_codepoint(20, &mut scratch);",
                  "    push_wtf8_codepoint(30, &mut scratch);",
                  "    assert_eq!(scratch[2], 30);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: n < 0x80 is false, with bound n == 0x80\n",
        "// constraint: n matches 0..=0x7F is true\n",
        "// constraint: n matches 0..=0x7F is true\n",
        "// constraint: n matches 0..=0x7F is true\n"
      ],
      "input_infer": "0x80, 0x80, 0x80, 0x800, 0xFFFF, 0x1_0000, 0x10_FFFF\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    scratch.push(0b1100_0000);",
                  "    assert_eq!(scratch.len(), 2);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    scratch.push(0b1100_0000);",
                  "    assert_eq!(scratch[0], 0b1100_0000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    scratch.push(0b1100_0000);",
                  "    assert_eq!(scratch[1], 0b1000_0000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    scratch.push(0b1100_0000);",
                  "    assert_eq!(scratch.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    scratch.push(0b1100_0000);",
                  "    assert_eq!(scratch[0], 0b1100_0000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    scratch.push(0b1100_0000);",
                  "    assert_eq!(scratch[1], 0b1000_0000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11101111);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10111111);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11101111);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10111111);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let scratch = Vec::new();",
                  "    assert_eq!(scratch.len(), 0);"
                ],
                [
                  "    let scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000);"
                ],
                [
                  "    let scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10010000);"
                ],
                [
                  "    let scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000);"
                ],
                [
                  "    let scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut scratch: Vec<u8> = Vec::new();  ",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);  ",
                  "   let scratch: Vec<u8> = Vec::new();  ",
                  "   assert_eq!(scratch.len(), 0);  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();  ",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);  ",
                  "   scratch.clear();  ",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);  ",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "   scratch.clear(); // Clear the previous values in scratch instead of redeclaring it",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "   assert_eq!(scratch[0], 0b11110000);",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();  ",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);  ",
                  "   // let scratch = Vec::new();  ",
                  "   // push_wtf8_codepoint(0x1_0000, &mut scratch);  ",
                  "   assert_eq!(scratch[1], 0b10010000);  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "   scratch.clear(); // Clear the existing vector instead of re-declaring it",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "   assert_eq!(scratch[2], 0b10000000);",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "   scratch.clear(); // Clear the mutable vector instead of re-declaring it",
                  "   push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((0x10_FFFF >> 18) & 0b00000111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((0x10_FFFF >> 12) & 0b00111111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((0x10_FFFF >> 6) & 0b00111111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000 | (0x10_FFFF & 0b00111111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((0x10_FFFF >> 18) & 0b00000111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((0x10_FFFF >> 12) & 0b00111111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((0x10_FFFF >> 6) & 0b00111111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000 | (0x10_FFFF & 0b00111111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 26,
      "prompt_conds": [
        "// constraint: n < 0x80 is false, with bound n == 0x80\n",
        "// constraint: n matches 0..=0x7F is false\n",
        "// constraint: n matches 0x80..=0x7FF is true\n",
        "// constraint: n matches 0x80..=0x7FF is true\n",
        "// constraint: n matches 0x80..=0x7FF is true\n"
      ],
      "input_infer": "80..=2047\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1100_0000 | (0x80 >> 6) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1100_0000 | (0x80 >> 6) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x81, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1100_0001);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0001);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1100_0001);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x81, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0001);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x200, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0010);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x200 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x200 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0010);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x200 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x200, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x200 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x400, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0100);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x400 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x400 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x400 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x400, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x400 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFF00 >> 12) & 0b0000_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFF00 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0xFF00 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFF00 >> 12) & 0b0000_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFF00 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFF00, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0xFF00 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1101_1111);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | 0b0011_1111);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | 0b0000_0111);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1101_1111);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | 0b0011_1111);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | 0b0000_0111);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 38,
      "prompt_conds": [
        "// constraint: n < 0x80 is false, with bound n == 0x80\n",
        "// constraint: n matches 0..=0x7F is false\n",
        "// constraint: n matches 0x80..=0x7FF is false\n",
        "// constraint: n matches 0x800..=0xFFFF is true\n",
        "// constraint: n matches 0x800..=0xFFFF is true\n",
        "// constraint: n matches 0x800..=0xFFFF is true\n"
      ],
      "input_infer": "8000..=FFFF\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | (0x800 >> 12) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | (0x800 >> 12) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x801, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x801 >> 12) & 0b0000_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x801 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x801 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x801 >> 12) & 0b0000_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x801 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x801, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x801 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFF >> 12) & 0b0000_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFF >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0xFFF & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFF >> 12) & 0b0000_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFF >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0xFFF & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x1000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x1000 >> 18) & 0b0000_0111));"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x1000 >> 12) & 0b0011_1111));"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | ((0x1000 >> 6) & 0b0011_1111));"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b1000_0000 | (0x1000 & 0b0011_1111));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x1000 >> 18) & 0b0000_0111));",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x1000, &mut scratch);",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x1000, &mut scratch);",
                  "   assert_eq!(scratch[1], 0b1000_0000 | ((0x1000 >> 4) & 0b0011_1111));",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();  ",
                  "   push_wtf8_codepoint(0x1000, &mut scratch);  ",
                  "   let mut scratch = Vec::new();  ",
                  "   push_wtf8_codepoint(0x1000, &mut scratch);  ",
                  "   assert_eq!(scratch[2] as u16, 0b1000_0000 | ((0x1000 >> 6) & 0b0011_1111));  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x1000, &mut scratch);",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x1000, &mut scratch);",
                  "   assert_eq!(scratch[3], 0b1000_0000 | ((0x1000 & 0b0011_1111) as u8));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: this arithmetic operation will overflow\n    --> src/read.rs:1104:43\n     |\n1104 |     assert_eq!(scratch[0], 0b1110_0000 | ((0x1000 >> 18) & 0b0000_0111));\n     |                                           ^^^^^^^^^^^^^^ attempt to shift right by `18_i32`, which would overflow\n     |\n     = note: `#[deny(arithmetic_overflow)]` on by default\n\nerror: literal out of range for `u8`\n    --> src/read.rs:1104:44\n     |\n1104 |     assert_eq!(scratch[0], 0b1110_0000 | ((0x1000 >> 18) & 0b0000_0111));\n     |                                            ^^^^^^\n     |\n     = note: the literal `0x1000` (decimal `4096`) does not fit into the type `u8` and will become `0u8`\n     = help: consider using the type `u16` instead\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: could not compile `serde_json` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: literal out of range for `u8`\n    --> src/read.rs:1104:43\n     |\n1104 |    assert_eq!(scratch[1], 0b1000_0000 | ((0x1000 >> 4) & 0b0011_1111));\n     |                                           ^^^^^^\n     |\n     = note: the literal `0x1000` (decimal `4096`) does not fit into the type `u8` and will become `0u8`\n     = help: consider using the type `u16` instead\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFFF >> 12) & 0b0000_1111));"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFFF >> 6) & 0b0011_1111));"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0xFFFF & 0b0011_1111));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "   let mut scratch = Vec::new();  ",
                  "   push_wtf8_codepoint(0xFFFF, &mut scratch);  ",
                  "   let mut scratch = Vec::new();  ",
                  "   push_wtf8_codepoint(0xFFFF, &mut scratch);  ",
                  "   assert_eq!(scratch[0], 0b1110_0000 | ((0xFFFF >> 4) & 0b0000_1111));  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFFF >> 6) & 0b0011_1111));",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "   assert_eq!(scratch[2], 0b1000_0000 | ((0xFFFFu16 & 0b0011_1111) as u8));  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: literal out of range for `u8`\n    --> src/read.rs:1104:43\n     |\n1104 |    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFFF >> 4) & 0b0000_1111));  \n     |                                           ^^^^^^\n     |\n     = note: the literal `0xFFFF` (decimal `65535`) does not fit into the type `u8` and will become `255u8`\n     = help: consider using the type `u16` instead\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror: literal out of range for `u8`\n    --> src/read.rs:1104:44\n     |\n1104 |     assert_eq!(scratch[1], 0b1000_0000 | ((0xFFFF >> 6) & 0b0011_1111));\n     |                                            ^^^^^^\n     |\n     = note: the literal `0xFFFF` (decimal `65535`) does not fit into the type `u8` and will become `255u8`\n     = help: consider using the type `u16` instead\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 44,
      "prompt_conds": [
        "// constraint: n < 0x80 is false, with bound n == 0x80\n",
        "// constraint: n matches 0..=0x7F is false\n",
        "// constraint: n matches 0x80..=0x7FF is false\n",
        "// constraint: n matches 0x800..=0xFFFF is false\n",
        "// constraint: n matches 0x1_0000..=0x10_FFFF is true\n",
        "// constraint: n matches 0x1_0000..=0x10_FFFF is true\n",
        "// constraint: n matches 0x1_0000..=0x10_FFFF is true\n"
      ],
      "input_infer": "100000..=1114111\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10010000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10010000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x20000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0xF0 | 0b0000_0111);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0x80 | ((0x20000 >> 12) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0x80 | ((0x20000 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0x80 | (0x20000 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0xF0 | 0b0000_0111);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0x80 | ((0x20000 >> 12) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0x80 | ((0x20000 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x20000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0x80 | (0x20000 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x30000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[0] & 0b1111_0000, 0b1111_0000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[1] & 0b1000_0000, 0b1000_0000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[2] & 0b1000_0000, 0b1000_0000);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[3] & 0b1000_0000, 0b1000_0000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[0] & 0b1111_0000, 0b1111_0000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[1] & 0b1000_0000, 0b1000_0000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[2] & 0b1000_0000, 0b1000_0000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x30000, &mut scratch);",
                  "    assert_eq!(scratch[3] & 0b1000_0000, 0b1000_0000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x40000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0xF0);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0x90);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0x80);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0x80);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[0], 0xF0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[1], 0x90);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[2], 0x80);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x40000, &mut scratch);",
                  "    assert_eq!(scratch[3], 0x80);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((0x10FFFF >> 18) & 0b0000_0111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((0x10FFFF >> 12) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((0x10FFFF >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000 | (0x10FFFF & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((0x10FFFF >> 18) & 0b0000_0111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((0x10FFFF >> 12) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((0x10FFFF >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10FFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000 | (0x10FFFF & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 47,
      "prompt_conds": [
        "// constraint: n < 0x80 is false, with bound n == 0x80\n",
        "// constraint: n matches 0..=0x7F is false\n",
        "// constraint: n matches 0x80..=0x7FF is false\n",
        "// constraint: n matches 0x800..=0xFFFF is false\n",
        "// constraint: n matches 0x1_0000..=0x10_FFFF is false\n",
        "// constraint: n matches 0x11_0000.. is true\n"
      ],
      "input_infer": "n: 0x110000..=0x200000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0x110000;",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let n = 0x110000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    assert!(scratch.len() == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let n = 0x110000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    let n = 0x110000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    assert!(scratch.len() == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0x200000;",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.len(), 0);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.capacity(), 4);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(0), None);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(1), None);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(2), None);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(3), None);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert!(scratch.len() > 0);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((n >> 18) & 0b00000111) as u8);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((n >> 12) & 0b00111111) as u8);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((n >> 6) & 0b00111111) as u8);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[3], 0b10000000 | (n & 0b00111111) as u8);"
                ],
                [
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.len(), 4);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.capacity(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(0), None);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(1), None);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(2), None);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.get(3), None);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert!(scratch.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((n >> 18) & 0b00000111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((n >> 12) & 0b00111111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((n >> 6) & 0b00111111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch[3], 0b10000000 | (n & 0b00111111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x200000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    scratch.reserve(4);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0x150000;",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let n = 0x150000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    assert_eq!(scratch.len(), 0);"
                ],
                [
                  "    let n = 0x150000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    assert!(scratch.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let n = 0x150000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    let n = 0x150000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    assert_eq!(scratch.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let n = 0x150000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    let n = 0x150000;",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(n, &mut scratch);",
                  "    assert!(scratch.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let n = 0x1FFFFF;",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let n = 0x110001; // Adjust this value if required to test panic on boundary",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(n, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let n = 0x110001;",
                  "    let mut scratch = Vec::new();",
                  "    assert!(std::panic::catch_unwind(|| push_wtf8_codepoint(n, &mut scratch)).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let n = 0x110001; // Adjust this value if required to test panic on boundary",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(n, &mut scratch);",
                  "   let n = 0x110001;",
                  "   let mut scratch = Vec::new();",
                  "   assert!(std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| push_wtf8_codepoint(n, &mut scratch))).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 48,
      "prompt_conds": [
        "// constraint: n < 0x80 is false, with bound n == 0x80\n",
        "// constraint: n matches 0..=0x7F is false\n",
        "// constraint: n matches 0x80..=0x7FF is false\n",
        "// constraint: n matches 0x800..=0xFFFF is false\n",
        "// constraint: n matches 0x1_0000..=0x10_FFFF is false\n",
        "// constraint: n matches 0x11_0000.. is false\n"
      ],
      "input_infer": "n == 0x80, n == 0x7FF, n == 0x800, n == 0xFFFF, n == 0x1_0000, n == 0x10_FFFF, n == 0x11_0000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x80, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1100_0000 | ((0x80 >> 6) & 0b0001_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1100_0000 | ((0x80 >> 6) & 0b0001_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x80, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | (0x80 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0011);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x7FF >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x7FF & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0011);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x7FF >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x7FF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x7FF & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x800, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0x800 >> 12) & 0b0000_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0x800 >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x800, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0x800 & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFFF >> 12) & 0b0000_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFFF >> 6) & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0xFFFF & 0b0011_1111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b1000_0000 | (0xFFFF & 0b0011_1111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b1110_0000 | ((0xFFFF >> 12) & 0b0000_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b1000_0000 | ((0xFFFF >> 6) & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b1000_0000 | (0xFFFF & 0b0011_1111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0xFFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b1000_0000 | (0xFFFF & 0b0011_1111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 0);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert!(scratch.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert_eq!(scratch.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x1_0000, &mut scratch);",
                  "    assert!(scratch.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((0x10_FFFF >> 18) & 0b00000111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((0x10_FFFF >> 12) & 0b00111111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((0x10_FFFF >> 6) & 0b00111111) as u8);"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000 | (0x10_FFFF & 0b00111111) as u8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[0], 0b11110000 | ((0x10_FFFF >> 18) & 0b00000111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[1], 0b10000000 | ((0x10_FFFF >> 12) & 0b00111111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[2], 0b10000000 | ((0x10_FFFF >> 6) & 0b00111111) as u8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x10_FFFF, &mut scratch);",
                  "    assert_eq!(scratch[3], 0b10000000 | (0x10_FFFF & 0b00111111) as u8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut scratch = Vec::new();",
                "    push_wtf8_codepoint(0x11_0000, &mut scratch);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut scratch = Vec::new();",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    push_wtf8_codepoint(0x11_0000, &mut scratch);",
                  "    });",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut scratch = Vec::new();",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    push_wtf8_codepoint(0x11_0000, &mut scratch);",
                  "    });",
                  "    assert!(scratch.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut scratch = Vec::new();",
                  "   push_wtf8_codepoint(0x11_0000, &mut scratch);",
                  "   let mut scratch = Vec::new();",
                  "   let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {",
                  "   push_wtf8_codepoint(0x11_0000, &mut scratch);",
                  "   }));",
                  "   assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut scratch = Vec::new();",
                  "    push_wtf8_codepoint(0x11_0000, &mut scratch);",
                  "    let mut scratch = Vec::new();",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    push_wtf8_codepoint(0x11_0000, &mut scratch);",
                  "    });",
                  "    assert!(scratch.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde_json v1.0.140 (/home/abezbm/rust-utgen-test-crates-new/json)\nerror[E0277]: the type `&mut std::vec::Vec<u8>` may not be safely transferred across an unwind boundary\n    --> src/read.rs:1104:43\n     |\n1104 |       let result = std::panic::catch_unwind(|| {\n     |                    ------------------------ ^-\n     |                    |                        |\n     |  __________________|________________________within this `{closure@src/read.rs:1104:43: 1104:45}`\n     | |                  |\n     | |                  required by a bound introduced by this call\n1105 | |     push_wtf8_codepoint(0x11_0000, &mut scratch);\n1106 | |     });\n     | |_____^ `&mut std::vec::Vec<u8>` may not be safely transferred across an unwind boundary\n     |\n     = help: within `{closure@src/read.rs:1104:43: 1104:45}`, the trait `UnwindSafe` is not implemented for `&mut std::vec::Vec<u8>`, which is required by `{closure@src/read.rs:1104:43: 1104:45}: UnwindSafe`\n     = note: `UnwindSafe` is implemented for `&std::vec::Vec<u8>`, but not for `&mut std::vec::Vec<u8>`\nnote: required because it's used within this closure\n    --> src/read.rs:1104:43\n     |\n1104 |     let result = std::panic::catch_unwind(|| {\n     |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n     |\n349  | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `serde_json` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}