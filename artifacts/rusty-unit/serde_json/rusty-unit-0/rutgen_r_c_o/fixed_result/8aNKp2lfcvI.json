{
    "function_name": "serde_json::read::<&mut R as read::Read<'de>>::set_failed",
    "file_path": "/home/abezbm/rusty-unit/evaluation/serde_json/rusty-unit-0/src/read.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/json",
    "tests": 5,
    "tests_lines": [
        68,
        69,
        73,
        69,
        73
    ],
    "oracles": 2,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 40.0,
    "oracles_run": 1,
    "oracles_passed": 1,
    "oracles_passed_rate": 100.0,
    "tests_run": 2,
    "tests_passed": 2,
    "tests_passed_rate": 100.0,
    "lines": 3,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        824,
        825,
        826
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "#[should_panic]",
                "fn test_set_failed_panic_case() {",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }",
                "        fn byte_offset(&self) -> usize { 0 }",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, _: &mut bool) {",
                "            panic!(\"The panicking scenario is reached.\");",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "}",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn byte_offset(&self) -> usize { 0 }  ",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, failed: &mut bool) {",
                "            self.failed = *failed;",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    assert!(reader.failed == true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[should_panic]",
                "fn test_set_failed_panic_case() {",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }",
                "        fn byte_offset(&self) -> usize { 0 }",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }  ",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }  ",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, _: &mut bool) {",
                "            panic!(\"The panicking scenario is reached.\");",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "}",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn byte_offset(&self) -> usize { 0 }  ",
                "       // Removed duplicate definition  ",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, failed: &mut bool) {",
                "            self.failed = *failed;",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = false;",
                "    reader.set_failed(&mut failed);",
                "    assert!(reader.failed == false);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "#[should_panic]",
                "fn test_set_failed_panic_case() {",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }",
                "        fn byte_offset(&self) -> usize { 0 }",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, _: &mut bool) {",
                "            panic!(\"The panicking scenario is reached.\");",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "}",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn byte_offset(&self) -> usize { 0 }  ",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, failed: &mut bool) {",
                "            self.failed = *failed;",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    assert!(reader.failed == true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[should_panic]",
                "fn test_set_failed_panic_case() {",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }",
                "        fn byte_offset(&self) -> usize { 0 }",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }  ",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }  ",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, _: &mut bool) {",
                "            panic!(\"The panicking scenario is reached.\");",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "}",
                "    struct TestReader {",
                "        failed: bool,",
                "    }",
                "",
                "    impl private::Sealed for TestReader {}",
                "    impl Read<'static> for TestReader {",
                "        const should_early_return_if_failed: bool = false;",
                "",
                "        fn next(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn peek(&mut self) -> Result<Option<u8>> {",
                "            Ok(None)",
                "        }",
                "        fn discard(&mut self) {}",
                "       fn position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn peek_position(&self) -> Position { Position { line: 0, column: 0 } }  ",
                "       fn byte_offset(&self) -> usize { 0 }  ",
                "       // Removed duplicate definition  ",
                "       fn parse_str<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, str>> { Ok(Reference::Borrowed(\"\")) }",
                "       fn parse_str_raw<'s>(&'s mut self, _scratch: &'s mut Vec<u8>) -> Result<Reference<'static, 's, [u8]>> { Ok(Reference::Borrowed(&[])) }",
                "        fn ignore_str(&mut self) -> Result<()> { Ok(()) }",
                "        fn decode_hex_escape(&mut self) -> Result<u16> { Ok(0) }",
                "        fn set_failed(&mut self, failed: &mut bool) {",
                "            self.failed = *failed;",
                "        }",
                "    }",
                "",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = true;",
                "    reader.set_failed(&mut failed);",
                "    let mut reader = TestReader { failed: false };",
                "    let mut failed = false;",
                "    reader.set_failed(&mut failed);",
                "    assert!(reader.failed == false);",
                "}"
            ],
            []
        ]
    ]
}