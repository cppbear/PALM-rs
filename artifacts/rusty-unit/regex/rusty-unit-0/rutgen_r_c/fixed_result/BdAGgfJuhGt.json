{
    "function_name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::bump_space",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/ast/parse.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 16,
    "tests_lines": [
        36,
        33,
        55,
        51,
        41,
        24,
        30,
        28,
        24,
        90,
        49,
        41,
        20,
        20,
        21,
        20
    ],
    "oracles": 16,
    "oracles_compiled": 11,
    "oracles_compiled_rate": 68.75,
    "tests_compiled": 11,
    "tests_compiled_rate": 68.75,
    "oracles_run": 11,
    "oracles_passed": 6,
    "oracles_passed_rate": 54.54545454545454,
    "tests_run": 11,
    "tests_passed": 6,
    "tests_passed_rate": 54.54545454545454,
    "lines": 25,
    "lines_covered": 25,
    "lines_coveraged_rate": 100.0,
    "branches": 12,
    "branches_covered": 11,
    "branches_coverage_rate": 91.66666666666666,
    "codes_lines": [
        550,
        551,
        552,
        553,
        554,
        555,
        556,
        557,
        558,
        559,
        560,
        561,
        562,
        563,
        564,
        565,
        566,
        567,
        569,
        570,
        571,
        572,
        573,
        575,
        578
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    // Create the starting position.",
                "    let start_position = Position { offset: 0, line: 1, column: 1 };",
                "",
                "    // Initialize Parser with ignore_whitespace set to true.",
                "    let parser = Parser {",
                "        pos: Cell::new(start_position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true), ",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    // Create a ParserI instance with a pattern that contains whitespace and a comment.",
                "    let pattern = \"    # This is a comment\\n   a\";",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    // Call bump_space without any external context.",
                "    parser_i.bump_space();",
                "",
                "    // Validate that the parser position has advanced past whitespaces and comments.",
                "    let expected_position = Position { offset: 15, line: 2, column: 4 };",
                "    assert_eq!(parser_i.pos(), expected_position);",
                "",
                "    // Check if the comment has been captured correctly.",
                "    let comments = parser.comments.borrow();",
                "    assert_eq!(comments.len(), 1);",
                "    assert_eq!(comments[0].comment, \"This is a comment\");",
                "    assert!(comments[0].span.is_one_line());",
                "}"
            ],
            [
                550,
                551,
                553,
                554,
                555,
                556,
                557,
                558,
                559,
                560,
                561,
                562,
                563,
                564,
                565,
                566,
                567,
                569,
                570,
                571,
                572,
                573,
                575,
                578
            ]
        ],
        [
            [
                "{",
                "    // Create the starting position.",
                "    let start_position = Position { offset: 0, line: 1, column: 1 };",
                "",
                "    // Initialize Parser with ignore_whitespace set to false.",
                "    let parser = Parser {",
                "        pos: Cell::new(start_position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(false), ",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    // Create a ParserI instance with a pattern.",
                "    let pattern = \"    # This is a comment\\n   a\";",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    // Call bump_space when ignore_whitespace is disabled.",
                "    parser_i.bump_space();",
                "",
                "    // Validate that the parser position remains the same since bump_space should do nothing.",
                "    assert_eq!(parser_i.pos(), start_position);",
                "",
                "    // Validate that no comments have been captured.",
                "    let comments = parser.comments.borrow();",
                "    assert_eq!(comments.len(), 0);",
                "}"
            ],
            [
                550,
                551,
                552,
                578
            ]
        ],
        [
            [
                "{",
                "    // Setup pattern with non-whitespace characters",
                "    let pattern = \"abc\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    parser_i.bump_space();",
                "    ",
                "    // Verify that position remains the same",
                "    assert_eq!(parser_i.pos(), pos);",
                "}"
            ],
            [
                550,
                551,
                553,
                554,
                555,
                557,
                575,
                578
            ]
        ],
        [
            [
                "{",
                "    // Setup pattern with leading whitespace",
                "    let pattern = \"   abc\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    // Bump for the leading whitespace",
                "    for _ in 0..3 {",
                "        parser_i.bump();",
                "    }",
                "    ",
                "    parser_i.bump_space();",
                "    ",
                "    // Verify that position has advanced",
                "    pos.offset += 3; // Moving past the 3 spaces",
                "    assert_eq!(parser_i.pos(), pos);",
                "}"
            ],
            [
                550,
                551,
                553,
                554,
                555,
                557,
                575,
                578
            ]
        ],
        [
            [
                "{",
                "    // Setup pattern with whitespace followed by a comment",
                "    let pattern = \"   abc # This is a comment\\n\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "",
                "    // Bump space to handle leading whitespace and comments",
                "    parser_i.bump_space();",
                "",
                "    // Verify that position has moved past whitespace and comment",
                "    pos.offset += 3; // past spaces",
                "    pos.column += 3; // remains on the same line after spaces",
                "    assert_eq!(parser_i.pos(), pos);",
                "    assert_eq!(parser.comments.borrow().len(), 1); // Confirm comment was added",
                "}"
            ],
            [
                550,
                551,
                553,
                554,
                555,
                556,
                557,
                575,
                578
            ]
        ],
        [
            [
                "{",
                "    // Setup parser with ignore_whitespace set to false",
                "    let pattern = \"   abc\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    parser_i.bump_space();",
                "    ",
                "    // Verify that position remains the same",
                "    assert_eq!(parser_i.pos(), pos);",
                "}"
            ],
            [
                550,
                551,
                552,
                578
            ]
        ],
        [
            [
                "{",
                "    struct TestParser {",
                "        pos: Cell<Position>,",
                "        ignore_whitespace: Cell<bool>,",
                "        pattern: String,",
                "        comments: RefCell<Vec<ast::Comment>>,",
                "    }",
                "",
                "    impl TestParser {",
                "        fn new(pattern: &str, ignore_whitespace: bool) -> Self {",
                "            Self {",
                "                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "                ignore_whitespace: Cell::new(ignore_whitespace),",
                "                pattern: pattern.to_string(),",
                "                comments: RefCell::new(Vec::new()),",
                "            }",
                "        }",
                "",
                "        fn bump_space(&self) {",
                "            if !self.ignore_whitespace.get() {",
                "                return;",
                "            }",
                "            while !self.is_eof() {",
                "                if self.char().is_whitespace() {",
                "                    self.bump();",
                "                } else if self.char() == '#' {",
                "                    let start = self.pos.get();",
                "                    let mut comment_text = String::new();",
                "                    self.bump();",
                "                    while !self.is_eof() {",
                "                        let c = self.char();",
                "                        self.bump();",
                "                        if c == '\\n' {",
                "                            break;",
                "                        }",
                "                        comment_text.push(c);",
                "                    }",
                "                    let comment = ast::Comment {",
                "                        span: Span::new(start, self.pos.get()),",
                "                        comment: comment_text,",
                "                    };",
                "                    self.comments.borrow_mut().push(comment);",
                "                } else {",
                "                    break;",
                "                }",
                "            }",
                "        }",
                "",
                "        fn is_eof(&self) -> bool {",
                "            self.pos.get().offset >= self.pattern.len()",
                "        }",
                "",
                "        fn char(&self) -> char {",
                "            if self.is_eof() {",
                "                return '\\0';",
                "            }",
                "            self.pattern[self.pos.get().offset..].chars().next().unwrap()",
                "        }",
                "",
                "        fn bump(&self) {",
                "            if self.is_eof() {",
                "                return;",
                "            }",
                "            let Position { mut offset, mut line, mut column } = self.pos.get();",
                "",
                "            if self.char() == '\\n' {",
                "                line += 1;",
                "                column = 1;",
                "            } else {",
                "                column += 1;",
                "            }",
                "            offset += self.char().len_utf8();",
                "",
                "            self.pos.set(Position { offset, line, column });",
                "        }",
                "    }",
                "",
                "    // Initialize the parser with ignore_whitespace set to true and pattern including whitespace and comments",
                "    let pattern = \"   # comment line\\n   x y\";",
                "    let parser = TestParser::new(pattern, true);",
                "    ",
                "    // Before calling bump_space",
                "    parser.bump_space();",
                "    ",
                "    // Verify final parser position and comments collected",
                "    assert!(parser.is_eof() == false);",
                "    assert_eq!(parser.pos.get().offset, 10); // Position after whitespace and comment (length 10)",
                "    assert_eq!(parser.comments.borrow().len(), 1); // One comment should be captured",
                "    assert_eq!(parser.comments.borrow()[0].comment, \" comment line\"); // Check captured comment text",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"abc\");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 0);",
                "}"
            ],
            [
                550,
                551,
                552,
                578
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"   \");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 3);",
                "}"
            ],
            [
                550,
                551,
                553,
                554,
                555,
                556,
                557,
                578
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"    # this is a comment\\n   \");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 24);",
                "    assert_eq!(parser_i.parser().comments.borrow().len(), 1);",
                "}"
            ],
            [
                550,
                551,
                553,
                554,
                555,
                556,
                557,
                558,
                559,
                560,
                561,
                562,
                563,
                564,
                565,
                566,
                567,
                569,
                570,
                571,
                572,
                573,
                578
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"   # No comment here\");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 0);",
                "}"
            ],
            [
                550,
                551,
                552,
                578
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 551,
            "start_column": 12,
            "end_line": 551,
            "end_column": 37,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 554,
            "start_column": 15,
            "end_line": 554,
            "end_column": 29,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 555,
            "start_column": 16,
            "end_line": 555,
            "end_column": 43,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 557,
            "start_column": 23,
            "end_line": 557,
            "end_column": 41,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 561,
            "start_column": 23,
            "end_line": 561,
            "end_column": 37,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 564,
            "start_column": 24,
            "end_line": 564,
            "end_column": 33,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    // Create the starting position.",
                "    let start_position = Position { offset: 0, line: 1, column: 1 };",
                "",
                "    // Initialize Parser with ignore_whitespace set to true.",
                "    let parser = Parser {",
                "        pos: Cell::new(start_position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true), ",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    // Create a ParserI instance with a pattern that contains whitespace and a comment.",
                "    let pattern = \"    # This is a comment\\n   a\";",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    // Call bump_space without any external context.",
                "    parser_i.bump_space();",
                "",
                "    // Validate that the parser position has advanced past whitespaces and comments.",
                "    let expected_position = Position { offset: 15, line: 2, column: 4 };",
                "    assert_eq!(parser_i.pos(), expected_position);",
                "",
                "    // Check if the comment has been captured correctly.",
                "    let comments = parser.comments.borrow();",
                "    assert_eq!(comments.len(), 1);",
                "    assert_eq!(comments[0].comment, \"This is a comment\");",
                "    assert!(comments[0].span.is_one_line());",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": true,
                    "negative": true
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": true,
                    "negative": true
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": true,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    // Create the starting position.",
                "    let start_position = Position { offset: 0, line: 1, column: 1 };",
                "",
                "    // Initialize Parser with ignore_whitespace set to false.",
                "    let parser = Parser {",
                "        pos: Cell::new(start_position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(false), ",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    // Create a ParserI instance with a pattern.",
                "    let pattern = \"    # This is a comment\\n   a\";",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    // Call bump_space when ignore_whitespace is disabled.",
                "    parser_i.bump_space();",
                "",
                "    // Validate that the parser position remains the same since bump_space should do nothing.",
                "    assert_eq!(parser_i.pos(), start_position);",
                "",
                "    // Validate that no comments have been captured.",
                "    let comments = parser.comments.borrow();",
                "    assert_eq!(comments.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Setup pattern with non-whitespace characters",
                "    let pattern = \"abc\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    parser_i.bump_space();",
                "    ",
                "    // Verify that position remains the same",
                "    assert_eq!(parser_i.pos(), pos);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Setup pattern with leading whitespace",
                "    let pattern = \"   abc\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    // Bump for the leading whitespace",
                "    for _ in 0..3 {",
                "        parser_i.bump();",
                "    }",
                "    ",
                "    parser_i.bump_space();",
                "    ",
                "    // Verify that position has advanced",
                "    pos.offset += 3; // Moving past the 3 spaces",
                "    assert_eq!(parser_i.pos(), pos);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Setup pattern with whitespace followed by a comment",
                "    let pattern = \"   abc # This is a comment\\n\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: true,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "",
                "    // Bump space to handle leading whitespace and comments",
                "    parser_i.bump_space();",
                "",
                "    // Verify that position has moved past whitespace and comment",
                "    pos.offset += 3; // past spaces",
                "    pos.column += 3; // remains on the same line after spaces",
                "    assert_eq!(parser_i.pos(), pos);",
                "    assert_eq!(parser.comments.borrow().len(), 1); // Confirm comment was added",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": true,
                    "negative": true
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Setup parser with ignore_whitespace set to false",
                "    let pattern = \"   abc\";",
                "    let mut pos = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 0,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, pattern);",
                "    ",
                "    parser_i.bump_space();",
                "    ",
                "    // Verify that position remains the same",
                "    assert_eq!(parser_i.pos(), pos);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestParser {",
                "        pos: Cell<Position>,",
                "        ignore_whitespace: Cell<bool>,",
                "        pattern: String,",
                "        comments: RefCell<Vec<ast::Comment>>,",
                "    }",
                "",
                "    impl TestParser {",
                "        fn new(pattern: &str, ignore_whitespace: bool) -> Self {",
                "            Self {",
                "                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "                ignore_whitespace: Cell::new(ignore_whitespace),",
                "                pattern: pattern.to_string(),",
                "                comments: RefCell::new(Vec::new()),",
                "            }",
                "        }",
                "",
                "        fn bump_space(&self) {",
                "            if !self.ignore_whitespace.get() {",
                "                return;",
                "            }",
                "            while !self.is_eof() {",
                "                if self.char().is_whitespace() {",
                "                    self.bump();",
                "                } else if self.char() == '#' {",
                "                    let start = self.pos.get();",
                "                    let mut comment_text = String::new();",
                "                    self.bump();",
                "                    while !self.is_eof() {",
                "                        let c = self.char();",
                "                        self.bump();",
                "                        if c == '\\n' {",
                "                            break;",
                "                        }",
                "                        comment_text.push(c);",
                "                    }",
                "                    let comment = ast::Comment {",
                "                        span: Span::new(start, self.pos.get()),",
                "                        comment: comment_text,",
                "                    };",
                "                    self.comments.borrow_mut().push(comment);",
                "                } else {",
                "                    break;",
                "                }",
                "            }",
                "        }",
                "",
                "        fn is_eof(&self) -> bool {",
                "            self.pos.get().offset >= self.pattern.len()",
                "        }",
                "",
                "        fn char(&self) -> char {",
                "            if self.is_eof() {",
                "                return '\\0';",
                "            }",
                "            self.pattern[self.pos.get().offset..].chars().next().unwrap()",
                "        }",
                "",
                "        fn bump(&self) {",
                "            if self.is_eof() {",
                "                return;",
                "            }",
                "            let Position { mut offset, mut line, mut column } = self.pos.get();",
                "",
                "            if self.char() == '\\n' {",
                "                line += 1;",
                "                column = 1;",
                "            } else {",
                "                column += 1;",
                "            }",
                "            offset += self.char().len_utf8();",
                "",
                "            self.pos.set(Position { offset, line, column });",
                "        }",
                "    }",
                "",
                "    // Initialize the parser with ignore_whitespace set to true and pattern including whitespace and comments",
                "    let pattern = \"   # comment line\\n   x y\";",
                "    let parser = TestParser::new(pattern, true);",
                "    ",
                "    // Before calling bump_space",
                "    parser.bump_space();",
                "    ",
                "    // Verify final parser position and comments collected",
                "    assert!(parser.is_eof() == false);",
                "    assert_eq!(parser.pos.get().offset, 10); // Position after whitespace and comment (length 10)",
                "    assert_eq!(parser.comments.borrow().len(), 1); // One comment should be captured",
                "    assert_eq!(parser.comments.borrow()[0].comment, \" comment line\"); // Check captured comment text",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"abc\");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"   \");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 3);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": true,
                    "negative": true
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(true),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"    # this is a comment\\n   \");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 24);",
                "    assert_eq!(parser_i.parser().comments.borrow().len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": true,
                    "negative": true
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": true,
                    "negative": true
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": true,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI::new(&parser, \"   # No comment here\");",
                "    ",
                "    parser_i.bump_space();",
                "    assert_eq!(parser_i.offset(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 551,
                    "start_column": 12,
                    "end_line": 551,
                    "end_column": 37,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 554,
                    "start_column": 15,
                    "end_line": 554,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 555,
                    "start_column": 16,
                    "end_line": 555,
                    "end_column": 43,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 557,
                    "start_column": 23,
                    "end_line": 557,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 561,
                    "start_column": 23,
                    "end_line": 561,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 564,
                    "start_column": 24,
                    "end_line": 564,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}