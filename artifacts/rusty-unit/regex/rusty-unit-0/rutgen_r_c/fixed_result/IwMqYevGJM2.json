{
    "function_name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_unicode_class",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/ast/parse.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 27,
    "tests_lines": [
        107,
        107,
        31,
        45,
        30,
        39,
        54,
        58,
        54,
        58,
        57,
        57,
        45,
        45,
        45,
        45,
        53,
        50,
        50,
        49,
        50,
        54,
        38,
        25,
        25,
        25,
        29
    ],
    "oracles": 27,
    "oracles_compiled": 4,
    "oracles_compiled_rate": 14.814814814814813,
    "tests_compiled": 4,
    "tests_compiled_rate": 14.814814814814813,
    "oracles_run": 4,
    "oracles_passed": 0,
    "oracles_passed_rate": 0.0,
    "tests_run": 4,
    "tests_passed": 0,
    "tests_passed_rate": 0.0,
    "lines": 58,
    "lines_covered": 2,
    "lines_coveraged_rate": 3.4482758620689653,
    "branches": 20,
    "branches_covered": 2,
    "branches_coverage_rate": 10.0,
    "codes_lines": [
        2020,
        2021,
        2023,
        2024,
        2025,
        2026,
        2027,
        2028,
        2029,
        2030,
        2031,
        2032,
        2033,
        2034,
        2035,
        2036,
        2037,
        2038,
        2039,
        2040,
        2041,
        2042,
        2043,
        2044,
        2045,
        2046,
        2047,
        2048,
        2049,
        2050,
        2051,
        2052,
        2053,
        2054,
        2055,
        2056,
        2057,
        2058,
        2059,
        2060,
        2061,
        2062,
        2063,
        2064,
        2065,
        2066,
        2068,
        2071,
        2072,
        2073,
        2074,
        2075,
        2077,
        2078,
        2079,
        2080,
        2081,
        2082
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let pattern = \"\\\\pN\"; // Valid single character notation ",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"N\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::OneLetter('N'));",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\pP\"; // Valid negated single character notation ",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"P\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, true);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::OneLetter('P'));",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\p{Greek}\"; // Valid bracketed notation",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"Greek\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::Named(\"Greek\".to_string()));",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\p{scx!=Katakana}\"; // Valid negated bracketed notation",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"scx!=Katakana\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, true);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::NamedValue {",
                "        op: ast::ClassUnicodeOpKind::NotEqual,",
                "        name: \"scx\".to_string(),",
                "        value: \"Katakana\".to_string(),",
                "    });",
                "}"
            ],
            [
                2020,
                2021
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 2021,
            "start_column": 17,
            "end_line": 2021,
            "end_column": 35,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 2021,
            "start_column": 39,
            "end_line": 2021,
            "end_column": 57,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 2027,
            "start_column": 12,
            "end_line": 2027,
            "end_column": 39,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2034,
            "start_column": 16,
            "end_line": 2034,
            "end_column": 34,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2036,
            "start_column": 23,
            "end_line": 2036,
            "end_column": 49,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2036,
            "start_column": 53,
            "end_line": 2036,
            "end_column": 71,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2039,
            "start_column": 20,
            "end_line": 2039,
            "end_column": 33,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2049,
            "start_column": 24,
            "end_line": 2049,
            "end_column": 31,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2055,
            "start_column": 31,
            "end_line": 2055,
            "end_column": 38,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2061,
            "start_column": 31,
            "end_line": 2061,
            "end_column": 38,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let pattern = \"\\\\pN\"; // Valid single character notation ",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"N\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::OneLetter('N'));",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\pP\"; // Valid negated single character notation ",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"P\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, true);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::OneLetter('P'));",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\p{Greek}\"; // Valid bracketed notation",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"Greek\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::Named(\"Greek\".to_string()));",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\p{scx!=Katakana}\"; // Valid negated bracketed notation",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"scx!=Katakana\")),",
                "        },",
                "        pattern: pattern,",
                "    };",
                "",
                "    let result = parser.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, true);",
                "    assert_eq!(class_unicode.kind, ast::ClassUnicodeKind::NamedValue {",
                "        op: ast::ClassUnicodeOpKind::NotEqual,",
                "        name: \"scx\".to_string(),",
                "        value: \"Katakana\".to_string(),",
                "    });",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}