{
    "function_name": "regex::dfa::dfa::Transitions::next_unchecked",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/src/dfa.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex",
    "tests": 8,
    "tests_lines": [
        37,
        34,
        34,
        13,
        12,
        12,
        17,
        16
    ],
    "oracles": 8,
    "oracles_compiled": 8,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 8,
    "tests_compiled_rate": 100.0,
    "oracles_run": 8,
    "oracles_passed": 7,
    "oracles_passed_rate": 87.5,
    "tests_run": 8,
    "tests_passed": 7,
    "tests_passed_rate": 87.5,
    "lines": 5,
    "lines_covered": 5,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1651,
        1652,
        1653,
        1654,
        1655
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct Transitions {",
                "        table: Vec<StatePtr>,",
                "        num_byte_classes: usize,",
                "    }",
                "",
                "    impl Transitions {",
                "        fn new(num_byte_classes: usize) -> Transitions {",
                "            let table_size = 10;",
                "            Transitions {",
                "                table: (0..table_size as StatePtr).collect(),",
                "                num_byte_classes,",
                "            }",
                "        }",
                "",
                "        fn num_states(&self) -> usize {",
                "            self.table.len()",
                "        }",
                "",
                "        unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {",
                "            debug_assert!((si as usize) < self.table.len());",
                "            debug_assert!(cls < self.num_byte_classes);",
                "            *self.table.get_unchecked(si as usize + cls)",
                "        }",
                "    }",
                "",
                "    let transitions = Transitions::new(5);",
                "    let si: StatePtr = 2;",
                "    let cls: usize = 1;",
                "    let result: StatePtr;",
                "",
                "    unsafe {",
                "        result = transitions.next_unchecked(si, cls);",
                "    }",
                "",
                "    assert_eq!(result, 3); // 2 + 1 = 3",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Transitions {",
                "        table: Vec<StatePtr>,",
                "        num_byte_classes: usize,",
                "    }",
                "",
                "    impl Transitions {",
                "        fn new(num_byte_classes: usize) -> Transitions {",
                "            let table_size = 10;",
                "            Transitions {",
                "                table: (0..table_size as StatePtr).collect(),",
                "                num_byte_classes,",
                "            }",
                "        }",
                "",
                "        fn num_states(&self) -> usize {",
                "            self.table.len()",
                "        }",
                "",
                "        unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {",
                "            debug_assert!((si as usize) < self.table.len());",
                "            debug_assert!(cls < self.num_byte_classes);",
                "            *self.table.get_unchecked(si as usize + cls)",
                "        }",
                "    }",
                "",
                "    let transitions = Transitions::new(5);",
                "    let si: StatePtr = 10; // Out of bounds",
                "    let cls: usize = 0;",
                "",
                "    unsafe {",
                "        transitions.next_unchecked(si, cls);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Transitions {",
                "        table: Vec<StatePtr>,",
                "        num_byte_classes: usize,",
                "    }",
                "",
                "    impl Transitions {",
                "        fn new(num_byte_classes: usize) -> Transitions {",
                "            let table_size = 10;",
                "            Transitions {",
                "                table: (0..table_size as StatePtr).collect(),",
                "                num_byte_classes,",
                "            }",
                "        }",
                "",
                "        fn num_states(&self) -> usize {",
                "            self.table.len()",
                "        }",
                "",
                "        unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {",
                "            debug_assert!((si as usize) < self.table.len());",
                "            debug_assert!(cls < self.num_byte_classes);",
                "            *self.table.get_unchecked(si as usize + cls)",
                "        }",
                "    }",
                "",
                "    let transitions = Transitions::new(5);",
                "    let si: StatePtr = 1;",
                "    let cls: usize = 5; // Out of bounds",
                "",
                "    unsafe {",
                "        transitions.next_unchecked(si, cls);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let num_byte_classes = 5;",
                "    let mut transitions = Transitions::new(num_byte_classes);",
                "    // Populate the table with at least num_byte_classes + 1 entries",
                "    for _ in 0..num_byte_classes + 1 {",
                "        transitions.add();",
                "    }",
                "",
                "    unsafe {",
                "        let result = transitions.next_unchecked(0, 0);",
                "        assert_eq!(result, transitions.table[0]); // Expect the first entry",
                "    }",
                "}"
            ],
            [
                1651,
                1652,
                1653,
                1654,
                1655
            ]
        ],
        [
            [
                "{",
                "    let num_byte_classes = 5;",
                "    let mut transitions = Transitions::new(num_byte_classes);",
                "    for _ in 0..num_byte_classes + 1 {",
                "        transitions.add();",
                "    }",
                "",
                "    unsafe {",
                "        // si is equal to the length of the table, which should panic",
                "        let _ = transitions.next_unchecked(num_byte_classes as StatePtr, 0);",
                "    }",
                "}"
            ],
            [
                1651,
                1652,
                1653,
                1654,
                1655
            ]
        ],
        [
            [
                "{",
                "    let num_byte_classes = 5;",
                "    let mut transitions = Transitions::new(num_byte_classes);",
                "    for _ in 0..num_byte_classes + 1 {",
                "        transitions.add();",
                "    }",
                "",
                "    unsafe {",
                "        // cls is equal to num_byte_classes, which should panic",
                "        let _ = transitions.next_unchecked(0, num_byte_classes);",
                "    }",
                "}"
            ],
            [
                1651,
                1652,
                1653
            ]
        ],
        [
            [
                "{",
                "    let mut transitions = Transitions::new(5); // Assuming we have 5 byte classes",
                "    transitions.table = vec![0, 1, 2, 3]; // Table initialized to have 4 states",
                "",
                "    let si = transitions.table.len() as StatePtr; // si set to the length of the table to trigger panic",
                "    let cls = 0;",
                "",
                "    // Since `next_unchecked` is an unsafe method, we need to wrap it in an unsafe block",
                "    // to test the panic condition",
                "    let result = std::panic::catch_unwind(|| {",
                "        unsafe {",
                "            transitions.next_unchecked(si, cls);",
                "        }",
                "    });",
                "",
                "    assert!(result.is_err()); // We expect this to panic",
                "}"
            ],
            [
                1651,
                1652
            ]
        ],
        [
            [
                "{",
                "    let mut transitions = Transitions::new(5); // 5 byte classes",
                "    transitions.table = vec![0, 1, 2, 3]; // Table initialized with 4 states",
                "",
                "    let si = 0; // valid state index",
                "    let cls = transitions.num_byte_classes; // cls set to the number of byte classes to trigger panic",
                "",
                "    // Testing the panic condition",
                "    let result = std::panic::catch_unwind(|| {",
                "        unsafe {",
                "            transitions.next_unchecked(si, cls);",
                "        }",
                "    });",
                "",
                "    assert!(result.is_err()); // We expect this to panic",
                "}"
            ],
            [
                1651,
                1652,
                1653
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct Transitions {",
                "        table: Vec<StatePtr>,",
                "        num_byte_classes: usize,",
                "    }",
                "",
                "    impl Transitions {",
                "        fn new(num_byte_classes: usize) -> Transitions {",
                "            let table_size = 10;",
                "            Transitions {",
                "                table: (0..table_size as StatePtr).collect(),",
                "                num_byte_classes,",
                "            }",
                "        }",
                "",
                "        fn num_states(&self) -> usize {",
                "            self.table.len()",
                "        }",
                "",
                "        unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {",
                "            debug_assert!((si as usize) < self.table.len());",
                "            debug_assert!(cls < self.num_byte_classes);",
                "            *self.table.get_unchecked(si as usize + cls)",
                "        }",
                "    }",
                "",
                "    let transitions = Transitions::new(5);",
                "    let si: StatePtr = 2;",
                "    let cls: usize = 1;",
                "    let result: StatePtr;",
                "",
                "    unsafe {",
                "        result = transitions.next_unchecked(si, cls);",
                "    }",
                "",
                "    assert_eq!(result, 3); // 2 + 1 = 3",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Transitions {",
                "        table: Vec<StatePtr>,",
                "        num_byte_classes: usize,",
                "    }",
                "",
                "    impl Transitions {",
                "        fn new(num_byte_classes: usize) -> Transitions {",
                "            let table_size = 10;",
                "            Transitions {",
                "                table: (0..table_size as StatePtr).collect(),",
                "                num_byte_classes,",
                "            }",
                "        }",
                "",
                "        fn num_states(&self) -> usize {",
                "            self.table.len()",
                "        }",
                "",
                "        unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {",
                "            debug_assert!((si as usize) < self.table.len());",
                "            debug_assert!(cls < self.num_byte_classes);",
                "            *self.table.get_unchecked(si as usize + cls)",
                "        }",
                "    }",
                "",
                "    let transitions = Transitions::new(5);",
                "    let si: StatePtr = 10; // Out of bounds",
                "    let cls: usize = 0;",
                "",
                "    unsafe {",
                "        transitions.next_unchecked(si, cls);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Transitions {",
                "        table: Vec<StatePtr>,",
                "        num_byte_classes: usize,",
                "    }",
                "",
                "    impl Transitions {",
                "        fn new(num_byte_classes: usize) -> Transitions {",
                "            let table_size = 10;",
                "            Transitions {",
                "                table: (0..table_size as StatePtr).collect(),",
                "                num_byte_classes,",
                "            }",
                "        }",
                "",
                "        fn num_states(&self) -> usize {",
                "            self.table.len()",
                "        }",
                "",
                "        unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {",
                "            debug_assert!((si as usize) < self.table.len());",
                "            debug_assert!(cls < self.num_byte_classes);",
                "            *self.table.get_unchecked(si as usize + cls)",
                "        }",
                "    }",
                "",
                "    let transitions = Transitions::new(5);",
                "    let si: StatePtr = 1;",
                "    let cls: usize = 5; // Out of bounds",
                "",
                "    unsafe {",
                "        transitions.next_unchecked(si, cls);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let num_byte_classes = 5;",
                "    let mut transitions = Transitions::new(num_byte_classes);",
                "    // Populate the table with at least num_byte_classes + 1 entries",
                "    for _ in 0..num_byte_classes + 1 {",
                "        transitions.add();",
                "    }",
                "",
                "    unsafe {",
                "        let result = transitions.next_unchecked(0, 0);",
                "        assert_eq!(result, transitions.table[0]); // Expect the first entry",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let num_byte_classes = 5;",
                "    let mut transitions = Transitions::new(num_byte_classes);",
                "    for _ in 0..num_byte_classes + 1 {",
                "        transitions.add();",
                "    }",
                "",
                "    unsafe {",
                "        // si is equal to the length of the table, which should panic",
                "        let _ = transitions.next_unchecked(num_byte_classes as StatePtr, 0);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let num_byte_classes = 5;",
                "    let mut transitions = Transitions::new(num_byte_classes);",
                "    for _ in 0..num_byte_classes + 1 {",
                "        transitions.add();",
                "    }",
                "",
                "    unsafe {",
                "        // cls is equal to num_byte_classes, which should panic",
                "        let _ = transitions.next_unchecked(0, num_byte_classes);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut transitions = Transitions::new(5); // Assuming we have 5 byte classes",
                "    transitions.table = vec![0, 1, 2, 3]; // Table initialized to have 4 states",
                "",
                "    let si = transitions.table.len() as StatePtr; // si set to the length of the table to trigger panic",
                "    let cls = 0;",
                "",
                "    // Since `next_unchecked` is an unsafe method, we need to wrap it in an unsafe block",
                "    // to test the panic condition",
                "    let result = std::panic::catch_unwind(|| {",
                "        unsafe {",
                "            transitions.next_unchecked(si, cls);",
                "        }",
                "    });",
                "",
                "    assert!(result.is_err()); // We expect this to panic",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut transitions = Transitions::new(5); // 5 byte classes",
                "    transitions.table = vec![0, 1, 2, 3]; // Table initialized with 4 states",
                "",
                "    let si = 0; // valid state index",
                "    let cls = transitions.num_byte_classes; // cls set to the number of byte classes to trigger panic",
                "",
                "    // Testing the panic condition",
                "    let result = std::panic::catch_unwind(|| {",
                "        unsafe {",
                "            transitions.next_unchecked(si, cls);",
                "        }",
                "    });",
                "",
                "    assert!(result.is_err()); // We expect this to panic",
                "}"
            ],
            []
        ]
    ]
}