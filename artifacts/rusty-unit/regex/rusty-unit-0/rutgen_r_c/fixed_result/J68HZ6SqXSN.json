{
    "function_name": "regex_syntax::unicode::unicode::ClassQuery<'a>::canonicalize",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/unicode.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 24,
    "tests_lines": [
        32,
        22,
        22,
        11,
        27,
        20,
        20,
        25,
        8,
        16,
        25,
        24,
        19,
        15,
        13,
        5,
        13,
        6,
        16,
        8,
        8,
        18,
        11,
        25
    ],
    "oracles": 24,
    "oracles_compiled": 10,
    "oracles_compiled_rate": 41.66666666666667,
    "tests_compiled": 10,
    "tests_compiled_rate": 41.66666666666667,
    "oracles_run": 10,
    "oracles_passed": 5,
    "oracles_passed_rate": 50.0,
    "tests_run": 10,
    "tests_passed": 5,
    "tests_passed_rate": 50.0,
    "lines": 39,
    "lines_covered": 24,
    "lines_coveraged_rate": 61.53846153846154,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        136,
        137,
        138,
        139,
        140,
        141,
        144,
        145,
        146,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        163
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct LocalClassQuery<'a> {",
                "        query: ClassQuery<'a>,",
                "    }",
                "",
                "    impl<'a> LocalClassQuery<'a> {",
                "        fn new(query: ClassQuery<'a>) -> Self {",
                "            LocalClassQuery { query }",
                "        }",
                "    }",
                "",
                "    let property_name = \"General_Category\";",
                "    let property_value = \"assigned\"; // Expecting this to map to \"Assigned\"",
                "",
                "    // Assume the helper functions return the expected values for this test",
                "    let query = ClassQuery::ByValue {",
                "        property_name,",
                "        property_value,",
                "    };",
                "",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "",
                "    if let Ok(canonical_query) = result {",
                "        match canonical_query {",
                "            CanonicalClassQuery::GeneralCategory(canon) => {",
                "                assert_eq!(canon, \"Assigned\");",
                "            }",
                "            _ => panic!(\"Expected a GeneralCategory variant\"),",
                "        }",
                "    }",
                "}"
            ],
            [
                116,
                117,
                120,
                121,
                122,
                124,
                126,
                127,
                128,
                129,
                130,
                132,
                133,
                134,
                163
            ]
        ],
        [
            [
                "{",
                "    use ucd_util::PropertyValues;",
                "",
                "    struct TestClassQuery<'a> {",
                "        query: ClassQuery<'a>,",
                "    }",
                "",
                "    impl<'a> TestClassQuery<'a> {",
                "        fn new(query: ClassQuery<'a>) -> Self {",
                "            TestClassQuery { query }",
                "        }",
                "    }",
                "",
                "    let query = TestClassQuery::new(ClassQuery::ByValue {",
                "        property_name: \"Script\",",
                "        property_value: \"Latin\",",
                "    });",
                "",
                "    let result = query.query.canonicalize();",
                "    ",
                "    match result {",
                "        Ok(CanonicalClassQuery::Script(canon)) => {",
                "            assert_eq!(canon, \"Latin\");  // Assuming \"Latin\" is a valid return from canonical_script",
                "        }",
                "        _ => panic!(\"Expected a Script CanonicalClassQuery\"),",
                "    }",
                "}"
            ],
            [
                116,
                117,
                120,
                121,
                122,
                124,
                126,
                127,
                128,
                129,
                136,
                137,
                139,
                140,
                141,
                163
            ]
        ],
        [
            [
                "{",
                "    let query = ClassQuery::ByValue {",
                "        property_name: \"NonExistentProperty\",",
                "        property_value: \"SomeValue\",",
                "    };",
                "",
                "    let _ = query.canonicalize(); // Should panic due to PropertyNotFound",
                "}"
            ],
            [
                116,
                117,
                120,
                121,
                122,
                124,
                125,
                163
            ]
        ],
        [
            [
                "{",
                "    let query = ClassQuery::Binary(\"Lu\");",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "    if let Ok(canonical) = result {",
                "        match canonical {",
                "            CanonicalClassQuery::Binary(name) => {",
                "                assert_eq!(name, \"Lu\"); // Unicode category for uppercase letters",
                "            }",
                "            _ => panic!(\"Expected CanonicalClassQuery::Binary variant\"),",
                "        }",
                "    }",
                "}"
            ],
            [
                116,
                117,
                119,
                163
            ]
        ],
        [
            [
                "{",
                "    let query = ClassQuery::OneLetter('A');",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "    if let Ok(canonical) = result {",
                "        match canonical {",
                "            CanonicalClassQuery::Binary(name) => {",
                "                assert_eq!(name, \"Lu\"); // Unicode category for uppercase letters",
                "            }",
                "            _ => panic!(\"Expected CanonicalClassQuery::Binary variant\"),",
                "        }",
                "    }",
                "}"
            ],
            [
                116,
                117,
                118,
                163
            ]
        ],
        [
            [
                "{",
                "    // Assuming 'Z' does not trigger an error based on our test case context",
                "    let query = ClassQuery::OneLetter('Z');",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                116,
                117,
                118,
                163
            ]
        ],
        [
            [
                "{",
                "    let query = ClassQuery::ByValue {",
                "        property_name: \"General_Category\",",
                "        property_value: \"Lu\",",
                "    };",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "    if let Ok(canonical) = result {",
                "        match canonical {",
                "            CanonicalClassQuery::GeneralCategory(name) => {",
                "                assert_eq!(name, \"Lu\"); // Unicode general category for uppercase letters",
                "            }",
                "            _ => panic!(\"Expected CanonicalClassQuery::GeneralCategory variant\"),",
                "        }",
                "    }",
                "}"
            ],
            [
                116,
                117,
                120,
                121,
                122,
                124,
                126,
                127,
                128,
                129,
                130,
                132,
                133,
                134,
                163
            ]
        ],
        [
            [
                "{",
                "    use std::char;",
                "",
                "    // Create an instance of ClassQuery::OneLetter with a valid character",
                "    let query_valid = ClassQuery::OneLetter('a');",
                "    let result_valid = query_valid.canonicalize();",
                "    assert!(result_valid.is_ok());",
                "",
                "    // Create an instance of ClassQuery::OneLetter with an invalid character",
                "    let query_invalid = ClassQuery::OneLetter(char::REPLACEMENT_CHARACTER);",
                "    let result_invalid = query_invalid.canonicalize();",
                "    assert!(result_invalid.is_ok()); // Assuming it should still return OK",
                "",
                "    // Create an edge case with a control character",
                "    let query_control = ClassQuery::OneLetter('\\u{0000}');",
                "    let result_control = query_control.canonicalize();",
                "    assert!(result_control.is_ok()); // Should also return OK",
                "}"
            ],
            [
                116,
                117,
                118,
                163
            ]
        ],
        [
            [
                "{",
                "    // Create an instance of ClassQuery::Binary with an existing binary property name",
                "    let query_existing = ClassQuery::Binary(\"Lu\");",
                "    let result_existing = query_existing.canonicalize();",
                "    assert!(result_existing.is_ok());",
                "    ",
                "    // Create an instance of ClassQuery::Binary with a non-existing binary property name",
                "    let query_non_existing = ClassQuery::Binary(\"NonExistentProperty\");",
                "    let result_non_existing = query_non_existing.canonicalize();",
                "    assert!(result_non_existing.is_err()); // Should return PropertyNotFound",
                "}"
            ],
            [
                116,
                117,
                119,
                163
            ]
        ],
        [
            [
                "{",
                "    // Create an instance of ClassQuery::ByValue with existing property and value",
                "    let query_existing = ClassQuery::ByValue {",
                "        property_name: \"General_Category\",",
                "        property_value: \"Lu\", // Uppercase Letter",
                "    };",
                "    let result_existing = query_existing.canonicalize();",
                "    assert!(result_existing.is_ok());",
                "",
                "    // Create an instance of ClassQuery::ByValue with existing property but non-existing value",
                "    let query_invalid_value = ClassQuery::ByValue {",
                "        property_name: \"General_Category\",",
                "        property_value: \"NonExistentValue\",",
                "    };",
                "    let result_invalid_value = query_invalid_value.canonicalize();",
                "    assert!(result_invalid_value.is_err()); // Should return PropertyValueNotFound",
                "",
                "    // Create an instance of ClassQuery::ByValue with a non-existing property",
                "    let query_non_existing_property = ClassQuery::ByValue {",
                "        property_name: \"NonExistentProperty\",",
                "        property_value: \"Assigned\",",
                "    };",
                "    let result_non_existing_property = query_non_existing_property.canonicalize();",
                "    assert!(result_non_existing_property.is_err()); // Should return PropertyNotFound",
                "}"
            ],
            [
                116,
                117,
                120,
                121,
                122,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                163
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct LocalClassQuery<'a> {",
                "        query: ClassQuery<'a>,",
                "    }",
                "",
                "    impl<'a> LocalClassQuery<'a> {",
                "        fn new(query: ClassQuery<'a>) -> Self {",
                "            LocalClassQuery { query }",
                "        }",
                "    }",
                "",
                "    let property_name = \"General_Category\";",
                "    let property_value = \"assigned\"; // Expecting this to map to \"Assigned\"",
                "",
                "    // Assume the helper functions return the expected values for this test",
                "    let query = ClassQuery::ByValue {",
                "        property_name,",
                "        property_value,",
                "    };",
                "",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "",
                "    if let Ok(canonical_query) = result {",
                "        match canonical_query {",
                "            CanonicalClassQuery::GeneralCategory(canon) => {",
                "                assert_eq!(canon, \"Assigned\");",
                "            }",
                "            _ => panic!(\"Expected a GeneralCategory variant\"),",
                "        }",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use ucd_util::PropertyValues;",
                "",
                "    struct TestClassQuery<'a> {",
                "        query: ClassQuery<'a>,",
                "    }",
                "",
                "    impl<'a> TestClassQuery<'a> {",
                "        fn new(query: ClassQuery<'a>) -> Self {",
                "            TestClassQuery { query }",
                "        }",
                "    }",
                "",
                "    let query = TestClassQuery::new(ClassQuery::ByValue {",
                "        property_name: \"Script\",",
                "        property_value: \"Latin\",",
                "    });",
                "",
                "    let result = query.query.canonicalize();",
                "    ",
                "    match result {",
                "        Ok(CanonicalClassQuery::Script(canon)) => {",
                "            assert_eq!(canon, \"Latin\");  // Assuming \"Latin\" is a valid return from canonical_script",
                "        }",
                "        _ => panic!(\"Expected a Script CanonicalClassQuery\"),",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let query = ClassQuery::ByValue {",
                "        property_name: \"NonExistentProperty\",",
                "        property_value: \"SomeValue\",",
                "    };",
                "",
                "    let _ = query.canonicalize(); // Should panic due to PropertyNotFound",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let query = ClassQuery::Binary(\"Lu\");",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "    if let Ok(canonical) = result {",
                "        match canonical {",
                "            CanonicalClassQuery::Binary(name) => {",
                "                assert_eq!(name, \"Lu\"); // Unicode category for uppercase letters",
                "            }",
                "            _ => panic!(\"Expected CanonicalClassQuery::Binary variant\"),",
                "        }",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let query = ClassQuery::OneLetter('A');",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "    if let Ok(canonical) = result {",
                "        match canonical {",
                "            CanonicalClassQuery::Binary(name) => {",
                "                assert_eq!(name, \"Lu\"); // Unicode category for uppercase letters",
                "            }",
                "            _ => panic!(\"Expected CanonicalClassQuery::Binary variant\"),",
                "        }",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    // Assuming 'Z' does not trigger an error based on our test case context",
                "    let query = ClassQuery::OneLetter('Z');",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let query = ClassQuery::ByValue {",
                "        property_name: \"General_Category\",",
                "        property_value: \"Lu\",",
                "    };",
                "    let result = query.canonicalize();",
                "    assert!(result.is_ok());",
                "    if let Ok(canonical) = result {",
                "        match canonical {",
                "            CanonicalClassQuery::GeneralCategory(name) => {",
                "                assert_eq!(name, \"Lu\"); // Unicode general category for uppercase letters",
                "            }",
                "            _ => panic!(\"Expected CanonicalClassQuery::GeneralCategory variant\"),",
                "        }",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::char;",
                "",
                "    // Create an instance of ClassQuery::OneLetter with a valid character",
                "    let query_valid = ClassQuery::OneLetter('a');",
                "    let result_valid = query_valid.canonicalize();",
                "    assert!(result_valid.is_ok());",
                "",
                "    // Create an instance of ClassQuery::OneLetter with an invalid character",
                "    let query_invalid = ClassQuery::OneLetter(char::REPLACEMENT_CHARACTER);",
                "    let result_invalid = query_invalid.canonicalize();",
                "    assert!(result_invalid.is_ok()); // Assuming it should still return OK",
                "",
                "    // Create an edge case with a control character",
                "    let query_control = ClassQuery::OneLetter('\\u{0000}');",
                "    let result_control = query_control.canonicalize();",
                "    assert!(result_control.is_ok()); // Should also return OK",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    // Create an instance of ClassQuery::Binary with an existing binary property name",
                "    let query_existing = ClassQuery::Binary(\"Lu\");",
                "    let result_existing = query_existing.canonicalize();",
                "    assert!(result_existing.is_ok());",
                "    ",
                "    // Create an instance of ClassQuery::Binary with a non-existing binary property name",
                "    let query_non_existing = ClassQuery::Binary(\"NonExistentProperty\");",
                "    let result_non_existing = query_non_existing.canonicalize();",
                "    assert!(result_non_existing.is_err()); // Should return PropertyNotFound",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    // Create an instance of ClassQuery::ByValue with existing property and value",
                "    let query_existing = ClassQuery::ByValue {",
                "        property_name: \"General_Category\",",
                "        property_value: \"Lu\", // Uppercase Letter",
                "    };",
                "    let result_existing = query_existing.canonicalize();",
                "    assert!(result_existing.is_ok());",
                "",
                "    // Create an instance of ClassQuery::ByValue with existing property but non-existing value",
                "    let query_invalid_value = ClassQuery::ByValue {",
                "        property_name: \"General_Category\",",
                "        property_value: \"NonExistentValue\",",
                "    };",
                "    let result_invalid_value = query_invalid_value.canonicalize();",
                "    assert!(result_invalid_value.is_err()); // Should return PropertyValueNotFound",
                "",
                "    // Create an instance of ClassQuery::ByValue with a non-existing property",
                "    let query_non_existing_property = ClassQuery::ByValue {",
                "        property_name: \"NonExistentProperty\",",
                "        property_value: \"Assigned\",",
                "    };",
                "    let result_non_existing_property = query_non_existing_property.canonicalize();",
                "    assert!(result_non_existing_property.is_err()); // Should return PropertyNotFound",
                "}"
            ],
            []
        ]
    ]
}