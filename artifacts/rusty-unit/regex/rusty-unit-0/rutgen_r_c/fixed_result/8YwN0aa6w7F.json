{
    "function_name": "regex_syntax::hir::hir::HirKind::has_subexprs",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/hir/mod.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 41,
    "tests_lines": [
        17,
        72,
        61,
        21,
        66,
        5,
        5,
        5,
        5,
        4,
        8,
        4,
        4,
        4,
        15,
        16,
        21,
        21,
        4,
        4,
        4,
        4,
        4,
        9,
        10,
        4,
        6,
        4,
        8,
        4,
        6,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4
    ],
    "oracles": 41,
    "oracles_compiled": 15,
    "oracles_compiled_rate": 36.58536585365854,
    "tests_compiled": 15,
    "tests_compiled_rate": 36.58536585365854,
    "oracles_run": 15,
    "oracles_passed": 15,
    "oracles_passed_rate": 100.0,
    "tests_run": 15,
    "tests_passed": 15,
    "tests_passed_rate": 100.0,
    "lines": 5,
    "lines_covered": 4,
    "lines_coveraged_rate": 80.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        595,
        596,
        601,
        605,
        607
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Span;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Ast;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    enum HirKind {",
                "        Empty,",
                "        Literal(Literal),",
                "        Class(Class),",
                "        Anchor(Anchor),",
                "        WordBoundary(WordBoundary),",
                "        Repetition(Repetition),",
                "        Group(Group),",
                "        Concat(Vec<Hir>),",
                "        Alternation(Vec<Hir>),",
                "    }",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Literal;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Class;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Anchor;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct WordBoundary;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Repetition;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Group;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Hir {",
                "        kind: HirKind,",
                "    }",
                "",
                "    impl HirKind {",
                "        pub fn has_subexprs(&self) -> bool {",
                "            match self {",
                "                HirKind::Empty",
                "                | HirKind::Literal(_)",
                "                | HirKind::Class(_)",
                "                | HirKind::Anchor(_)",
                "                | HirKind::WordBoundary(_) => false,",
                "                HirKind::Group(_)",
                "                | HirKind::Repetition(_)",
                "                | HirKind::Concat(_)",
                "                | HirKind::Alternation(_) => true,",
                "            }",
                "        }",
                "    }",
                "",
                "    let hir_concat = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Hir {",
                "                kind: HirKind::Literal(Literal),",
                "            },",
                "            Hir {",
                "                kind: HirKind::Class(Class),",
                "            },",
                "        ]),",
                "    };",
                "",
                "    assert!(hir_concat.kind.has_subexprs());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ptr::null;",
                "",
                "    #[derive(Clone, Debug)]",
                "    struct Span;  // Dummy struct for Span",
                "    #[derive(Clone, Debug)]",
                "    struct HirInfo;  // Dummy struct for HirInfo",
                "",
                "    #[derive(Clone)]",
                "    struct ClassUnicode;  // Dummy structure for ClassUnicode",
                "    #[derive(Clone)]",
                "    struct ClassBytes;    // Dummy structure for ClassBytes",
                "",
                "    #[derive(Clone)]",
                "    struct Class { ",
                "        kind: ClassKind, ",
                "    }",
                "    ",
                "    #[derive(Clone)]",
                "    enum ClassKind {",
                "        Unicode(ClassUnicode),",
                "        Bytes(ClassBytes),",
                "    }",
                "",
                "    #[derive(Clone)]",
                "    struct WordBoundary;",
                "",
                "    #[derive(Clone)]",
                "    enum HirKind {",
                "        Empty,",
                "        Literal,",
                "        Class(Class),",
                "        Anchor,",
                "        WordBoundary(WordBoundary),",
                "        Group(Group),",
                "        Repetition(Repetition),",
                "        Concat(Vec<Hir>),",
                "        Alternation(Vec<Hir>),",
                "    }",
                "",
                "    #[derive(Clone)]",
                "    struct Hir {",
                "        kind: HirKind,",
                "        info: HirInfo,",
                "    }",
                "",
                "    impl HirKind {",
                "        pub fn has_subexprs(&self) -> bool {",
                "            match *self {",
                "                HirKind::Empty",
                "                | HirKind::Literal",
                "                | HirKind::Class(_)",
                "                | HirKind::Anchor",
                "                | HirKind::WordBoundary(_) => false,",
                "                HirKind::Group(_)",
                "                | HirKind::Repetition(_)",
                "                | HirKind::Concat(_)",
                "                | HirKind::Alternation(_) => true,",
                "            }",
                "        }",
                "    }",
                "",
                "    let word_boundary = HirKind::WordBoundary(WordBoundary);",
                "    let has_subexprs_result = word_boundary.has_subexprs();",
                "    assert_eq!(has_subexprs_result, false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let empty = HirKind::Empty;",
                "    let has_subexprs_result = empty.has_subexprs();",
                "    assert_eq!(has_subexprs_result, false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartLine);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartText);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartLine);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartLine);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            [
                595,
                596,
                601,
                607
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Span;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Ast;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    enum HirKind {",
                "        Empty,",
                "        Literal(Literal),",
                "        Class(Class),",
                "        Anchor(Anchor),",
                "        WordBoundary(WordBoundary),",
                "        Repetition(Repetition),",
                "        Group(Group),",
                "        Concat(Vec<Hir>),",
                "        Alternation(Vec<Hir>),",
                "    }",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Literal;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Class;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Anchor;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct WordBoundary;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Repetition;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Group;",
                "",
                "    #[derive(Clone, Debug, Eq, PartialEq)]",
                "    struct Hir {",
                "        kind: HirKind,",
                "    }",
                "",
                "    impl HirKind {",
                "        pub fn has_subexprs(&self) -> bool {",
                "            match self {",
                "                HirKind::Empty",
                "                | HirKind::Literal(_)",
                "                | HirKind::Class(_)",
                "                | HirKind::Anchor(_)",
                "                | HirKind::WordBoundary(_) => false,",
                "                HirKind::Group(_)",
                "                | HirKind::Repetition(_)",
                "                | HirKind::Concat(_)",
                "                | HirKind::Alternation(_) => true,",
                "            }",
                "        }",
                "    }",
                "",
                "    let hir_concat = Hir {",
                "        kind: HirKind::Concat(vec![",
                "            Hir {",
                "                kind: HirKind::Literal(Literal),",
                "            },",
                "            Hir {",
                "                kind: HirKind::Class(Class),",
                "            },",
                "        ]),",
                "    };",
                "",
                "    assert!(hir_concat.kind.has_subexprs());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ptr::null;",
                "",
                "    #[derive(Clone, Debug)]",
                "    struct Span;  // Dummy struct for Span",
                "    #[derive(Clone, Debug)]",
                "    struct HirInfo;  // Dummy struct for HirInfo",
                "",
                "    #[derive(Clone)]",
                "    struct ClassUnicode;  // Dummy structure for ClassUnicode",
                "    #[derive(Clone)]",
                "    struct ClassBytes;    // Dummy structure for ClassBytes",
                "",
                "    #[derive(Clone)]",
                "    struct Class { ",
                "        kind: ClassKind, ",
                "    }",
                "    ",
                "    #[derive(Clone)]",
                "    enum ClassKind {",
                "        Unicode(ClassUnicode),",
                "        Bytes(ClassBytes),",
                "    }",
                "",
                "    #[derive(Clone)]",
                "    struct WordBoundary;",
                "",
                "    #[derive(Clone)]",
                "    enum HirKind {",
                "        Empty,",
                "        Literal,",
                "        Class(Class),",
                "        Anchor,",
                "        WordBoundary(WordBoundary),",
                "        Group(Group),",
                "        Repetition(Repetition),",
                "        Concat(Vec<Hir>),",
                "        Alternation(Vec<Hir>),",
                "    }",
                "",
                "    #[derive(Clone)]",
                "    struct Hir {",
                "        kind: HirKind,",
                "        info: HirInfo,",
                "    }",
                "",
                "    impl HirKind {",
                "        pub fn has_subexprs(&self) -> bool {",
                "            match *self {",
                "                HirKind::Empty",
                "                | HirKind::Literal",
                "                | HirKind::Class(_)",
                "                | HirKind::Anchor",
                "                | HirKind::WordBoundary(_) => false,",
                "                HirKind::Group(_)",
                "                | HirKind::Repetition(_)",
                "                | HirKind::Concat(_)",
                "                | HirKind::Alternation(_) => true,",
                "            }",
                "        }",
                "    }",
                "",
                "    let word_boundary = HirKind::WordBoundary(WordBoundary);",
                "    let has_subexprs_result = word_boundary.has_subexprs();",
                "    assert_eq!(has_subexprs_result, false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let empty = HirKind::Empty;",
                "    let has_subexprs_result = empty.has_subexprs();",
                "    assert_eq!(has_subexprs_result, false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartLine);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartText);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartLine);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Empty;",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartLine);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    assert_eq!(kind.has_subexprs(), false);",
                "}"
            ],
            []
        ]
    ]
}