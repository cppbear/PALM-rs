{
    "function_name": "regex_syntax::hir::print::hir::print::Writer<'p, W>::write_literal_char",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/hir/print.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 7,
    "tests_lines": [
        36,
        31,
        31,
        26,
        26,
        26,
        43
    ],
    "oracles": 7,
    "oracles_compiled": 7,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 7,
    "tests_compiled_rate": 100.0,
    "oracles_run": 7,
    "oracles_passed": 7,
    "oracles_passed_rate": 100.0,
    "tests_run": 7,
    "tests_passed": 7,
    "tests_passed_rate": 100.0,
    "lines": 6,
    "lines_covered": 6,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        221,
        222,
        223,
        224,
        225,
        226
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct MockWriter {",
                "        error_occurred: bool,",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            if self.error_occurred {",
                "                Err(fmt::Error)",
                "            } else {",
                "                self.output.push_str(s);",
                "                Ok(())",
                "            }",
                "        }",
                "    ",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "    ",
                "    let mut mock_writer = MockWriter {",
                "        error_occurred: true,",
                "        output: String::new(),",
                "    };",
                "    ",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut mock_writer,",
                "    };",
                "    ",
                "    let result = writer.write_literal_char('.'); // '.' is a meta character",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                221,
                222,
                223,
                226
            ]
        ],
        [
            [
                "{",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "    ",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "    ",
                "    let mut mock_writer = MockWriter {",
                "        output: String::new(),",
                "    };",
                "    ",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut mock_writer,",
                "    };",
                "    ",
                "    let result = writer.write_literal_char('.'); // '.' is a meta character",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"\\\\.\"); // Expecting the output to include the escaped meta character",
                "}"
            ],
            [
                221,
                222,
                223,
                225,
                226
            ]
        ],
        [
            [
                "{",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "    ",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "    ",
                "    let mut mock_writer = MockWriter {",
                "        output: String::new(),",
                "    };",
                "    ",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut mock_writer,",
                "    };",
                "    ",
                "    let result = writer.write_literal_char('a'); // 'a' is not a meta character",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"a\"); // Expecting the output to be the non-escaped character",
                "}"
            ],
            [
                221,
                222,
                224,
                225,
                226
            ]
        ],
        [
            [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut mock_writer = MockWriter { output: String::new() };",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut mock_writer };",
                "",
                "    let result = writer.write_literal_char('+');",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"\\\\+\");",
                "}"
            ],
            [
                221,
                222,
                223,
                225,
                226
            ]
        ],
        [
            [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut mock_writer = MockWriter { output: String::new() };",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut mock_writer };",
                "",
                "    let result = writer.write_literal_char('a');",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"a\");",
                "}"
            ],
            [
                221,
                222,
                224,
                225,
                226
            ]
        ],
        [
            [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut mock_writer = MockWriter { output: String::new() };",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut mock_writer };",
                "",
                "    let result = writer.write_literal_char('\\\\');",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"\\\\\\\\\");",
                "}"
            ],
            [
                221,
                222,
                223,
                225,
                226
            ]
        ],
        [
            [
                "{",
                "    // Define a struct to implement the `fmt::Write` trait for testing",
                "    struct TestWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for TestWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    // Create a Printer instance",
                "    let mut printer = Printer { _priv: () };",
                "",
                "    // Create a Writer instance with the TestWriter",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: TestWriter { output: String::new() },",
                "    };",
                "",
                "    // Test with a non-meta character",
                "    let result = writer.write_literal_char('a');",
                "    ",
                "    // Assert that the result is Ok and the output is the character itself",
                "    assert!(result.is_ok());",
                "    assert_eq!(writer.wtr.output, \"a\");",
                "",
                "    // Test with other non-meta characters",
                "    let characters = ['b', 'c', '1', 'x', ' '];",
                "    for &c in &characters {",
                "        writer.wtr.output.clear(); // Clear the output before each test",
                "        let result = writer.write_literal_char(c);",
                "        assert!(result.is_ok());",
                "        assert_eq!(writer.wtr.output, c.to_string());",
                "    }",
                "}"
            ],
            [
                221,
                222,
                224,
                225,
                226
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 222,
            "start_column": 12,
            "end_line": 222,
            "end_column": 32,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct MockWriter {",
                "        error_occurred: bool,",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            if self.error_occurred {",
                "                Err(fmt::Error)",
                "            } else {",
                "                self.output.push_str(s);",
                "                Ok(())",
                "            }",
                "        }",
                "    ",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "    ",
                "    let mut mock_writer = MockWriter {",
                "        error_occurred: true,",
                "        output: String::new(),",
                "    };",
                "    ",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut mock_writer,",
                "    };",
                "    ",
                "    let result = writer.write_literal_char('.'); // '.' is a meta character",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 222,
                    "start_column": 12,
                    "end_line": 222,
                    "end_column": 32,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "    ",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "    ",
                "    let mut mock_writer = MockWriter {",
                "        output: String::new(),",
                "    };",
                "    ",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut mock_writer,",
                "    };",
                "    ",
                "    let result = writer.write_literal_char('.'); // '.' is a meta character",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"\\\\.\"); // Expecting the output to include the escaped meta character",
                "}"
            ],
            [
                {
                    "start_line": 222,
                    "start_column": 12,
                    "end_line": 222,
                    "end_column": 32,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "    ",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "    ",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "    ",
                "    let mut mock_writer = MockWriter {",
                "        output: String::new(),",
                "    };",
                "    ",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: &mut mock_writer,",
                "    };",
                "    ",
                "    let result = writer.write_literal_char('a'); // 'a' is not a meta character",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"a\"); // Expecting the output to be the non-escaped character",
                "}"
            ],
            [
                {
                    "start_line": 222,
                    "start_column": 12,
                    "end_line": 222,
                    "end_column": 32,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut mock_writer = MockWriter { output: String::new() };",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut mock_writer };",
                "",
                "    let result = writer.write_literal_char('+');",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"\\\\+\");",
                "}"
            ],
            [
                {
                    "start_line": 222,
                    "start_column": 12,
                    "end_line": 222,
                    "end_column": 32,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut mock_writer = MockWriter { output: String::new() };",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut mock_writer };",
                "",
                "    let result = writer.write_literal_char('a');",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"a\");",
                "}"
            ],
            [
                {
                    "start_line": 222,
                    "start_column": 12,
                    "end_line": 222,
                    "end_column": 32,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct MockWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for MockWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    let mut mock_writer = MockWriter { output: String::new() };",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: &mut mock_writer };",
                "",
                "    let result = writer.write_literal_char('\\\\');",
                "    assert!(result.is_ok());",
                "    assert_eq!(mock_writer.output, \"\\\\\\\\\");",
                "}"
            ],
            [
                {
                    "start_line": 222,
                    "start_column": 12,
                    "end_line": 222,
                    "end_column": 32,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Define a struct to implement the `fmt::Write` trait for testing",
                "    struct TestWriter {",
                "        output: String,",
                "    }",
                "",
                "    impl fmt::Write for TestWriter {",
                "        fn write_str(&mut self, s: &str) -> fmt::Result {",
                "            self.output.push_str(s);",
                "            Ok(())",
                "        }",
                "",
                "        fn write_char(&mut self, c: char) -> fmt::Result {",
                "            self.output.push(c);",
                "            Ok(())",
                "        }",
                "    }",
                "",
                "    // Create a Printer instance",
                "    let mut printer = Printer { _priv: () };",
                "",
                "    // Create a Writer instance with the TestWriter",
                "    let mut writer = Writer {",
                "        printer: &mut printer,",
                "        wtr: TestWriter { output: String::new() },",
                "    };",
                "",
                "    // Test with a non-meta character",
                "    let result = writer.write_literal_char('a');",
                "    ",
                "    // Assert that the result is Ok and the output is the character itself",
                "    assert!(result.is_ok());",
                "    assert_eq!(writer.wtr.output, \"a\");",
                "",
                "    // Test with other non-meta characters",
                "    let characters = ['b', 'c', '1', 'x', ' '];",
                "    for &c in &characters {",
                "        writer.wtr.output.clear(); // Clear the output before each test",
                "        let result = writer.write_literal_char(c);",
                "        assert!(result.is_ok());",
                "        assert_eq!(writer.wtr.output, c.to_string());",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 222,
                    "start_column": 12,
                    "end_line": 222,
                    "end_column": 32,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ]
}