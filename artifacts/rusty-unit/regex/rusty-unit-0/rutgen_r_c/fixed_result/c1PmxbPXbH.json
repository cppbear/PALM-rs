{
    "function_name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_uncounted_repetition",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/ast/parse.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 22,
    "tests_lines": [
        47,
        47,
        26,
        27,
        21,
        21,
        21,
        20,
        20,
        33,
        33,
        30,
        31,
        28,
        28,
        28,
        82,
        82,
        30,
        30,
        30,
        26
    ],
    "oracles": 22,
    "oracles_compiled": 3,
    "oracles_compiled_rate": 13.636363636363635,
    "tests_compiled": 3,
    "tests_compiled_rate": 13.636363636363635,
    "oracles_run": 3,
    "oracles_passed": 1,
    "oracles_passed_rate": 33.33333333333333,
    "tests_run": 3,
    "tests_passed": 1,
    "tests_passed_rate": 33.33333333333333,
    "lines": 37,
    "lines_covered": 14,
    "lines_coveraged_rate": 37.83783783783784,
    "branches": 10,
    "branches_covered": 4,
    "branches_coverage_rate": 40.0,
    "codes_lines": [
        1039,
        1040,
        1041,
        1042,
        1043,
        1044,
        1045,
        1046,
        1047,
        1048,
        1049,
        1050,
        1051,
        1052,
        1054,
        1055,
        1056,
        1057,
        1058,
        1059,
        1060,
        1061,
        1062,
        1063,
        1064,
        1065,
        1066,
        1067,
        1068,
        1069,
        1070,
        1071,
        1072,
        1073,
        1074,
        1075,
        1076
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let span = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
                "    let mut concat = ast::Concat { span, asts: vec![Ast::Empty(span.clone())] };",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 1, line: 1, column: 2 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"abc*\",",
                "    };",
                "",
                "    let result = parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "    assert!(result.is_err());",
                "    if let Err(err) = result {",
                "        assert_eq!(err.kind, ast::ErrorKind::RepetitionMissing);",
                "    }",
                "}"
            ],
            [
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    ",
                "    let mut concat = ast::Concat {",
                "        span,",
                "        asts: vec![],",
                "    };",
                "",
                "    let parser_state = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser_state,",
                "        pattern: \"?\",",
                "    };",
                "    ",
                "    let _result = parser_instance.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "}"
            ],
            [
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1047,
                1049,
                1050,
                1051,
                1052,
                1076
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"a?\";",
                "    let concat = ast::Concat {",
                "        span: ast::Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
                "        asts: vec![], // No preceding AST to pop",
                "    };",
                "",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern,",
                "    };",
                "    ",
                "    parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrOne).unwrap(); // This should panic",
                "}"
            ],
            [
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1045,
            "start_column": 13,
            "end_line": 1045,
            "end_column": 31,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 1045,
            "start_column": 35,
            "end_line": 1045,
            "end_column": 53,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1045,
            "start_column": 57,
            "end_line": 1045,
            "end_column": 75,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1062,
            "start_column": 12,
            "end_line": 1062,
            "end_column": 23,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1062,
            "start_column": 27,
            "end_line": 1062,
            "end_column": 45,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let span = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
                "    let mut concat = ast::Concat { span, asts: vec![Ast::Empty(span.clone())] };",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 1, line: 1, column: 2 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern: \"abc*\",",
                "    };",
                "",
                "    let result = parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "    assert!(result.is_err());",
                "    if let Err(err) = result {",
                "        assert_eq!(err.kind, ast::ErrorKind::RepetitionMissing);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1045,
                    "start_column": 13,
                    "end_line": 1045,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 35,
                    "end_line": 1045,
                    "end_column": 53,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 57,
                    "end_line": 1045,
                    "end_column": 75,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1062,
                    "start_column": 12,
                    "end_line": 1062,
                    "end_column": 23,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1062,
                    "start_column": 27,
                    "end_line": 1062,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    ",
                "    let mut concat = ast::Concat {",
                "        span,",
                "        asts: vec![],",
                "    };",
                "",
                "    let parser_state = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser_state,",
                "        pattern: \"?\",",
                "    };",
                "    ",
                "    let _result = parser_instance.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "}"
            ],
            [
                {
                    "start_line": 1045,
                    "start_column": 13,
                    "end_line": 1045,
                    "end_column": 31,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1045,
                    "start_column": 35,
                    "end_line": 1045,
                    "end_column": 53,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1045,
                    "start_column": 57,
                    "end_line": 1045,
                    "end_column": 75,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1062,
                    "start_column": 12,
                    "end_line": 1062,
                    "end_column": 23,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1062,
                    "start_column": 27,
                    "end_line": 1062,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"a?\";",
                "    let concat = ast::Concat {",
                "        span: ast::Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
                "        asts: vec![], // No preceding AST to pop",
                "    };",
                "",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 100,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(vec![]),",
                "            stack_group: RefCell::new(vec![]),",
                "            stack_class: RefCell::new(vec![]),",
                "            capture_names: RefCell::new(vec![]),",
                "            scratch: RefCell::new(String::new()),",
                "        },",
                "        pattern,",
                "    };",
                "    ",
                "    parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrOne).unwrap(); // This should panic",
                "}"
            ],
            [
                {
                    "start_line": 1045,
                    "start_column": 13,
                    "end_line": 1045,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 35,
                    "end_line": 1045,
                    "end_column": 53,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 57,
                    "end_line": 1045,
                    "end_column": 75,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1062,
                    "start_column": 12,
                    "end_line": 1062,
                    "end_column": 23,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1062,
                    "start_column": 27,
                    "end_line": 1062,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}