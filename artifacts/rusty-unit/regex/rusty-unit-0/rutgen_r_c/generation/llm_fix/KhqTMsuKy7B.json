{
  "name": "regex_debug::escape_byte",
  "name_with_impl": "regex_debug::escape_byte",
  "mod_info": {
    "name": "",
    "loc": "regex-debug/src/main.rs:1:1:328:2"
  },
  "visible": false,
  "loc": "regex-debug/src/main.rs:323:1:328:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let test_cases: Vec<(u8, &str)> = vec![",
                  "        (0, \"\\\\0\"),",
                  "        (1, \"\\\\x01\"),",
                  "        (10, \"\\\\n\"),",
                  "        (13, \"\\\\r\"),",
                  "        (27, \"\\\\x1b\"),",
                  "        (255, \"\\\\xff\"),",
                  "    ];",
                  "",
                  "    for (input, expected) in test_cases {",
                  "        let result = escape_byte(input);",
                  "        assert_eq!(result, expected);",
                  "    }",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let non_printable_bytes: Vec<u8> = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];",
                  "    for byte in non_printable_bytes {",
                  "        let result = escape_byte(byte);",
                  "        assert!(result.starts_with(\"\\\\x\") || result == \"\\\\0\" || result == \"\\\\n\" || result == \"\\\\r\");",
                  "    }",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let high_byte: u8 = 128;",
                  "    let result = escape_byte(high_byte);",
                  "    assert_eq!(result, \"\\\\x80\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result_zero = escape_byte(0);",
                  "    assert_eq!(result_zero, \"\\\\0\");",
                  "",
                  "    let result_255 = escape_byte(255);",
                  "    assert_eq!(result_255, \"\\\\xff\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}