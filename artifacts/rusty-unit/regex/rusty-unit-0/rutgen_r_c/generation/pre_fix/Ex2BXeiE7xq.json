{
  "name": "regex_syntax::hir::hir::ClassBytesRange::new",
  "name_with_impl": "regex_syntax::hir::{impl#18}::new",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:116:1:116:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:1059:5:1061:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let range = ClassBytesRange::new(10, 20);",
                  "    assert_eq!(range.start(), 10);",
                  "    assert_eq!(range.end(), 20);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let range = ClassBytesRange::new(15, 15);",
                  "    assert_eq!(range.start(), 15);",
                  "    assert_eq!(range.end(), 15);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let range = ClassBytesRange::new(20, 10);",
                  "    assert_eq!(range.start(), 10);",
                  "    assert_eq!(range.end(), 20);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let range = ClassBytesRange::new(0, 0);",
                  "    assert_eq!(range.start(), 0);",
                  "    assert_eq!(range.end(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let range = ClassBytesRange::new(255, 255);",
                  "    assert_eq!(range.start(), 255);",
                  "    assert_eq!(range.end(), 255);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let range = ClassBytesRange::new(256, 255);",
                  "    assert_eq!(range.start(), 255);",
                  "    assert_eq!(range.end(), 256);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/mod.rs:2061:8\n     |\n2061 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/mod.rs:2065:38\n     |\n2065 |     let range = ClassBytesRange::new(256, 255);\n     |                                      ^^^\n     |\n     = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/mod.rs:2067:29\n     |\n2067 |     assert_eq!(range.end(), 256);\n     |                             ^^^\n     |\n     = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 94 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 94 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let range = ClassBytesRange::new(255, 256);",
                  "    assert_eq!(range.start(), 255);",
                  "    assert_eq!(range.end(), 256);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/mod.rs:2061:8\n     |\n2061 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/mod.rs:2065:43\n     |\n2065 |     let range = ClassBytesRange::new(255, 256);\n     |                                           ^^^\n     |\n     = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n     = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n    --> regex-syntax/src/hir/mod.rs:2067:29\n     |\n2067 |     assert_eq!(range.end(), 256);\n     |                             ^^^\n     |\n     = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 94 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 94 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}