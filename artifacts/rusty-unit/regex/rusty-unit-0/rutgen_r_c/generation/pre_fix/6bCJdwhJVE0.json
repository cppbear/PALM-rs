{
  "name": "regex_syntax::hir::literal::escape_unicode",
  "name_with_impl": "regex_syntax::hir::literal::escape_unicode",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:27:1:27:17"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/literal/mod.rs:948:1:971:2",
  "fn_tests": [
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Err(_) is true\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = &[0, 159, 146, 150]; // Invalid UTF-8 bytes",
                  "    let expected_output = r\"\\x00\\x9f\\x92\\x96\"; // Expect bytes to be escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello\\xFFWorld\"; // Contains invalid UTF-8 bytes",
                  "    let result = escape_unicode(input);",
                  "    assert_ne!(result, \"\"); // Ensure the result is not empty",
                  "    assert!(result.contains(\"Hello\")); // Check if non-whitespace chars remain",
                  "    assert!(result.contains(\"W\")); // Check if non-whitespace chars remain",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\" \\n\\t \"; // Valid UTF-8 but all whitespace",
                  "    let expected_output = r\"\\u{0020}\\u{000a}\\u{0009}\\u{0020}\"; // Spaces and newlines escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\" Hello \\xFF World \"; // Mixed valid UTF-8 and invalid bytes",
                  "    let expected_output = r\" Hello \\u{ff} World \"; // Invalid byte should be escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is true\n",
        "// constraint: c as u32 <= 0x7F is true, with bound c as u32 == 0x7F\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello World\\n\"; // Contains whitespace and valid UTF-8",
                  "    let expected = \"Hello\\\\n\"; // Expecting newline to be escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello World \"; // Contains space and valid UTF-8",
                  "    let expected = \"Hello\\\\ World\"; // Expecting space to be escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\u{00A0}World\".as_bytes(); // Non-breaking space (U+00A0) is from valid UTF-8",
                  "    let expected = \"Hello \\\\u{00a0}World\"; // Non-breaking space should be Unicode escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\u{2003}World\".as_bytes(); // Em Space (U+2003) is from valid UTF-8",
                  "    let expected = \"Hello \\\\u{2003}World\"; // Em space should be Unicode escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = &[0xff, 0xfe, 0xfd]; // Invalid UTF-8 bytes",
                  "    let expected = \"\\\\xff\\\\xfe\\\\xfd\"; // All bytes should be escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is true\n",
        "// constraint: c as u32 <= 0x7F is false\n",
        "// constraint: c as u32 <= 0xFFFF is true, with bound c as u32 == 0xFFFF\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let expected = \"\";",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"Hello World\"; // ASCII spaces",
                  "    let expected = \"Hello World\"; // No escaping occurs",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = \"Hello \\u{00A0}World\".as_bytes(); // Non-breaking space (U+00A0)",
                  "    let expected = format!(\"Hello \\\\u{{00a0}}World\");",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = \"Hello \\u{FFFF}World\".as_bytes(); // Upper bound character (U+FFFF)",
                  "    let expected = format!(\"Hello \\\\u{{ffff}}World\");",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = \"HelloWorld\".as_bytes(); // No whitespace characters",
                  "    let expected = \"HelloWorld\"; // No escaping occurs",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is true\n",
        "// constraint: c as u32 <= 0x7F is false\n",
        "// constraint: c as u32 <= 0xFFFF is false\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello World\"; // Valid UTF-8 with no whitespace escaping",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello World\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\t\\n World\".as_bytes(); // Valid UTF-8 with whitespace characters",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello \\t\\n World\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\u{00A0}World\".as_bytes(); // Non-ASCII whitespace character (no escaping expected)",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello \\u{00A0}World\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\u{202F}World\".as_bytes(); // Non-ASCII whitespace, should be escaped",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello \\\\u{202f}World\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello ðŸ˜Š World\".as_bytes(); // Emojis should remain intact",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello ðŸ˜Š World\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = \"Hello \\u{1F600}World\".as_bytes(); // Larger Unicode characters",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello \\\\U{0001f600}World\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"\"; // Empty input",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = &[0xFF, 0xFE, 0xFD]; // Non-UTF-8 byte sequence",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"\\\\xff\\\\xfe\\\\xfd\"); // All bytes should be escaped",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is true\n",
        "// constraint: c.is_whitespace() is false\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"Hello World\"; // Valid UTF-8 with no whitespace",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello World\"); // Should return the same string",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"Hello \\tWorld\"; // Valid UTF-8 with a tab (whitespace)",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello \\u{0009}World\"); // Tab should be escaped",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"Hello\\nWorld\"; // Valid UTF-8 with a newline (whitespace)",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"Hello\\nWorld\"); // Newline should remain unescaped",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = &[0xFF, 0xFE, 0xFD]; // Invalid UTF-8 bytes",
                  "    let result = escape_unicode(input);",
                  "    assert!(result.contains(r\"\\xff\") || result.contains(r\"\\xfe\") || result.contains(r\"\\xfd\")); // Check that bytes are escaped",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"\"; // Empty input",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, \"\"); // Should return an empty string",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: ::std::str::from_utf8(bytes) matches Ok(v) is true\n",
        "// constraint: c in show.chars() is false\n",
        "// expected return value/type: space_escaped\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello World\";",
                  "    let expected_output = \"Hello World\";",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello\\tWorld\\n\";",
                  "    let expected_output = \"Hello\\tWorld\\n\";  // Assuming tab and newline are preserved",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"Hello \\xE2\\x9C\\x94\"; // Unicode checkmark character \"âœ“\"",
                  "    let expected_output = \"Hello \\u{2714}\"; // Should be escaped as Unicode",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"\\xFF\\xFE\\xFD\"; // Invalid UTF-8 bytes",
                  "    let expected_output = \"\\u{ff}\\u{fe}\\u{fd}\"; // Expected to escape bytes to Unicode",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input = b\"\\xF0\\x9F\\x92\\xA9\"; // Unicode for pile of poop \"ðŸ’©\"",
                  "    let expected_output = r\"\\U{1f4a9}\";",
                  "    let result = escape_unicode(input);",
                  "    assert_eq!(result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}