{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/dfa.rs\n// crate name is regex\nThe function to be tested is presented as follows:\n/// Follows the epsilon transitions starting at (and including) `ip`. The\n/// resulting states are inserted into the ordered set `q`.\n///\n/// Conditional epsilon transitions (i.e., empty width assertions) are only\n/// followed if they are satisfied by the given flags, which should\n/// represent the flags set at the current location in the input.\n///\n/// If the current location corresponds to the empty string, then only the\n/// end line and/or end text flags may be set. If the current location\n/// corresponds to a real byte in the input, then only the start line\n/// and/or start text flags may be set.\n///\n/// As an exception to the above, when finding the initial state, any of\n/// the above flags may be set:\n///\n/// If matching starts at the beginning of the input, then start text and\n/// start line should be set. If the input is empty, then end text and end\n/// line should also be set.\n///\n/// If matching starts after the beginning of the input, then only start\n/// line should be set if the preceding byte is `\\n`. End line should never\n/// be set in this case. (Even if the proceding byte is a `\\n`, it will\n/// be handled in a subsequent DFA state.)\nfn follow_epsilons(\n    &mut self,\n    ip: InstPtr,\n    q: &mut SparseSet,\n    flags: EmptyFlags,\n) {\n    use prog::Inst::*;\n    use prog::EmptyLook::*;\n\n    // We need to traverse the NFA to follow epsilon transitions, so avoid\n    // recursion with an explicit stack.\n    self.cache.stack.push(ip);\n    while let Some(mut ip) = self.cache.stack.pop() {\n        // Try to munch through as many states as possible without\n        // pushes/pops to the stack.\n        loop {\n            // Don't visit states we've already added.\n            if q.contains(ip as usize) {\n                break;\n            }\n            q.insert(ip as usize);\n            match self.prog[ip as usize] {\n                Char(_) | Ranges(_) => unreachable!(),\n                Match(_) | Bytes(_) => {\n                    break;\n                }\n                EmptyLook(ref inst) => {\n                    // Only follow empty assertion states if our flags\n                    // satisfy the assertion.\n                    match inst.look {\n                        StartLine if flags.start_line => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        EndLine if flags.end_line => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        StartText if flags.start => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        EndText if flags.end => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        WordBoundaryAscii if flags.word_boundary => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        NotWordBoundaryAscii if flags.not_word_boundary => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        WordBoundary if flags.word_boundary => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        NotWordBoundary if flags.not_word_boundary => {\n                            ip = inst.goto as InstPtr;\n                        }\n                        StartLine | EndLine | StartText | EndText\n                        | WordBoundaryAscii | NotWordBoundaryAscii\n                        | WordBoundary | NotWordBoundary => {\n                            break;\n                        }\n                    }\n                }\n                Save(ref inst) => {\n                    ip = inst.goto as InstPtr;\n                }\n                Split(ref inst) => {\n                    self.cache.stack.push(inst.goto2 as InstPtr);\n                    ip = inst.goto1 as InstPtr;\n                }\n            }\n        }\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}