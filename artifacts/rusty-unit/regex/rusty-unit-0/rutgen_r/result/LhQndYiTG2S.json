{
    "function_name": "regex::exec::exec::ExecNoSync<'c>::find_literals",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/src/exec.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex",
    "tests": 13,
    "tests_lines": [
        42,
        40,
        39,
        73,
        68,
        13,
        13,
        48,
        48,
        46,
        47,
        57,
        55
    ],
    "oracles": 13,
    "oracles_compiled": 6,
    "oracles_compiled_rate": 46.15384615384615,
    "tests_compiled": 6,
    "tests_compiled_rate": 46.15384615384615,
    "oracles_run": 6,
    "oracles_passed": 2,
    "oracles_passed_rate": 33.33333333333333,
    "tests_run": 6,
    "tests_passed": 2,
    "tests_passed_rate": 33.33333333333333,
    "lines": 20,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 6,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        608,
        609,
        610,
        611,
        612,
        613,
        615,
        617,
        618,
        619,
        622,
        623,
        624,
        625,
        626,
        628,
        632,
        633,
        634,
        637
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct NFA {",
                "        prefixes: Vec<(usize, usize)>,",
                "        is_anchored_start: bool,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                prefixes: vec![(0, 3), (5, 8)], // Example prefixes",
                "                is_anchored_start: false,",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"hello world, this is a test\";",
                "    let start = 0;",
                "",
                "    // Test with Unanchored Literal Search",
                "    let result = matcher.find_literals(MatchLiteralType::Unanchored, text, start);",
                "    assert_eq!(result, Some((0, 3))); // Should find \"hel\"",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct NFA {",
                "        prefixes: Vec<(usize, usize)>,",
                "        is_anchored_start: bool,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                prefixes: vec![(0, 3), (5, 8)], // Example prefixes",
                "                is_anchored_start: false,",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"hello world, this is a test\";",
                "    let start = 0;",
                "",
                "    // Test with AnchoredStart Literal Search (should return None)",
                "    let result = matcher.find_literals(MatchLiteralType::AnchoredStart, text, start);",
                "    assert_eq!(result, None); // Because is_anchored_start is false",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct NFA {",
                "        suffixes: Vec<(usize, usize)>,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                suffixes: vec![(0, 4), (5, 7)], // Example suffixes",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"this is a test\";",
                "    let start = 0;",
                "",
                "    // Test with AnchoredEnd Literal Search",
                "    let result = matcher.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                "    assert_eq!(result, None); // Should return None as there is no specific literal match at the end",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct NFA {",
                "        prefixes: Vec<(usize, usize)>,",
                "        is_anchored_start: bool,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                prefixes: vec![(0, 3)],",
                "                is_anchored_start: false,",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"short\";",
                "    let start = 10; // Out of bounds",
                "",
                "    // This will trigger a panic due to out-of-bounds access",
                "    matcher.find_literals(MatchLiteralType::Unanchored, text, start);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct MatchLiteralType;",
                "    ",
                "    struct NFA {",
                "        prefixes: Prefixes,",
                "        is_anchored_start: bool,",
                "    }",
                "    ",
                "    struct Regex {",
                "        nfa: NFA,",
                "    }",
                "    ",
                "    impl Regex {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function implementation goes here",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    struct Prefixes {",
                "        patterns: Vec<&'static [u8]>,",
                "    }",
                "",
                "    impl Prefixes {",
                "        fn find(&self, text: &[u8]) -> Option<(usize, usize)> {",
                "            for pattern in &self.patterns {",
                "                if let Some(idx) = text.windows(pattern.len()).position(|window| window == *pattern) {",
                "                    return Some((idx, idx + pattern.len()));",
                "                }",
                "            }",
                "            None",
                "        }",
                "    }",
                "",
                "    let prefixes = Prefixes {",
                "        patterns: vec![b\"abc\", b\"def\", b\"ghi\"],",
                "    };",
                "",
                "    let nfa = NFA {",
                "        prefixes,",
                "        is_anchored_start: false,",
                "    };",
                "",
                "    let regex = Regex { nfa };",
                "",
                "    let text = b\"abcdefghi\";",
                "    let start = 0;",
                "",
                "    let result = regex.find_literals(MatchLiteralType, text, start);",
                "    ",
                "    assert_eq!(result, Some((0, 3))); // pattern \"abc\" found",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct MatchLiteralType;",
                "    ",
                "    struct NFA {",
                "        prefixes: Prefixes,",
                "        is_anchored_start: bool,",
                "    }",
                "    ",
                "    struct Regex {",
                "        nfa: NFA,",
                "    }",
                "",
                "    impl Regex {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function implementation goes here",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    struct Prefixes {",
                "        patterns: Vec<&'static [u8]>,",
                "    }",
                "",
                "    impl Prefixes {",
                "        fn find(&self, text: &[u8]) -> Option<(usize, usize)> {",
                "            for pattern in &self.patterns {",
                "                if let Some(idx) = text.windows(pattern.len()).position(|window| window == *pattern) {",
                "                    return Some((idx, idx + pattern.len()));",
                "                }",
                "            }",
                "            None",
                "        }",
                "    }",
                "",
                "    let prefixes = Prefixes {",
                "        patterns: vec![b\"abc\"],",
                "    };",
                "",
                "    let nfa = NFA {",
                "        prefixes,",
                "        is_anchored_start: false,",
                "    };",
                "",
                "    let regex = Regex { nfa };",
                "",
                "    let text = b\"\"; // empty text",
                "    let start = 0; // start index at the beginning",
                "",
                "    let _result = regex.find_literals(MatchLiteralType, text, start); // This should panic",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 623,
            "start_column": 20,
            "end_line": 623,
            "end_column": 50,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 624,
            "start_column": 25,
            "end_line": 624,
            "end_column": 54,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 624,
            "start_column": 58,
            "end_line": 624,
            "end_column": 68,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct NFA {",
                "        prefixes: Vec<(usize, usize)>,",
                "        is_anchored_start: bool,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                prefixes: vec![(0, 3), (5, 8)], // Example prefixes",
                "                is_anchored_start: false,",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"hello world, this is a test\";",
                "    let start = 0;",
                "",
                "    // Test with Unanchored Literal Search",
                "    let result = matcher.find_literals(MatchLiteralType::Unanchored, text, start);",
                "    assert_eq!(result, Some((0, 3))); // Should find \"hel\"",
                "}"
            ],
            [
                {
                    "start_line": 623,
                    "start_column": 20,
                    "end_line": 623,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 25,
                    "end_line": 624,
                    "end_column": 54,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 58,
                    "end_line": 624,
                    "end_column": 68,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct NFA {",
                "        prefixes: Vec<(usize, usize)>,",
                "        is_anchored_start: bool,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                prefixes: vec![(0, 3), (5, 8)], // Example prefixes",
                "                is_anchored_start: false,",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"hello world, this is a test\";",
                "    let start = 0;",
                "",
                "    // Test with AnchoredStart Literal Search (should return None)",
                "    let result = matcher.find_literals(MatchLiteralType::AnchoredStart, text, start);",
                "    assert_eq!(result, None); // Because is_anchored_start is false",
                "}"
            ],
            [
                {
                    "start_line": 623,
                    "start_column": 20,
                    "end_line": 623,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 25,
                    "end_line": 624,
                    "end_column": 54,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 58,
                    "end_line": 624,
                    "end_column": 68,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct NFA {",
                "        suffixes: Vec<(usize, usize)>,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                suffixes: vec![(0, 4), (5, 7)], // Example suffixes",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"this is a test\";",
                "    let start = 0;",
                "",
                "    // Test with AnchoredEnd Literal Search",
                "    let result = matcher.find_literals(MatchLiteralType::AnchoredEnd, text, start);",
                "    assert_eq!(result, None); // Should return None as there is no specific literal match at the end",
                "}"
            ],
            [
                {
                    "start_line": 623,
                    "start_column": 20,
                    "end_line": 623,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 25,
                    "end_line": 624,
                    "end_column": 54,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 58,
                    "end_line": 624,
                    "end_column": 68,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct NFA {",
                "        prefixes: Vec<(usize, usize)>,",
                "        is_anchored_start: bool,",
                "    }",
                "",
                "    struct RO {",
                "        nfa: NFA,",
                "    }",
                "",
                "    struct Matcher {",
                "        ro: RO,",
                "    }",
                "",
                "    impl Matcher {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function definition omitted for brevity",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    enum MatchLiteralType {",
                "        Unanchored,",
                "        AnchoredStart,",
                "        AnchoredEnd,",
                "    }",
                "",
                "    let matcher = Matcher {",
                "        ro: RO {",
                "            nfa: NFA {",
                "                prefixes: vec![(0, 3)],",
                "                is_anchored_start: false,",
                "            },",
                "        },",
                "    };",
                "",
                "    let text = b\"short\";",
                "    let start = 10; // Out of bounds",
                "",
                "    // This will trigger a panic due to out-of-bounds access",
                "    matcher.find_literals(MatchLiteralType::Unanchored, text, start);",
                "}"
            ],
            [
                {
                    "start_line": 623,
                    "start_column": 20,
                    "end_line": 623,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 25,
                    "end_line": 624,
                    "end_column": 54,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 58,
                    "end_line": 624,
                    "end_column": 68,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct MatchLiteralType;",
                "    ",
                "    struct NFA {",
                "        prefixes: Prefixes,",
                "        is_anchored_start: bool,",
                "    }",
                "    ",
                "    struct Regex {",
                "        nfa: NFA,",
                "    }",
                "    ",
                "    impl Regex {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function implementation goes here",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    struct Prefixes {",
                "        patterns: Vec<&'static [u8]>,",
                "    }",
                "",
                "    impl Prefixes {",
                "        fn find(&self, text: &[u8]) -> Option<(usize, usize)> {",
                "            for pattern in &self.patterns {",
                "                if let Some(idx) = text.windows(pattern.len()).position(|window| window == *pattern) {",
                "                    return Some((idx, idx + pattern.len()));",
                "                }",
                "            }",
                "            None",
                "        }",
                "    }",
                "",
                "    let prefixes = Prefixes {",
                "        patterns: vec![b\"abc\", b\"def\", b\"ghi\"],",
                "    };",
                "",
                "    let nfa = NFA {",
                "        prefixes,",
                "        is_anchored_start: false,",
                "    };",
                "",
                "    let regex = Regex { nfa };",
                "",
                "    let text = b\"abcdefghi\";",
                "    let start = 0;",
                "",
                "    let result = regex.find_literals(MatchLiteralType, text, start);",
                "    ",
                "    assert_eq!(result, Some((0, 3))); // pattern \"abc\" found",
                "}"
            ],
            [
                {
                    "start_line": 623,
                    "start_column": 20,
                    "end_line": 623,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 25,
                    "end_line": 624,
                    "end_column": 54,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 58,
                    "end_line": 624,
                    "end_column": 68,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct MatchLiteralType;",
                "    ",
                "    struct NFA {",
                "        prefixes: Prefixes,",
                "        is_anchored_start: bool,",
                "    }",
                "    ",
                "    struct Regex {",
                "        nfa: NFA,",
                "    }",
                "",
                "    impl Regex {",
                "        fn find_literals(",
                "            &self,",
                "            ty: MatchLiteralType,",
                "            text: &[u8],",
                "            start: usize,",
                "        ) -> Option<(usize, usize)> {",
                "            // Function implementation goes here",
                "            unimplemented!()",
                "        }",
                "    }",
                "",
                "    struct Prefixes {",
                "        patterns: Vec<&'static [u8]>,",
                "    }",
                "",
                "    impl Prefixes {",
                "        fn find(&self, text: &[u8]) -> Option<(usize, usize)> {",
                "            for pattern in &self.patterns {",
                "                if let Some(idx) = text.windows(pattern.len()).position(|window| window == *pattern) {",
                "                    return Some((idx, idx + pattern.len()));",
                "                }",
                "            }",
                "            None",
                "        }",
                "    }",
                "",
                "    let prefixes = Prefixes {",
                "        patterns: vec![b\"abc\"],",
                "    };",
                "",
                "    let nfa = NFA {",
                "        prefixes,",
                "        is_anchored_start: false,",
                "    };",
                "",
                "    let regex = Regex { nfa };",
                "",
                "    let text = b\"\"; // empty text",
                "    let start = 0; // start index at the beginning",
                "",
                "    let _result = regex.find_literals(MatchLiteralType, text, start); // This should panic",
                "}"
            ],
            [
                {
                    "start_line": 623,
                    "start_column": 20,
                    "end_line": 623,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 25,
                    "end_line": 624,
                    "end_column": 54,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 624,
                    "start_column": 58,
                    "end_line": 624,
                    "end_column": 68,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}