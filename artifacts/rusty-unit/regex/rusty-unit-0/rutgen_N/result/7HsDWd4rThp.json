{
    "function_name": "regex::re_unicode::<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/src/re_unicode.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex",
    "tests": 2,
    "tests_lines": [
        48,
        46
    ],
    "oracles": 2,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 100.0,
    "oracles_run": 2,
    "oracles_passed": 2,
    "oracles_passed_rate": 100.0,
    "tests_run": 2,
    "tests_passed": 2,
    "tests_passed_rate": 100.0,
    "lines": 15,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 2,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        891,
        892,
        893,
        894,
        895,
        896,
        897,
        898,
        899,
        900,
        901,
        902,
        903,
        905,
        906
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    use std::fmt;",
                "    use std::collections::HashMap;",
                "",
                "    struct TestStruct {",
                "        named_groups: HashMap<String, usize>,",
                "        locs: Vec<Option<(usize, usize)>>,",
                "        text: String,",
                "    }",
                "",
                "    impl TestStruct {",
                "        fn new(named_groups: HashMap<String, usize>, locs: Vec<Option<(usize, usize)>>, text: String) -> Self {",
                "            TestStruct { named_groups, locs, text }",
                "        }",
                "    }",
                "",
                "    impl fmt::Debug for TestStruct {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            let slot_to_name: HashMap<&usize, &String> =",
                "                self.named_groups.iter().map(|(a, b)| (b, a)).collect();",
                "            let mut map = f.debug_map();",
                "            for (slot, m) in self.locs.iter().enumerate() {",
                "                let m = m.map(|(s, e)| &self.text[s..e]);",
                "                if let Some(name) = slot_to_name.get(&slot) {",
                "                    map.entry(name, &m);",
                "                } else {",
                "                    map.entry(&slot, &m);",
                "                }",
                "            }",
                "            map.finish()",
                "        }",
                "    }",
                "",
                "    let mut named_groups = HashMap::new();",
                "    named_groups.insert(\"group1\".to_string(), 0);",
                "    named_groups.insert(\"group2\".to_string(), 1);",
                "",
                "    let locs = vec![Some((0, 5)), Some((6, 11)), None];",
                "    let text = \"Hello World\".to_string();",
                "",
                "    let test_struct = TestStruct::new(named_groups, locs, text);",
                "    ",
                "    let result = format!(\"{:?}\", test_struct);",
                "    assert!(result.contains(\"group1\"));",
                "    assert!(result.contains(\"Hello\"));",
                "    assert!(result.contains(\"group2\"));",
                "    assert!(result.contains(\"World\"));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::fmt;",
                "    use std::collections::HashMap;",
                "",
                "    struct TestStruct {",
                "        named_groups: HashMap<String, usize>,",
                "        locs: Vec<Option<(usize, usize)>>,",
                "        text: String,",
                "    }",
                "",
                "    impl TestStruct {",
                "        fn new(named_groups: HashMap<String, usize>, locs: Vec<Option<(usize, usize)>>, text: String) -> Self {",
                "            TestStruct { named_groups, locs, text }",
                "        }",
                "    }",
                "",
                "    impl fmt::Debug for TestStruct {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            let slot_to_name: HashMap<&usize, &String> =",
                "                self.named_groups.iter().map(|(a, b)| (b, a)).collect();",
                "            let mut map = f.debug_map();",
                "            for (slot, m) in self.locs.iter().enumerate() {",
                "                let m = m.map(|(s, e)| &self.text[s..e]);",
                "                if let Some(name) = slot_to_name.get(&slot) {",
                "                    map.entry(name, &m);",
                "                } else {",
                "                    map.entry(&slot, &m);",
                "                }",
                "            }",
                "            map.finish()",
                "        }",
                "    }",
                "",
                "    let named_groups = HashMap::new();",
                "",
                "    let locs = vec![Some((0, 5)), Some((6, 11)), None];",
                "    let text = \"Hello World\".to_string();",
                "",
                "    let test_struct = TestStruct::new(named_groups, locs, text);",
                "    ",
                "    let result = format!(\"{:?}\", test_struct);",
                "    assert!(result.contains(\"0\"));",
                "    assert!(result.contains(\"Hello\"));",
                "    assert!(result.contains(\"1\"));",
                "    assert!(result.contains(\"World\"));",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 899,
            "start_column": 20,
            "end_line": 899,
            "end_column": 30,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    use std::fmt;",
                "    use std::collections::HashMap;",
                "",
                "    struct TestStruct {",
                "        named_groups: HashMap<String, usize>,",
                "        locs: Vec<Option<(usize, usize)>>,",
                "        text: String,",
                "    }",
                "",
                "    impl TestStruct {",
                "        fn new(named_groups: HashMap<String, usize>, locs: Vec<Option<(usize, usize)>>, text: String) -> Self {",
                "            TestStruct { named_groups, locs, text }",
                "        }",
                "    }",
                "",
                "    impl fmt::Debug for TestStruct {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            let slot_to_name: HashMap<&usize, &String> =",
                "                self.named_groups.iter().map(|(a, b)| (b, a)).collect();",
                "            let mut map = f.debug_map();",
                "            for (slot, m) in self.locs.iter().enumerate() {",
                "                let m = m.map(|(s, e)| &self.text[s..e]);",
                "                if let Some(name) = slot_to_name.get(&slot) {",
                "                    map.entry(name, &m);",
                "                } else {",
                "                    map.entry(&slot, &m);",
                "                }",
                "            }",
                "            map.finish()",
                "        }",
                "    }",
                "",
                "    let mut named_groups = HashMap::new();",
                "    named_groups.insert(\"group1\".to_string(), 0);",
                "    named_groups.insert(\"group2\".to_string(), 1);",
                "",
                "    let locs = vec![Some((0, 5)), Some((6, 11)), None];",
                "    let text = \"Hello World\".to_string();",
                "",
                "    let test_struct = TestStruct::new(named_groups, locs, text);",
                "    ",
                "    let result = format!(\"{:?}\", test_struct);",
                "    assert!(result.contains(\"group1\"));",
                "    assert!(result.contains(\"Hello\"));",
                "    assert!(result.contains(\"group2\"));",
                "    assert!(result.contains(\"World\"));",
                "}"
            ],
            [
                {
                    "start_line": 899,
                    "start_column": 20,
                    "end_line": 899,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::fmt;",
                "    use std::collections::HashMap;",
                "",
                "    struct TestStruct {",
                "        named_groups: HashMap<String, usize>,",
                "        locs: Vec<Option<(usize, usize)>>,",
                "        text: String,",
                "    }",
                "",
                "    impl TestStruct {",
                "        fn new(named_groups: HashMap<String, usize>, locs: Vec<Option<(usize, usize)>>, text: String) -> Self {",
                "            TestStruct { named_groups, locs, text }",
                "        }",
                "    }",
                "",
                "    impl fmt::Debug for TestStruct {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            let slot_to_name: HashMap<&usize, &String> =",
                "                self.named_groups.iter().map(|(a, b)| (b, a)).collect();",
                "            let mut map = f.debug_map();",
                "            for (slot, m) in self.locs.iter().enumerate() {",
                "                let m = m.map(|(s, e)| &self.text[s..e]);",
                "                if let Some(name) = slot_to_name.get(&slot) {",
                "                    map.entry(name, &m);",
                "                } else {",
                "                    map.entry(&slot, &m);",
                "                }",
                "            }",
                "            map.finish()",
                "        }",
                "    }",
                "",
                "    let named_groups = HashMap::new();",
                "",
                "    let locs = vec![Some((0, 5)), Some((6, 11)), None];",
                "    let text = \"Hello World\".to_string();",
                "",
                "    let test_struct = TestStruct::new(named_groups, locs, text);",
                "    ",
                "    let result = format!(\"{:?}\", test_struct);",
                "    assert!(result.contains(\"0\"));",
                "    assert!(result.contains(\"Hello\"));",
                "    assert!(result.contains(\"1\"));",
                "    assert!(result.contains(\"World\"));",
                "}"
            ],
            [
                {
                    "start_line": 899,
                    "start_column": 20,
                    "end_line": 899,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}