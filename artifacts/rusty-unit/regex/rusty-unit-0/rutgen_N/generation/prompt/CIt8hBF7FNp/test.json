{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// regex-syntax/src/ast/parse.rs\n// crate name is regex_syntax\nThe function to be tested is presented as follows:\n/// Parses the opening of a character class set. This includes the opening\n/// bracket along with `^` if present to indicate negation. This also\n/// starts parsing the opening set of unioned items if applicable, since\n/// there are special rules applied to certain characters in the opening\n/// of a character class. For example, `[^]]` is the class of all\n/// characters not equal to `]`. (`]` would need to be escaped in any other\n/// position.) Similarly for `-`.\n///\n/// In all cases, the op inside the returned `ast::ClassBracketed` is an\n/// empty union. This empty union should be replaced with the actual item\n/// when it is popped from the parser's stack.\n///\n/// This assumes the parser is positioned at the opening `[` and advances\n/// the parser to the first non-special byte of the character class.\n///\n/// An error is returned if EOF is found.\nfn parse_set_class_open(\n    &self,\n) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {\n    assert_eq!(self.char(), '[');\n    let start = self.pos();\n    if !self.bump_and_bump_space() {\n        return Err(self.error(\n            Span::new(start, self.pos()),\n            ast::ErrorKind::ClassUnclosed,\n        ));\n    }\n\n    let negated =\n        if self.char() != '^' {\n            false\n        } else {\n            if !self.bump_and_bump_space() {\n                return Err(self.error(\n                    Span::new(start, self.pos()),\n                    ast::ErrorKind::ClassUnclosed,\n                ));\n            }\n            true\n        };\n    // Accept any number of `-` as literal `-`.\n    let mut union = ast::ClassSetUnion {\n        span: self.span(),\n        items: vec![],\n    };\n    while self.char() == '-' {\n        union.push(ast::ClassSetItem::Literal(ast::Literal {\n            span: self.span_char(),\n            kind: ast::LiteralKind::Verbatim,\n            c: '-',\n        }));\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::ClassUnclosed,\n            ));\n        }\n    }\n    // If `]` is the *first* char in a set, then interpret it as a literal\n    // `]`. That is, an empty class is impossible to write.\n    if union.items.is_empty() && self.char() == ']' {\n        union.push(ast::ClassSetItem::Literal(ast::Literal {\n            span: self.span_char(),\n            kind: ast::LiteralKind::Verbatim,\n            c: ']',\n        }));\n        if !self.bump_and_bump_space() {\n            return Err(self.error(\n                Span::new(start, self.pos()),\n                ast::ErrorKind::ClassUnclosed,\n            ));\n        }\n    }\n    let set = ast::ClassBracketed {\n        span: Span::new(start, self.pos()),\n        negated: negated,\n        kind: ast::ClassSet::union(ast::ClassSetUnion {\n            span: Span::new(union.span.start, union.span.start),\n            items: vec![],\n        }),\n    };\n    Ok((set, union))\n}\n",
  "depend_pt": ""
}