{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/dfa.rs\n// crate name is regex\nThe function to be tested is presented as follows:\n/// Executes the DFA on a forward NFA.\n///\n/// {qcur,qnext} are scratch ordered sets which may be non-empty.\nfn exec_at(\n    &mut self,\n    qcur: &mut SparseSet,\n    qnext: &mut SparseSet,\n    text: &[u8],\n) -> Result<usize> {\n    // For the most part, the DFA is basically:\n    //\n    //   last_match = null\n    //   while current_byte != EOF:\n    //     si = current_state.next[current_byte]\n    //     if si is match\n    //       last_match = si\n    //   return last_match\n    //\n    // However, we need to deal with a few things:\n    //\n    //   1. This is an *online* DFA, so the current state's next list\n    //      may not point to anywhere yet, so we must go out and compute\n    //      them. (They are then cached into the current state's next list\n    //      to avoid re-computation.)\n    //   2. If we come across a state that is known to be dead (i.e., never\n    //      leads to a match), then we can quit early.\n    //   3. If the caller just wants to know if a match occurs, then we\n    //      can quit as soon as we know we have a match. (Full leftmost\n    //      first semantics require continuing on.)\n    //   4. If we're in the start state, then we can use a pre-computed set\n    //      of prefix literals to skip quickly along the input.\n    //   5. After the input is exhausted, we run the DFA on one symbol\n    //      that stands for EOF. This is useful for handling empty width\n    //      assertions.\n    //   6. We can't actually do state.next[byte]. Instead, we have to do\n    //      state.next[byte_classes[byte]], which permits us to keep the\n    //      'next' list very small.\n    //\n    // Since there's a bunch of extra stuff we need to consider, we do some\n    // pretty hairy tricks to get the inner loop to run as fast as\n    // possible.\n    debug_assert!(!self.prog.is_reverse);\n\n    // The last match is the currently known ending match position. It is\n    // reported as an index to the most recent byte that resulted in a\n    // transition to a match state and is always stored in capture slot `1`\n    // when searching forwards. Its maximum value is `text.len()`.\n    let mut result = Result::NoMatch(self.at);\n    let (mut prev_si, mut next_si) = (self.start, self.start);\n    let mut at = self.at;\n    while at < text.len() {\n        // This is the real inner loop. We take advantage of special bits\n        // set in the state pointer to determine whether a state is in the\n        // \"common\" case or not. Specifically, the common case is a\n        // non-match non-start non-dead state that has already been\n        // computed. So long as we remain in the common case, this inner\n        // loop will chew through the input.\n        //\n        // We also unroll the loop 4 times to amortize the cost of checking\n        // whether we've consumed the entire input. We are also careful\n        // to make sure that `prev_si` always represents the previous state\n        // and `next_si` always represents the next state after the loop\n        // exits, even if it isn't always true inside the loop.\n        while next_si <= STATE_MAX && at < text.len() {\n            // Argument for safety is in the definition of next_si.\n            prev_si = unsafe { self.next_si(next_si, text, at) };\n            at += 1;\n            if prev_si > STATE_MAX || at + 2 >= text.len() {\n                mem::swap(&mut prev_si, &mut next_si);\n                break;\n            }\n            next_si = unsafe { self.next_si(prev_si, text, at) };\n            at += 1;\n            if next_si > STATE_MAX {\n                break;\n            }\n            prev_si = unsafe { self.next_si(next_si, text, at) };\n            at += 1;\n            if prev_si > STATE_MAX {\n                mem::swap(&mut prev_si, &mut next_si);\n                break;\n            }\n            next_si = unsafe { self.next_si(prev_si, text, at) };\n            at += 1;\n        }\n        if next_si & STATE_MATCH > 0 {\n            // A match state is outside of the common case because it needs\n            // special case analysis. In particular, we need to record the\n            // last position as having matched and possibly quit the DFA if\n            // we don't need to keep matching.\n            next_si &= !STATE_MATCH;\n            result = Result::Match(at - 1);\n            if self.quit_after_match {\n                return result;\n            }\n            self.last_match_si = next_si;\n            prev_si = next_si;\n\n            // This permits short-circuiting when matching a regex set.\n            // In particular, if this DFA state contains only match states,\n            // then it's impossible to extend the set of matches since\n            // match states are final. Therefore, we can quit.\n            if self.prog.matches.len() > 1 {\n                let state = self.state(next_si);\n                let just_matches = state.inst_ptrs()\n                     .all(|ip| self.prog[ip].is_match());\n                if just_matches {\n                    return result;\n                }\n            }\n\n            // Another inner loop! If the DFA stays in this particular\n            // match state, then we can rip through all of the input\n            // very quickly, and only recording the match location once\n            // we've left this particular state.\n            let cur = at;\n            while (next_si & !STATE_MATCH) == prev_si\n                && at + 2 < text.len() {\n                // Argument for safety is in the definition of next_si.\n                next_si = unsafe {\n                    self.next_si(next_si & !STATE_MATCH, text, at)\n                };\n                at += 1;\n            }\n            if at > cur {\n                result = Result::Match(at - 2);\n            }\n        } else if next_si & STATE_START > 0 {\n            // A start state isn't in the common case because we may\n            // what to do quick prefix scanning. If the program doesn't\n            // have a detected prefix, then start states are actually\n            // considered common and this case is never reached.\n            debug_assert!(self.has_prefix());\n            next_si &= !STATE_START;\n            prev_si = next_si;\n            at = match self.prefix_at(text, at) {\n                None => return Result::NoMatch(text.len()),\n                Some(i) => i,\n            };\n        } else if next_si >= STATE_UNKNOWN {\n            if next_si == STATE_QUIT {\n                return Result::Quit;\n            }\n            // Finally, this corresponds to the case where the transition\n            // entered a state that can never lead to a match or a state\n            // that hasn't been computed yet. The latter being the \"slow\"\n            // path.\n            let byte = Byte::byte(text[at - 1]);\n            // We no longer care about the special bits in the state\n            // pointer.\n            prev_si &= STATE_MAX;\n            // Record where we are. This is used to track progress for\n            // determining whether we should quit if we've flushed the\n            // cache too much.\n            self.at = at;\n            next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return result.set_non_match(at),\n                Some(si) => si,\n            };\n            debug_assert!(next_si != STATE_UNKNOWN);\n            if next_si & STATE_MATCH > 0 {\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at - 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n            }\n            prev_si = next_si;\n        } else {\n            prev_si = next_si;\n        }\n    }\n\n    // Run the DFA once more on the special EOF senitnel value.\n    // We don't care about the special bits in the state pointer any more,\n    // so get rid of them.\n    prev_si &= STATE_MAX;\n    prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n        None => return Result::Quit,\n        Some(STATE_DEAD) => return result.set_non_match(text.len()),\n        Some(si) => si & !STATE_START,\n    };\n    debug_assert!(prev_si != STATE_UNKNOWN);\n    if prev_si & STATE_MATCH > 0 {\n        prev_si &= !STATE_MATCH;\n        self.last_match_si = prev_si;\n        result = Result::Match(text.len());\n    }\n    result\n}\n",
  "depend_pt": ""
}