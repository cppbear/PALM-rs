{
  "name": "regex_syntax::hir::interval::hir::interval::IntervalSet<I>::negate",
  "name_with_impl": "regex_syntax::hir::interval::{impl#0}::negate",
  "mod_info": {
    "name": "hir::interval",
    "loc": "regex-syntax/src/hir/mod.rs:26:1:26:14"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/interval.rs:241:5:270:6",
  "fn_tests": [
    {
      "chain_id": 0,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[derive(Debug, Clone)]",
            "struct Bound {",
            "    value: i32,",
            "}",
            "",
            "impl Bound {",
            "    fn min_value() -> Self {",
            "        Bound { value: i32::min_value() }",
            "    }",
            "",
            "    fn max_value() -> Self {",
            "        Bound { value: i32::max_value() }",
            "    }",
            "",
            "    fn increment(&self) -> Self {",
            "        Bound { value: self.value + 1 }",
            "    }",
            "",
            "    fn decrement(&self) -> Self {",
            "        Bound { value: self.value - 1 }",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone)]",
            "struct Range {",
            "    lower: Bound,",
            "    upper: Bound,",
            "}",
            "",
            "impl Range {",
            "    fn create(lower: Bound, upper: Bound) -> Self {",
            "        Range { lower, upper }",
            "    }",
            "",
            "    fn lower(&self) -> &Bound {",
            "        &self.lower",
            "    }",
            "",
            "    fn upper(&self) -> &Bound {",
            "        &self.upper",
            "    }",
            "}",
            "",
            "#[derive(Debug, Default)]",
            "struct IntervalSet {",
            "    ranges: Vec<Range>,",
            "}",
            "",
            "impl IntervalSet {",
            "    fn negate(&mut self) {",
            "        if self.ranges.is_empty() {",
            "            let (min, max) = (Bound::min_value(), Bound::max_value());",
            "            self.ranges.push(Range::create(min, max));",
            "            return;",
            "        }",
            "",
            "        let drain_end = self.ranges.len();",
            "",
            "        if self.ranges[0].lower().value > Bound::min_value().value {",
            "            let upper = self.ranges[0].lower().decrement();",
            "            self.ranges.push(Range::create(Bound::min_value(), upper));",
            "        }",
            "        for i in 1..drain_end {",
            "            let lower = self.ranges[i - 1].upper().increment();",
            "            let upper = self.ranges[i].lower().decrement();",
            "            self.ranges.push(Range::create(lower, upper));",
            "        }",
            "        if self.ranges[drain_end - 1].upper().value < Bound::max_value().value {",
            "            let lower = self.ranges[drain_end - 1].upper().increment();",
            "            self.ranges.push(Range::create(lower, Bound::max_value()));",
            "        }",
            "        self.ranges.drain(..drain_end);",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut interval_set = IntervalSet::default();",
                  "    interval_set.negate();",
                  "    assert_eq!(interval_set.ranges.len(), 1);",
                  "    assert_eq!(interval_set.ranges[0].lower.value, i32::MIN);",
                  "    assert_eq!(interval_set.ranges[0].upper.value, i32::MAX);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut interval_set = IntervalSet {",
                  "        ranges: vec![Range::create(Bound { value: 1 }, Bound { value: 3 })],",
                  "    };",
                  "    interval_set.negate();",
                  "    assert_eq!(interval_set.ranges.len(), 2);",
                  "    assert_eq!(interval_set.ranges[0].lower.value, i32::MIN);",
                  "    assert_eq!(interval_set.ranges[0].upper.value, 0);",
                  "    assert_eq!(interval_set.ranges[1].lower.value, 4);",
                  "    assert_eq!(interval_set.ranges[1].upper.value, i32::MAX);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut interval_set = IntervalSet {",
                  "        ranges: vec![",
                  "            Range::create(Bound { value: 1 }, Bound { value: 2 }),",
                  "            Range::create(Bound { value: 4 }, Bound { value: 5 }),",
                  "        ],",
                  "    };",
                  "    interval_set.negate();",
                  "    assert_eq!(interval_set.ranges.len(), 3);",
                  "    assert_eq!(interval_set.ranges[0].lower.value, i32::MIN);",
                  "    assert_eq!(interval_set.ranges[0].upper.value, 0);",
                  "    assert_eq!(interval_set.ranges[1].lower.value, 3);",
                  "    assert_eq!(interval_set.ranges[1].upper.value, 3);",
                  "    assert_eq!(interval_set.ranges[2].lower.value, 6);",
                  "    assert_eq!(interval_set.ranges[2].upper.value, i32::MAX);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}