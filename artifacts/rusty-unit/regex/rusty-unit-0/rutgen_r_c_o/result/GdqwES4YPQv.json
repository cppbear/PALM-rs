{
    "function_name": "regex::literal::literal::SingleByteSet::approximate_size",
    "tests": 12,
    "tests_lines": [
        8,
        10,
        12,
        15,
        18,
        9,
        11,
        13,
        15,
        11,
        11,
        11
    ],
    "oracles": 6,
    "oracles_compiled": 6,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 12,
    "tests_compiled_rate": 100.0,
    "oracles_run": 6,
    "oracles_passed": 5,
    "oracles_passed_rate": 83.33333333333334,
    "tests_run": 12,
    "tests_passed": 11,
    "tests_passed_rate": 91.66666666666666,
    "lines": 4,
    "lines_covered": 4,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        403,
        404,
        405,
        406
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let single_byte_set = SingleByteSet::new();",
                "    let _ = single_byte_set.approximate_size();",
                "    let single_byte_set = SingleByteSet::new();",
                "    let expected_size = (single_byte_set.dense.len() * mem::size_of::<u8>()) + (single_byte_set.sparse.len() * mem::size_of::<bool>());",
                "    let actual_size = single_byte_set.approximate_size();",
                "    assert_eq!(actual_size, expected_size);",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    assert_eq!(size, (10 * mem::size_of::<u8>()) + (5 * mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    single_byte_set.sparse = vec![false; 0]; // 0 booleans",
                "    let size_zero_sparse = single_byte_set.approximate_size();",
                "    assert_eq!(size_zero_sparse, (10 * mem::size_of::<u8>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    single_byte_set.sparse = vec![false; 0]; // 0 booleans",
                "    let size_zero_sparse = single_byte_set.approximate_size();",
                "    single_byte_set.dense = vec![0; 0]; // 0 bytes",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size_zero_dense = single_byte_set.approximate_size();",
                "    assert_eq!(size_zero_dense, (0 * mem::size_of::<u8>()) + (5 * mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    single_byte_set.sparse = vec![false; 0]; // 0 booleans",
                "    let size_zero_sparse = single_byte_set.approximate_size();",
                "    single_byte_set.dense = vec![0; 0]; // 0 bytes",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size_zero_dense = single_byte_set.approximate_size();",
                "    single_byte_set.dense = vec![0; 12]; // 12 bytes",
                "    single_byte_set.sparse = vec![false; 8]; // 8 booleans",
                "    let size_new_values = single_byte_set.approximate_size();",
                "    assert_eq!(size_new_values, (12 * mem::size_of::<u8>()) + (8 * mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    assert_eq!(single_byte_set.approximate_size(), (10 * mem::size_of::<u8>()) + (5 * mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    single_byte_set.dense = vec![];",
                "    single_byte_set.sparse = vec![true; 3];",
                "    assert_eq!(single_byte_set.approximate_size(), (0 * mem::size_of::<u8>()) + (3 * mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    single_byte_set.dense = vec![];",
                "    single_byte_set.sparse = vec![true; 3];",
                "    single_byte_set.dense = vec![1u8; 7];",
                "    single_byte_set.sparse = vec![];",
                "    assert_eq!(single_byte_set.approximate_size(), (7 * mem::size_of::<u8>()) + (0 * mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    single_byte_set.dense = vec![];",
                "    single_byte_set.sparse = vec![true; 3];",
                "    single_byte_set.dense = vec![1u8; 7];",
                "    single_byte_set.sparse = vec![];",
                "    single_byte_set.dense = vec![1u8; 0];",
                "    single_byte_set.sparse = vec![false; 0];",
                "    assert_eq!(single_byte_set.approximate_size(), (0 * mem::size_of::<u8>()) + (0 * mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![true; 5];",
                "    let expected_size = (single_byte_set.dense.len() * mem::size_of::<u8>()) + (single_byte_set.sparse.len() * mem::size_of::<bool>());",
                "    assert_eq!(single_byte_set.approximate_size(), expected_size);",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 100]; // 100 bytes",
                "    single_byte_set.sparse = vec![true; 50]; // 50 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 100];",
                "    single_byte_set.sparse = vec![true; 50];",
                "    let result = single_byte_set.approximate_size();",
                "    assert_eq!(result, (100 * std::mem::size_of::<u8>()) + (50 * std::mem::size_of::<bool>()));",
                "}"
            ],
            [
                403,
                404,
                405,
                406
            ]
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; usize::MAX / mem::size_of::<u8>()]; // maximum for dense",
                "    single_byte_set.sparse = vec![true; usize::MAX / mem::size_of::<bool>()]; // maximum for sparse",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; usize::MAX / mem::size_of::<u8>()];",
                "    single_byte_set.sparse = vec![true; usize::MAX / mem::size_of::<bool>()];",
                "    let size = single_byte_set.approximate_size();",
                "    assert_eq!(size, (single_byte_set.dense.len() * mem::size_of::<u8>()) + (single_byte_set.sparse.len() * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let single_byte_set = SingleByteSet::new();",
                "    let _ = single_byte_set.approximate_size();",
                "    let single_byte_set = SingleByteSet::new();",
                "    let expected_size = (single_byte_set.dense.len() * mem::size_of::<u8>()) + (single_byte_set.sparse.len() * mem::size_of::<bool>());",
                "    let actual_size = single_byte_set.approximate_size();",
                "    assert_eq!(actual_size, expected_size);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    assert_eq!(size, (10 * mem::size_of::<u8>()) + (5 * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    single_byte_set.sparse = vec![false; 0]; // 0 booleans",
                "    let size_zero_sparse = single_byte_set.approximate_size();",
                "    assert_eq!(size_zero_sparse, (10 * mem::size_of::<u8>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    single_byte_set.sparse = vec![false; 0]; // 0 booleans",
                "    let size_zero_sparse = single_byte_set.approximate_size();",
                "    single_byte_set.dense = vec![0; 0]; // 0 bytes",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size_zero_dense = single_byte_set.approximate_size();",
                "    assert_eq!(size_zero_dense, (0 * mem::size_of::<u8>()) + (5 * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size = single_byte_set.approximate_size();",
                "    single_byte_set.sparse = vec![false; 0]; // 0 booleans",
                "    let size_zero_sparse = single_byte_set.approximate_size();",
                "    single_byte_set.dense = vec![0; 0]; // 0 bytes",
                "    single_byte_set.sparse = vec![false; 5]; // 5 booleans",
                "    let size_zero_dense = single_byte_set.approximate_size();",
                "    single_byte_set.dense = vec![0; 12]; // 12 bytes",
                "    single_byte_set.sparse = vec![false; 8]; // 8 booleans",
                "    let size_new_values = single_byte_set.approximate_size();",
                "    assert_eq!(size_new_values, (12 * mem::size_of::<u8>()) + (8 * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    assert_eq!(single_byte_set.approximate_size(), (10 * mem::size_of::<u8>()) + (5 * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    single_byte_set.dense = vec![];",
                "    single_byte_set.sparse = vec![true; 3];",
                "    assert_eq!(single_byte_set.approximate_size(), (0 * mem::size_of::<u8>()) + (3 * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    single_byte_set.dense = vec![];",
                "    single_byte_set.sparse = vec![true; 3];",
                "    single_byte_set.dense = vec![1u8; 7];",
                "    single_byte_set.sparse = vec![];",
                "    assert_eq!(single_byte_set.approximate_size(), (7 * mem::size_of::<u8>()) + (0 * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0u8; 10]; // 10 u8s",
                "    single_byte_set.sparse = vec![true; 5];",
                "    single_byte_set.dense = vec![];",
                "    single_byte_set.sparse = vec![true; 3];",
                "    single_byte_set.dense = vec![1u8; 7];",
                "    single_byte_set.sparse = vec![];",
                "    single_byte_set.dense = vec![1u8; 0];",
                "    single_byte_set.sparse = vec![false; 0];",
                "    assert_eq!(single_byte_set.approximate_size(), (0 * mem::size_of::<u8>()) + (0 * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10]; // 10 bytes",
                "    single_byte_set.sparse = vec![true; 5]; // 5 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 10];",
                "    single_byte_set.sparse = vec![true; 5];",
                "    let expected_size = (single_byte_set.dense.len() * mem::size_of::<u8>()) + (single_byte_set.sparse.len() * mem::size_of::<bool>());",
                "    assert_eq!(single_byte_set.approximate_size(), expected_size);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 100]; // 100 bytes",
                "    single_byte_set.sparse = vec![true; 50]; // 50 bools",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; 100];",
                "    single_byte_set.sparse = vec![true; 50];",
                "    let result = single_byte_set.approximate_size();",
                "    assert_eq!(result, (100 * std::mem::size_of::<u8>()) + (50 * std::mem::size_of::<bool>()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; usize::MAX / mem::size_of::<u8>()]; // maximum for dense",
                "    single_byte_set.sparse = vec![true; usize::MAX / mem::size_of::<bool>()]; // maximum for sparse",
                "    let _ = single_byte_set.approximate_size();",
                "    let mut single_byte_set = SingleByteSet::new();",
                "    single_byte_set.dense = vec![0; usize::MAX / mem::size_of::<u8>()];",
                "    single_byte_set.sparse = vec![true; usize::MAX / mem::size_of::<bool>()];",
                "    let size = single_byte_set.approximate_size();",
                "    assert_eq!(size, (single_byte_set.dense.len() * mem::size_of::<u8>()) + (single_byte_set.sparse.len() * mem::size_of::<bool>()));",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/src/literal/mod.rs"
}