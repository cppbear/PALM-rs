{
    "function_name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_escape",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/ast/parse.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 921,
    "tests_lines": [
        37,
        38,
        36,
        36,
        36,
        36,
        36,
        36,
        36,
        36,
        37,
        40,
        40,
        40,
        40,
        37,
        37,
        37,
        38,
        36,
        36,
        36,
        36,
        37,
        38,
        37,
        38,
        38,
        41,
        42,
        49,
        50,
        53,
        54,
        54,
        57,
        58,
        61,
        62,
        65,
        66,
        18,
        27,
        28,
        28,
        17,
        17,
        17,
        17,
        21,
        22,
        22,
        19,
        19,
        19,
        27,
        28,
        28,
        28,
        28,
        21,
        21,
        27,
        27,
        27,
        27,
        38,
        39,
        23,
        38,
        38,
        26,
        26,
        26,
        26,
        26,
        43,
        25,
        11,
        11,
        12,
        13,
        15,
        16,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        17,
        12,
        12,
        11,
        10,
        10,
        10,
        11,
        12,
        12,
        12,
        12,
        13,
        12,
        13,
        11,
        11,
        11,
        16,
        12,
        15,
        15,
        15,
        15,
        12,
        14,
        15,
        16,
        17,
        17,
        20,
        9,
        10,
        11,
        12,
        12,
        17,
        12,
        12,
        10,
        10,
        11,
        12,
        12,
        14,
        14,
        17,
        17,
        17,
        12,
        13,
        17,
        15,
        18,
        18,
        15,
        16,
        20,
        21,
        21,
        22,
        22,
        22,
        22,
        34,
        34,
        21,
        26,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        19,
        19,
        33,
        34,
        34,
        21,
        21,
        21,
        21,
        21,
        21,
        21,
        34,
        34,
        22,
        22,
        22,
        33,
        33,
        22,
        22,
        34,
        35,
        40,
        40,
        42,
        42,
        44,
        44,
        46,
        47,
        52,
        53,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        34,
        35,
        35,
        35,
        23,
        23,
        23,
        21,
        21,
        21,
        20,
        20,
        20,
        20,
        20,
        34,
        34,
        36,
        36,
        38,
        40,
        42,
        44,
        46,
        48,
        50,
        52,
        54,
        56,
        58,
        60,
        62,
        64,
        66,
        68,
        70,
        72,
        74,
        76,
        78,
        80,
        82,
        12,
        12,
        15,
        18,
        12,
        13,
        12,
        13,
        12,
        12,
        12,
        13,
        14,
        15,
        15,
        12,
        13,
        14,
        14,
        14,
        14,
        15,
        17,
        38,
        39,
        38,
        39,
        40,
        40,
        40,
        42,
        43,
        44,
        44,
        44,
        23,
        37,
        38,
        41,
        41,
        38,
        40,
        40,
        38,
        41,
        28,
        23,
        37,
        40,
        48,
        50,
        52,
        54,
        56,
        58,
        60,
        62,
        64,
        64,
        38,
        39,
        49,
        51,
        51,
        50,
        51,
        29,
        29,
        30,
        31,
        34,
        34,
        35,
        36,
        37,
        38,
        39,
        30,
        30,
        30,
        30,
        30,
        49,
        54,
        59,
        64,
        69,
        74,
        78,
        82,
        50,
        51,
        51,
        51,
        51,
        51,
        51,
        28,
        37,
        23,
        23,
        24,
        27,
        27,
        43,
        38,
        40,
        40,
        38,
        41,
        41,
        37,
        17,
        18,
        22,
        23,
        23,
        21,
        22,
        22,
        22,
        22,
        22,
        22,
        21,
        24,
        24,
        27,
        27,
        27,
        14,
        14,
        14,
        14,
        15,
        16,
        16,
        16,
        16,
        14,
        14,
        14,
        15,
        16,
        16,
        16,
        16,
        16,
        22,
        23,
        23,
        22,
        23,
        23,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        22,
        23,
        23,
        23,
        23,
        21,
        21,
        21,
        21,
        22,
        23,
        8,
        9,
        7,
        8,
        9,
        9,
        7,
        8,
        13,
        13,
        8,
        9,
        9,
        9,
        9,
        10,
        11,
        11,
        11,
        7,
        8,
        8,
        8,
        9,
        9,
        9,
        7,
        8,
        8,
        8,
        7,
        8,
        35,
        36,
        36,
        36,
        36,
        36,
        21,
        22,
        22,
        22,
        35,
        38,
        38,
        33,
        34,
        34,
        34,
        34,
        34,
        35,
        35,
        35,
        35,
        35,
        35,
        35,
        35,
        37,
        37,
        41,
        20,
        21,
        22,
        22,
        22,
        22,
        22,
        35,
        35,
        35,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        34,
        36,
        36,
        40,
        40,
        40,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        34,
        36,
        36,
        36,
        36,
        36,
        36,
        36,
        37,
        38,
        38,
        38,
        38,
        36,
        36,
        36,
        37,
        38,
        38,
        38,
        38,
        38,
        36,
        37,
        37,
        37,
        37,
        37,
        37,
        36,
        37,
        41,
        41,
        36,
        36,
        36,
        37,
        40,
        40,
        22,
        22,
        22,
        22,
        23,
        24,
        24,
        24,
        24,
        37,
        41,
        44,
        44,
        44,
        30,
        31,
        31,
        31,
        31,
        31,
        31,
        31,
        37,
        40,
        40,
        42,
        42,
        61,
        80,
        99,
        118,
        137,
        156,
        43,
        44,
        44,
        45,
        45,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        26,
        29,
        29,
        43,
        44,
        44,
        52,
        53,
        53,
        61,
        62,
        62,
        70,
        71,
        71,
        79,
        80,
        80,
        88,
        89,
        97,
        98,
        106,
        107,
        107,
        115,
        116,
        116,
        124,
        125,
        133,
        134,
        142,
        143,
        143,
        151,
        152,
        152,
        160,
        161,
        169,
        170,
        178,
        179,
        41,
        42,
        42,
        42,
        13,
        13,
        13,
        15,
        13,
        13,
        13,
        14,
        16,
        16,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        10,
        10,
        10,
        10,
        10,
        10,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        12,
        12,
        12,
        13,
        14,
        15,
        15,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        14,
        15,
        10,
        10,
        10,
        10,
        10,
        10,
        38,
        38,
        39,
        40,
        40,
        23,
        23,
        23,
        23,
        39,
        40,
        39,
        42,
        42,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        24,
        27,
        27,
        27,
        24,
        24,
        39,
        39,
        39,
        39,
        39,
        39,
        39,
        44,
        47,
        47,
        50,
        44,
        44,
        44,
        44,
        44,
        44,
        45,
        45,
        44,
        44,
        44,
        44,
        44,
        15,
        15,
        15,
        15,
        23,
        23,
        22,
        22,
        22,
        22,
        22,
        28,
        28,
        28,
        28,
        28,
        28,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        28,
        32,
        33,
        33,
        33,
        26,
        27,
        25,
        26,
        26,
        26,
        9,
        12,
        12,
        9,
        9,
        9,
        9,
        8,
        9,
        9,
        9,
        9,
        9,
        9,
        8,
        8,
        8,
        8,
        9,
        10,
        11,
        11,
        9,
        12,
        9,
        9,
        9,
        9
    ],
    "oracles": 196,
    "oracles_compiled": 12,
    "oracles_compiled_rate": 6.122448979591836,
    "tests_compiled": 28,
    "tests_compiled_rate": 3.040173724212812,
    "oracles_run": 12,
    "oracles_passed": 11,
    "oracles_passed_rate": 91.66666666666666,
    "tests_run": 28,
    "tests_passed": 22,
    "tests_passed_rate": 78.57142857142857,
    "lines": 80,
    "lines_covered": 31,
    "lines_coveraged_rate": 38.75,
    "branches": 10,
    "branches_covered": 6,
    "branches_coverage_rate": 60.0,
    "codes_lines": [
        1433,
        1434,
        1435,
        1436,
        1437,
        1438,
        1439,
        1440,
        1441,
        1442,
        1444,
        1445,
        1446,
        1447,
        1448,
        1449,
        1450,
        1451,
        1452,
        1453,
        1454,
        1456,
        1457,
        1458,
        1459,
        1460,
        1463,
        1464,
        1465,
        1468,
        1469,
        1470,
        1473,
        1474,
        1475,
        1477,
        1478,
        1479,
        1480,
        1481,
        1482,
        1483,
        1484,
        1485,
        1486,
        1487,
        1488,
        1489,
        1490,
        1491,
        1492,
        1493,
        1494,
        1495,
        1496,
        1497,
        1498,
        1499,
        1500,
        1501,
        1502,
        1503,
        1505,
        1506,
        1507,
        1508,
        1509,
        1510,
        1511,
        1512,
        1513,
        1514,
        1515,
        1516,
        1517,
        1518,
        1519,
        1520,
        1521,
        1523
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let result = parser_i.parse_escape();",
                "    let primitive = result.unwrap();",
                "    assert!(matches!(primitive, Primitive::Literal(_)));",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parse_escape().is_ok());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert_eq!(parser_i.parser().capture_index.get(), 0);",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert_eq!(parser_i.parser().octal, true);",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parser().comments.borrow().is_empty());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parser().stack_group.borrow().is_empty());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parser().stack_class.borrow().is_empty());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\2\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\2\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\3\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\3\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let result = parser_i.parse_escape();",
                "    let primitive = result.unwrap();",
                "    assert!(matches!(primitive, Primitive::Literal(_)));",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert!(matches!(parser_i.parse_escape(), Ok(Primitive::Literal(_))));",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert_eq!(parser_i.parser().pos.get().offset, 2);",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert_eq!(parser_i.parser().ignore_whitespace.get(), false);",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert!(parser_i.parser().octal);",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let result = parser_i.parse_escape();",
                "    let primitive = result.unwrap();",
                "    assert!(matches!(primitive, Primitive::Literal(_)));",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let result = parser_i.parse_escape();",
                "    if let Ok(Primitive::Literal(lit)) = result {",
                "    }",
                "    let parser_i_invalid = ParserI { parser: &parser, pattern: \"\\\\8\" };",
                "    let result_invalid = parser_i_invalid.parse_escape();",
                "    assert!(result_invalid.is_err());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let result = parser_i.parse_escape();",
                "    if let Ok(Primitive::Literal(lit)) = result {",
                "    }",
                "    let parser_i_invalid = ParserI { parser: &parser, pattern: \"\\\\8\" };",
                "    let result_invalid = parser_i_invalid.parse_escape();",
                "    if let Err(ref e) = result_invalid {",
                "    }",
                "    let parser_i_no_octal = Parser {",
                "    octal: false,",
                "    ..parser",
                "    };",
                "    let parser_i_no_octal = ParserI { parser: &parser_i_no_octal, pattern: \"\\\\7\" };",
                "    let result_no_octal = parser_i_no_octal.parse_escape();",
                "    assert!(result_no_octal.is_err());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1445,
                1446,
                1451,
                1452,
                1453,
                1454,
                1523
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\8\"; // starts with escape character followed by an invalid octal",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "    pos: Cell::new(start_pos),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    let result = parser_instance.parse_escape();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1444,
                1445,
                1456,
                1477,
                1478,
                1479,
                1480,
                1481,
                1482,
                1483,
                1489,
                1490,
                1521,
                1523
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\9\"; // starts with escape character followed by an invalid octal",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(start, Position { offset: 2, line: 1, column: 3 });",
                "    assert_eq!(parser_instance.parse_escape(), Err(parser_instance.error(span, ast::ErrorKind::EscapeUnrecognized)));",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1444,
                1445,
                1456,
                1477,
                1478,
                1479,
                1480,
                1481,
                1482,
                1483,
                1489,
                1490,
                1521,
                1523
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \"; // starts with escape character followed by a space",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \";",
                "    let parser = Parser {",
                "    pos: Cell::new(start_pos),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    let result = parser_instance.parse_escape();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1477,
                1478,
                1479,
                1480,
                1481,
                1482,
                1483,
                1489,
                1490,
                1495,
                1502,
                1521,
                1523
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \"; // starts with escape character followed by a space",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \";",
                "    let parser = Parser {",
                "    pos: Cell::new(start_pos),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    let result = parser_instance.parse_escape();",
                "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeUnrecognized);",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1477,
                1478,
                1479,
                1480,
                1481,
                1482,
                1483,
                1489,
                1490,
                1495,
                1502,
                1521,
                1523
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: pattern,",
                "    };",
                "",
                "    let _ = parser_instance.parse_escape();",
                "    let start = parser_instance.pos();",
                "    let end = parser_instance.pos();",
                "    assert_eq!(parser_instance.char(), '\\\\');",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1444,
                1445,
                1456,
                1457,
                1458,
                1459,
                1460,
                1523
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: pattern,",
                "    };",
                "",
                "    let _ = parser_instance.parse_escape();",
                "    let start = parser_instance.pos();",
                "    let end = parser_instance.pos();",
                "    assert_eq!(parser_instance.pattern, \"\\\\8\");",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1444,
                1445,
                1456,
                1457,
                1458,
                1459,
                1460,
                1523
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: pattern,",
                "    };",
                "",
                "    let _ = parser_instance.parse_escape();",
                "    let start = parser_instance.pos();",
                "    let end = parser_instance.pos();",
                "    assert!(parser_instance.bump());",
                "}"
            ],
            [
                1433,
                1434,
                1435,
                1436,
                1441,
                1442,
                1444,
                1445,
                1456,
                1457,
                1458,
                1459,
                1460,
                1523
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1436,
            "start_column": 12,
            "end_line": 1436,
            "end_column": 24,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1446,
            "start_column": 20,
            "end_line": 1446,
            "end_column": 40,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1456,
            "start_column": 26,
            "end_line": 1456,
            "end_column": 46,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 1483,
            "start_column": 12,
            "end_line": 1483,
            "end_column": 32,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1502,
            "start_column": 20,
            "end_line": 1502,
            "end_column": 44,
            "positive": false,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\0\" };",
                "    let result = parser_i.parse_escape();",
                "    let primitive = result.unwrap();",
                "    assert!(matches!(primitive, Primitive::Literal(_)));",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parse_escape().is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert_eq!(parser_i.parser().capture_index.get(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert_eq!(parser_i.parser().octal, true);",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parser().comments.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parser().stack_group.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\1\" };",
                "    assert!(parser_i.parser().stack_class.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\2\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\2\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\3\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\3\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\4\" };",
                "    let result = parser_i.parse_escape();",
                "    let primitive = result.unwrap();",
                "    assert!(matches!(primitive, Primitive::Literal(_)));",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert!(matches!(parser_i.parse_escape(), Ok(Primitive::Literal(_))));",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert_eq!(parser_i.parser().pos.get().offset, 2);",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert_eq!(parser_i.parser().ignore_whitespace.get(), false);",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\5\" };",
                "    assert!(parser_i.parser().octal);",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\6\" };",
                "    let result = parser_i.parse_escape();",
                "    let primitive = result.unwrap();",
                "    assert!(matches!(primitive, Primitive::Literal(_)));",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let result = parser_i.parse_escape();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let result = parser_i.parse_escape();",
                "    if let Ok(Primitive::Literal(lit)) = result {",
                "    }",
                "    let parser_i_invalid = ParserI { parser: &parser, pattern: \"\\\\8\" };",
                "    let result_invalid = parser_i_invalid.parse_escape();",
                "    assert!(result_invalid.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let _ = parser_i.parse_escape();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(position, position);",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_i = ParserI { parser: &parser, pattern: \"\\\\7\" };",
                "    let result = parser_i.parse_escape();",
                "    if let Ok(Primitive::Literal(lit)) = result {",
                "    }",
                "    let parser_i_invalid = ParserI { parser: &parser, pattern: \"\\\\8\" };",
                "    let result_invalid = parser_i_invalid.parse_escape();",
                "    if let Err(ref e) = result_invalid {",
                "    }",
                "    let parser_i_no_octal = Parser {",
                "    octal: false,",
                "    ..parser",
                "    };",
                "    let parser_i_no_octal = ParserI { parser: &parser_i_no_octal, pattern: \"\\\\7\" };",
                "    let result_no_octal = parser_i_no_octal.parse_escape();",
                "    assert!(result_no_octal.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\8\"; // starts with escape character followed by an invalid octal",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "    pos: Cell::new(start_pos),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    let result = parser_instance.parse_escape();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\9\"; // starts with escape character followed by an invalid octal",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(start, Position { offset: 2, line: 1, column: 3 });",
                "    assert_eq!(parser_instance.parse_escape(), Err(parser_instance.error(span, ast::ErrorKind::EscapeUnrecognized)));",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \"; // starts with escape character followed by a space",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \";",
                "    let parser = Parser {",
                "    pos: Cell::new(start_pos),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    let result = parser_instance.parse_escape();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \"; // starts with escape character followed by a space",
                "    let parser = Parser {",
                "        pos: Cell::new(start_pos),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    ",
                "    let _ = parser_instance.parse_escape();",
                "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
                "    let pattern = \"\\\\ \";",
                "    let parser = Parser {",
                "    pos: Cell::new(start_pos),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::new()),",
                "    };",
                "    let parser_instance = ParserI { parser: &parser, pattern };",
                "    let result = parser_instance.parse_escape();",
                "    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeUnrecognized);",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: pattern,",
                "    };",
                "",
                "    let _ = parser_instance.parse_escape();",
                "    let start = parser_instance.pos();",
                "    let end = parser_instance.pos();",
                "    assert_eq!(parser_instance.char(), '\\\\');",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: pattern,",
                "    };",
                "",
                "    let _ = parser_instance.parse_escape();",
                "    let start = parser_instance.pos();",
                "    let end = parser_instance.pos();",
                "    assert_eq!(parser_instance.pattern, \"\\\\8\");",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let pattern = \"\\\\8\";",
                "    let parser = Parser {",
                "        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: false,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::new()),",
                "    };",
                "",
                "    let parser_instance = ParserI {",
                "        parser: &parser,",
                "        pattern: pattern,",
                "    };",
                "",
                "    let _ = parser_instance.parse_escape();",
                "    let start = parser_instance.pos();",
                "    let end = parser_instance.pos();",
                "    assert!(parser_instance.bump());",
                "}"
            ],
            [
                {
                    "start_line": 1436,
                    "start_column": 12,
                    "end_line": 1436,
                    "end_column": 24,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1446,
                    "start_column": 20,
                    "end_line": 1446,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1456,
                    "start_column": 26,
                    "end_line": 1456,
                    "end_column": 46,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1483,
                    "start_column": 12,
                    "end_line": 1483,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1502,
                    "start_column": 20,
                    "end_line": 1502,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}