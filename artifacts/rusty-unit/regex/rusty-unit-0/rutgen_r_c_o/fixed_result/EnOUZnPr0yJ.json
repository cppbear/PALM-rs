{
    "function_name": "regex::compile::compile::Compiler::c_class",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/src/compile.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex",
    "tests": 84,
    "tests_lines": [
        8,
        9,
        9,
        9,
        9,
        9,
        16,
        16,
        16,
        17,
        17,
        17,
        9,
        10,
        10,
        11,
        11,
        11,
        11,
        8,
        8,
        8,
        8,
        8,
        8,
        12,
        13,
        13,
        11,
        11,
        11,
        11,
        14,
        15,
        15,
        12,
        13,
        13,
        13,
        13,
        11,
        11,
        11,
        11,
        11,
        12,
        13,
        13,
        11,
        11,
        11,
        12,
        13,
        13,
        14,
        14,
        14,
        14,
        14,
        15,
        16,
        16,
        17,
        18,
        18,
        11,
        12,
        13,
        13,
        13,
        9,
        10,
        10,
        9,
        10,
        10,
        7,
        7,
        7,
        8,
        8,
        11,
        12,
        12
    ],
    "oracles": 18,
    "oracles_compiled": 16,
    "oracles_compiled_rate": 88.88888888888889,
    "tests_compiled": 54,
    "tests_compiled_rate": 64.28571428571429,
    "oracles_run": 16,
    "oracles_passed": 16,
    "oracles_passed_rate": 100.0,
    "tests_run": 54,
    "tests_passed": 51,
    "tests_passed_rate": 94.44444444444444,
    "lines": 14,
    "lines_covered": 14,
    "lines_coveraged_rate": 100.0,
    "branches": 6,
    "branches_covered": 6,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        420,
        421,
        422,
        423,
        424,
        425,
        426,
        428,
        429,
        430,
        431,
        433,
        435,
        437
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    assert!(!ranges.is_empty());",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    assert!(compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    assert_eq!(compiler.insts.len(), 0);  // Initial state before calling c_class",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    assert!(compiler.insts.len() > 0);  // Insts should have been added after c_class call",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    assert_eq!(compiler.compiled.matches.len(), 0);  // No match instructions expected yet",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    assert!(compiler.compiled.byte_classes.iter().any(|&b| b == 1)); // Checking if byte classes were affected",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert!(matches!(patch.hole, Hole::One(_)));",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(compiler.insts.len() > 0);",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert_eq!(compiler.compiled.is_bytes, true);",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "   let mut compiler = Compiler::new().bytes(true);",
                "   let ranges = (0..100).map(|c| hir::ClassUnicodeRange::new(char::from_u32(c).expect(\"valid char range\"), char::from_u32(c).expect(\"valid char range\"))).collect::<Vec<_>>();",
                "   compiler.c_class(&ranges).unwrap();",
                "   let mut compiler = Compiler::new().bytes(true);",
                "   let ranges = (0..100).map(|c| hir::ClassUnicodeRange::new(char::from_u32(c).expect(\"valid char range\"), char::from_u32(c).expect(\"valid char range\"))).collect::<Vec<_>>();",
                "    assert_eq!(compiler.num_exprs, 0);",
                "}"
            ],
            [
                420,
                421,
                422,
                423,
                424,
                425,
                426,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    assert!(_result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert!(!ranges.is_empty());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert_eq!(ranges.len(), 3);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert!(ranges[0].start() != ranges[0].end());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert!(!compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let expected_hole = compiler.push_hole(InstHole::Ranges { ranges: vec![('x', 'y'), ('y', 'y'), ('z', 'z')] });",
                "    let expected_entry = compiler.insts.len() - 1;",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let expected_hole = compiler.push_hole(InstHole::Ranges { ranges: vec![('x', 'y'), ('y', 'y'), ('z', 'z')] });",
                "    let expected_entry = compiler.insts.len() - 1;",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, expected_entry);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    assert!(_result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let patch = _result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let patch = _result.unwrap();",
                "    assert!(matches!(patch.hole, Hole::One(_)));",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges.len() == 2);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[0].start() == 'a');",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[0].end() == 'a');",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[1].start() == 'b');",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[1].end() == 'd');",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert!(patch.entry == compiler.insts.len() - 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    assert!(ranges.len() > 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    assert!(ranges.len() > 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(compiler.compiled.uses_bytes() == false);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(ranges.len() == 2);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(ranges[0].start() == char::from(0));",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(ranges[1].end() == char::from(3));",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(2)),",
                "        hir::ClassUnicodeRange::new(char::from(3), char::from(5)),",
                "        hir::ClassUnicodeRange::new(char::from(6), char::from(7)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(2)),",
                "    hir::ClassUnicodeRange::new(char::from(3), char::from(5)),",
                "    hir::ClassUnicodeRange::new(char::from(6), char::from(7)),",
                "    ];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    if let Ok(patch) = result {",
                "    }",
                "    assert_eq!(compiler.insts.len(), 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    if let Ok(patch) = result {",
                "    }",
                "    assert!(matches!(compiler.insts[0], MaybeInst::Uncompiled(InstHole::Ranges {..})));",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    if let Ok(patch) = result {",
                "    }",
                "    assert!(!compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                433,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    assert!(!ranges.is_empty());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    assert_eq!(compiler.compiled.uses_bytes(), false);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    assert_eq!(ranges.len(), 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false; // Ensure that uses_bytes() is false",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false; // Ensure that uses_bytes() is false",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                420,
                421,
                422,
                428,
                429,
                430,
                431,
                435,
                437
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 422,
            "start_column": 12,
            "end_line": 422,
            "end_column": 38,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 430,
            "start_column": 27,
            "end_line": 430,
            "end_column": 44,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 430,
            "start_column": 48,
            "end_line": 430,
            "end_column": 74,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    assert!(!ranges.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    assert!(compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    assert_eq!(compiler.insts.len(), 0);  // Initial state before calling c_class",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    assert!(compiler.insts.len() > 0);  // Insts should have been added after c_class call",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    assert_eq!(compiler.compiled.matches.len(), 0);  // No match instructions expected yet",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('a', 'b'),",
                "        hir::ClassUnicodeRange::new('d', 'e'),",
                "        hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new('a', 'b'),",
                "    hir::ClassUnicodeRange::new('d', 'e'),",
                "    hir::ClassUnicodeRange::new('g', 'z'),",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    assert!(compiler.compiled.byte_classes.iter().any(|&b| b == 1)); // Checking if byte classes were affected",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert!(matches!(patch.hole, Hole::One(_)));",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(compiler.insts.len() > 0);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')",
                "    ];",
                "    compiler.c_class(&ranges).unwrap();",
                "    let mut compiler = Compiler::new().bytes(true);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert_eq!(compiler.compiled.is_bytes, true);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut compiler = Compiler::new().bytes(true);",
                "   let ranges = (0..100).map(|c| hir::ClassUnicodeRange::new(char::from_u32(c).expect(\"valid char range\"), char::from_u32(c).expect(\"valid char range\"))).collect::<Vec<_>>();",
                "   compiler.c_class(&ranges).unwrap();",
                "   let mut compiler = Compiler::new().bytes(true);",
                "   let ranges = (0..100).map(|c| hir::ClassUnicodeRange::new(char::from_u32(c).expect(\"valid char range\"), char::from_u32(c).expect(\"valid char range\"))).collect::<Vec<_>>();",
                "    assert_eq!(compiler.num_exprs, 0);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    assert!(_result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert!(!ranges.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert_eq!(ranges.len(), 3);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert!(ranges[0].start() != ranges[0].end());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    assert!(!compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let expected_hole = compiler.push_hole(InstHole::Ranges { ranges: vec![('x', 'y'), ('y', 'y'), ('z', 'z')] });",
                "    let expected_entry = compiler.insts.len() - 1;",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('x', 'y'), hir::ClassUnicodeRange::new('y', 'y'), hir::ClassUnicodeRange::new('z', 'z')];",
                "    let expected_hole = compiler.push_hole(InstHole::Ranges { ranges: vec![('x', 'y'), ('y', 'y'), ('z', 'z')] });",
                "    let expected_entry = compiler.insts.len() - 1;",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, expected_entry);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    assert!(_result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let patch = _result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'b'), hir::ClassUnicodeRange::new('c', 'c')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let patch = _result.unwrap();",
                "    assert!(matches!(patch.hole, Hole::One(_)));",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges.len() == 2);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[0].start() == 'a');",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[0].end() == 'a');",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[1].start() == 'b');",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    assert!(ranges[1].end() == 'd');",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a'), hir::ClassUnicodeRange::new('b', 'd')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert!(patch.entry == compiler.insts.len() - 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    assert!(ranges.len() > 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    assert!(ranges.len() > 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('e', 'e'), hir::ClassUnicodeRange::new('f', 'g')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(compiler.compiled.uses_bytes() == false);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(ranges.len() == 2);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(ranges[0].start() == char::from(0));",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    assert!(ranges[1].end() == char::from(3));",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "        hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(1)),",
                "    hir::ClassUnicodeRange::new(char::from(2), char::from(3)),",
                "    ];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(2)),",
                "        hir::ClassUnicodeRange::new(char::from(3), char::from(5)),",
                "        hir::ClassUnicodeRange::new(char::from(6), char::from(7)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "    hir::ClassUnicodeRange::new(char::from(0), char::from(2)),",
                "    hir::ClassUnicodeRange::new(char::from(3), char::from(5)),",
                "    hir::ClassUnicodeRange::new(char::from(6), char::from(7)),",
                "    ];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    if let Ok(patch) = result {",
                "    }",
                "    assert_eq!(compiler.insts.len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    if let Ok(patch) = result {",
                "    }",
                "    assert!(matches!(compiler.insts[0], MaybeInst::Uncompiled(InstHole::Ranges {..})));",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![",
                "        hir::ClassUnicodeRange::new(char::from(0), char::from(3)),",
                "    ];",
                "    let _result = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new(char::from(0), char::from(3))];",
                "    let result = compiler.c_class(&ranges);",
                "    if let Ok(patch) = result {",
                "    }",
                "    assert!(!compiler.compiled.uses_bytes());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{0000}', '\\u{0000}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{10FFFF}', '\\u{10FFFF}')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    assert!(!ranges.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    assert_eq!(compiler.compiled.uses_bytes(), false);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let ranges = vec![hir::ClassUnicodeRange::new('\\u{7F}', '\\u{7F}')];",
                "    assert_eq!(ranges.len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false; // Ensure that uses_bytes() is false",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let result = compiler.c_class(&ranges);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false; // Ensure that uses_bytes() is false",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let _ = compiler.c_class(&ranges);",
                "    let mut compiler = Compiler::new();",
                "    compiler.compiled.is_bytes = false;",
                "    let ranges = vec![hir::ClassUnicodeRange::new('a', 'a')];",
                "    let result = compiler.c_class(&ranges);",
                "    let patch = result.unwrap();",
                "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
                "}"
            ],
            [
                {
                    "start_line": 422,
                    "start_column": 12,
                    "end_line": 422,
                    "end_column": 38,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 430,
                    "start_column": 27,
                    "end_line": 430,
                    "end_column": 44,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 430,
                    "start_column": 48,
                    "end_line": 430,
                    "end_column": 74,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ]
}