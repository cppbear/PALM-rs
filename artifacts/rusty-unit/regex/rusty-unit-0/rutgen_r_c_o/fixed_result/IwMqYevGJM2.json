{
    "function_name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_unicode_class",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/ast/parse.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 236,
    "tests_lines": [
        42,
        42,
        42,
        42,
        42,
        44,
        45,
        46,
        46,
        46,
        43,
        44,
        44,
        48,
        48,
        24,
        26,
        26,
        26,
        26,
        28,
        42,
        42,
        42,
        42,
        42,
        43,
        43,
        43,
        44,
        45,
        45,
        37,
        37,
        37,
        37,
        37,
        37,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        22,
        21,
        21,
        21,
        21,
        21,
        21,
        21,
        21,
        37,
        37,
        37,
        37,
        37,
        37,
        37,
        37,
        41,
        42,
        42,
        41,
        42,
        42,
        46,
        46,
        40,
        40,
        40,
        40,
        40,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        24,
        25,
        25,
        29,
        20,
        20,
        20,
        20,
        35,
        35,
        35,
        35,
        35,
        45,
        46,
        46,
        50,
        50,
        45,
        46,
        46,
        42,
        43,
        43,
        43,
        43,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        42,
        43,
        44,
        45,
        45,
        45,
        45,
        45,
        45,
        45,
        35,
        35,
        35,
        36,
        37,
        37,
        37,
        37,
        21,
        21,
        21,
        23,
        23,
        23,
        37,
        38,
        38,
        38,
        37,
        38,
        38,
        38,
        38,
        36,
        36,
        36,
        36,
        37,
        38,
        38,
        38,
        38,
        33,
        33,
        21,
        21,
        33,
        34,
        34,
        49,
        49,
        64,
        79,
        35,
        36,
        36,
        36,
        36,
        34,
        34,
        34,
        34,
        34,
        22,
        23,
        23,
        23,
        23,
        34,
        34,
        20,
        20,
        20,
        20,
        20,
        20,
        20,
        20,
        20,
        20,
        20,
        20
    ],
    "oracles": 39,
    "oracles_compiled": 7,
    "oracles_compiled_rate": 17.94871794871795,
    "tests_compiled": 55,
    "tests_compiled_rate": 23.30508474576271,
    "oracles_run": 7,
    "oracles_passed": 2,
    "oracles_passed_rate": 28.57142857142857,
    "tests_run": 55,
    "tests_passed": 7,
    "tests_passed_rate": 12.727272727272727,
    "lines": 58,
    "lines_covered": 25,
    "lines_coveraged_rate": 43.103448275862064,
    "branches": 20,
    "branches_covered": 6,
    "branches_coverage_rate": 30.0,
    "codes_lines": [
        2020,
        2021,
        2023,
        2024,
        2025,
        2026,
        2027,
        2028,
        2029,
        2030,
        2031,
        2032,
        2033,
        2034,
        2035,
        2036,
        2037,
        2038,
        2039,
        2040,
        2041,
        2042,
        2043,
        2044,
        2045,
        2046,
        2047,
        2048,
        2049,
        2050,
        2051,
        2052,
        2053,
        2054,
        2055,
        2056,
        2057,
        2058,
        2059,
        2060,
        2061,
        2062,
        2063,
        2064,
        2065,
        2066,
        2068,
        2071,
        2072,
        2073,
        2074,
        2075,
        2077,
        2078,
        2079,
        2080,
        2081,
        2082
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(parser_i.char() != 'p');",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(parser_i.char() != '{');",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(!parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(!parser_i.is_eof());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    assert!(left_val == right_val);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    assert!(name.find(\"!=\").is_some());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    let i = name.find(\"!=\").unwrap();",
                "    assert_eq!(&name[..i], \"name\");",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    let i = name.find(\"!=\").unwrap();",
                "    assert_eq!(&name[i + 2..], \"value\");",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    let i = name.find(\"!=\").unwrap();",
                "    assert_eq!(parser_i.parse_unicode_class().is_ok(), true);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let result = parser_i.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let result = parser_i.parse_unicode_class();",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    assert!(parser_i.char() == 'p' || parser_i.char() == 'P');",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2028,
                2029,
                2030,
                2031,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2028,
                2029,
                2030,
                2031,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(!parser_i.is_eof());",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2028,
                2029,
                2030,
                2031,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(parser_i.char() != '{');",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2028,
                2029,
                2030,
                2031,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(!parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2028,
                2029,
                2030,
                2031,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.char() == 'p' || parser_i.char() == 'P');",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.bump_and_bump_space() == true);",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.bump_and_bump_space() == false);",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.is_eof() == false);",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let name = parser_i.parser().scratch.borrow().as_str();",
                "    let result = parser_i.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let name = parser_i.parser().scratch.borrow().as_str();",
                "    let result = parser_i.parse_unicode_class();",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "}"
            ],
            [
                2020,
                2021,
                2023,
                2024,
                2025,
                2026,
                2027,
                2032,
                2033,
                2034,
                2071,
                2072,
                2073,
                2074,
                2075,
                2077,
                2078,
                2079,
                2080,
                2081,
                2082
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.char(), 'p');",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.bump_and_bump_space(), true);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.char(), '{');",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert!(parser.bump_and_bump_space() == false);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.is_eof(), false);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert!(parser.char() != '}');",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.pos.get().offset == 0);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.capture_index.get() == 0);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.nest_limit == 10);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(!parser.parser.octal);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(!parser.parser.initial_ignore_whitespace);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(!parser.parser.ignore_whitespace.get());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.comments.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.stack_group.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.stack_class.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.capture_names.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.pattern == \"\\\\p{a\");",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(scratch.is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.pos.get().offset, 0);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.capture_index.get(), 0);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.nest_limit, 10);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.octal, false);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.initial_ignore_whitespace, false);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(!parser.parser.ignore_whitespace.get());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.comments.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.stack_group.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.stack_class.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.capture_names.borrow().is_empty());",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.scratch.borrow().as_str(), \"p\");",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(matches!(_result, Ok(_)));",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(_result.unwrap().negated, false);",
                "}"
            ],
            [
                2020,
                2021
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(matches!(_result.unwrap().kind, ast::ClassUnicodeKind::Named(_)));",
                "}"
            ],
            [
                2020,
                2021
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 2021,
            "start_column": 17,
            "end_line": 2021,
            "end_column": 35,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 2021,
            "start_column": 39,
            "end_line": 2021,
            "end_column": 57,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 2027,
            "start_column": 12,
            "end_line": 2027,
            "end_column": 39,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 2034,
            "start_column": 16,
            "end_line": 2034,
            "end_column": 34,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 2036,
            "start_column": 23,
            "end_line": 2036,
            "end_column": 49,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2036,
            "start_column": 53,
            "end_line": 2036,
            "end_column": 71,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2039,
            "start_column": 20,
            "end_line": 2039,
            "end_column": 33,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2049,
            "start_column": 24,
            "end_line": 2049,
            "end_column": 31,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2055,
            "start_column": 31,
            "end_line": 2055,
            "end_column": 38,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 2061,
            "start_column": 31,
            "end_line": 2061,
            "end_column": 38,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(parser_i.char() != 'p');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(parser_i.char() != '{');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(!parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    assert!(!parser_i.is_eof());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    assert!(left_val == right_val);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    assert!(name.find(\"!=\").is_some());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    let i = name.find(\"!=\").unwrap();",
                "    assert_eq!(&name[..i], \"name\");",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    let i = name.find(\"!=\").unwrap();",
                "    assert_eq!(&name[i + 2..], \"value\");",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    ",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"a\",",
                "    };",
                "    ",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"a\",",
                "    };",
                "    let left_val = \"expected\";",
                "    let right_val = \"expected\";",
                "    let name = \"name!=value\";",
                "    let i = name.find(\"!=\").unwrap();",
                "    assert_eq!(parser_i.parse_unicode_class().is_ok(), true);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let result = parser_i.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let result = parser_i.parse_unicode_class();",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    assert!(parser_i.char() == 'p' || parser_i.char() == 'P');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(!parser_i.is_eof());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(parser_i.char() != '{');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"p\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    parser_i.parser.scratch.borrow_mut().clear();",
                "    let negated = parser_i.char() == 'P';",
                "    assert!(!parser_i.bump_and_bump_space());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.char() == 'p' || parser_i.char() == 'P');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.bump_and_bump_space() == true);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.bump_and_bump_space() == false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    assert!(parser_i.is_eof() == false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let name = parser_i.parser().scratch.borrow().as_str();",
                "    let result = parser_i.parse_unicode_class();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "        pos: Cell::new(position),",
                "        capture_index: Cell::new(0),",
                "        nest_limit: 10,",
                "        octal: true,",
                "        initial_ignore_whitespace: false,",
                "        ignore_whitespace: Cell::new(false),",
                "        comments: RefCell::new(vec![]),",
                "        stack_group: RefCell::new(vec![]),",
                "        stack_class: RefCell::new(vec![]),",
                "        capture_names: RefCell::new(vec![]),",
                "        scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "",
                "    let parser_i = ParserI {",
                "        parser: &parser,",
                "        pattern: \"property!=value\",",
                "    };",
                "",
                "    let _ = parser_i.parse_unicode_class();",
                "    let position = Position { offset: 0, line: 1, column: 1 };",
                "    let parser = Parser {",
                "    pos: Cell::new(position),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: true,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(vec![]),",
                "    stack_group: RefCell::new(vec![]),",
                "    stack_class: RefCell::new(vec![]),",
                "    capture_names: RefCell::new(vec![]),",
                "    scratch: RefCell::new(String::from(\"\")),",
                "    };",
                "    let parser_i = ParserI {",
                "    parser: &parser,",
                "    pattern: \"property!=value\",",
                "    };",
                "    let name = parser_i.parser().scratch.borrow().as_str();",
                "    let result = parser_i.parse_unicode_class();",
                "    let class_unicode = result.unwrap();",
                "    assert_eq!(class_unicode.negated, false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.char(), 'p');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.bump_and_bump_space(), true);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.char(), '{');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert!(parser.bump_and_bump_space() == false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert_eq!(parser.is_eof(), false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\px\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let parser = ParserI {",
                "    parser: Parser {",
                "    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "    capture_index: Cell::new(0),",
                "    nest_limit: 10,",
                "    octal: false,",
                "    initial_ignore_whitespace: false,",
                "    ignore_whitespace: Cell::new(false),",
                "    comments: RefCell::new(Vec::new()),",
                "    stack_group: RefCell::new(Vec::new()),",
                "    stack_class: RefCell::new(Vec::new()),",
                "    capture_names: RefCell::new(Vec::new()),",
                "    scratch: RefCell::new(String::from(\"p\")),",
                "    },",
                "    pattern: \"\\\\px\",",
                "    };",
                "    assert!(parser.char() != '}');",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.pos.get().offset == 0);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.capture_index.get() == 0);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.nest_limit == 10);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(!parser.parser.octal);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(!parser.parser.initial_ignore_whitespace);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(!parser.parser.ignore_whitespace.get());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.comments.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.stack_group.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.stack_class.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.parser.capture_names.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{a\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let scratch = parser.parser.scratch.borrow();",
                "    assert!(parser.pattern == \"\\\\p{a\");",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(scratch.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.pos.get().offset, 0);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.capture_index.get(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.nest_limit, 10);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.octal, false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.initial_ignore_whitespace, false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(!parser.parser.ignore_whitespace.get());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.comments.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.stack_group.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.stack_class.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(parser.parser.capture_names.borrow().is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(parser.parser.scratch.borrow().as_str(), \"p\");",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(matches!(_result, Ok(_)));",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert_eq!(_result.unwrap().negated, false);",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let parser = ParserI {",
                "        parser: Parser {",
                "            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),",
                "            capture_index: Cell::new(0),",
                "            nest_limit: 10,",
                "            octal: false,",
                "            initial_ignore_whitespace: false,",
                "            ignore_whitespace: Cell::new(false),",
                "            comments: RefCell::new(Vec::new()),",
                "            stack_group: RefCell::new(Vec::new()),",
                "            stack_class: RefCell::new(Vec::new()),",
                "            capture_names: RefCell::new(Vec::new()),",
                "            scratch: RefCell::new(String::from(\"p\")),",
                "        },",
                "        pattern: \"\\\\p{Greek}\",",
                "    };",
                "",
                "    let _result = parser.parse_unicode_class();",
                "    let mut scratch = parser.parser.scratch.borrow_mut();",
                "    assert!(matches!(_result.unwrap().kind, ast::ClassUnicodeKind::Named(_)));",
                "}"
            ],
            [
                {
                    "start_line": 2021,
                    "start_column": 17,
                    "end_line": 2021,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2021,
                    "start_column": 39,
                    "end_line": 2021,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 2027,
                    "start_column": 12,
                    "end_line": 2027,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2034,
                    "start_column": 16,
                    "end_line": 2034,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 23,
                    "end_line": 2036,
                    "end_column": 49,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2036,
                    "start_column": 53,
                    "end_line": 2036,
                    "end_column": 71,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2039,
                    "start_column": 20,
                    "end_line": 2039,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2049,
                    "start_column": 24,
                    "end_line": 2049,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2055,
                    "start_column": 31,
                    "end_line": 2055,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 2061,
                    "start_column": 31,
                    "end_line": 2061,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}