{
    "function_name": "regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_uncounted_repetition",
    "file_path": "/home/abezbm/rusty-unit/evaluation/regex/rusty-unit-0/regex-syntax/src/ast/parse.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax",
    "tests": 153,
    "tests_lines": [
        13,
        13,
        13,
        15,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        47,
        47,
        47,
        47,
        47,
        47,
        47,
        47,
        29,
        29,
        29,
        29,
        49,
        49,
        49,
        49,
        17,
        17,
        17,
        17,
        17,
        17,
        18,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        19,
        21,
        21,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        33,
        33,
        33,
        33,
        33,
        33,
        34,
        34,
        34,
        34,
        15,
        15,
        15,
        15,
        15,
        16,
        16,
        16,
        15,
        15,
        15,
        15,
        15,
        15,
        16,
        16,
        19,
        19,
        19,
        19,
        19,
        8,
        8,
        8,
        8,
        8,
        8,
        12,
        12,
        12,
        12,
        13,
        13,
        13,
        13,
        18,
        18,
        8,
        8,
        8,
        8,
        8,
        8,
        26,
        27,
        27,
        27,
        27,
        27,
        36,
        37,
        37,
        37,
        37,
        46,
        47,
        47,
        47,
        47,
        50,
        50,
        26,
        28,
        33,
        35,
        36,
        26,
        27,
        27,
        29,
        30,
        30,
        32,
        33,
        33,
        36,
        36,
        41,
        41,
        43,
        43,
        19,
        19,
        19,
        19,
        23,
        23
    ],
    "oracles": 24,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 4.166666666666666,
    "tests_compiled": 2,
    "tests_compiled_rate": 1.3071895424836601,
    "oracles_run": 1,
    "oracles_passed": 0,
    "oracles_passed_rate": 0.0,
    "tests_run": 2,
    "tests_passed": 0,
    "tests_passed_rate": 0.0,
    "lines": 37,
    "lines_covered": 7,
    "lines_coveraged_rate": 18.91891891891892,
    "branches": 10,
    "branches_covered": 3,
    "branches_coverage_rate": 30.0,
    "codes_lines": [
        1039,
        1040,
        1041,
        1042,
        1043,
        1044,
        1045,
        1046,
        1047,
        1048,
        1049,
        1050,
        1051,
        1052,
        1054,
        1055,
        1056,
        1057,
        1058,
        1059,
        1060,
        1061,
        1062,
        1063,
        1064,
        1065,
        1066,
        1067,
        1068,
        1069,
        1070,
        1071,
        1072,
        1073,
        1074,
        1075,
        1076
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "",
                "    let _result = parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "    assert!(parser.char() != '?');",
                "}"
            ],
            [
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045
            ]
        ],
        [
            [
                "{",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "",
                "    let _result = parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "    assert_eq!(_result, Err(parser.error(parser.span(), ast::ErrorKind::RepetitionMissing)));",
                "}"
            ],
            [
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1045,
            "start_column": 13,
            "end_line": 1045,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1045,
            "start_column": 35,
            "end_line": 1045,
            "end_column": 53,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1045,
            "start_column": 57,
            "end_line": 1045,
            "end_column": 75,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1062,
            "start_column": 12,
            "end_line": 1062,
            "end_column": 23,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1062,
            "start_column": 27,
            "end_line": 1062,
            "end_column": 45,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "",
                "    let _result = parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "    assert!(parser.char() != '?');",
                "}"
            ],
            [
                {
                    "start_line": 1045,
                    "start_column": 13,
                    "end_line": 1045,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 35,
                    "end_line": 1045,
                    "end_column": 53,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 57,
                    "end_line": 1045,
                    "end_column": 75,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1062,
                    "start_column": 12,
                    "end_line": 1062,
                    "end_column": 23,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1062,
                    "start_column": 27,
                    "end_line": 1062,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "",
                "    let _result = parser.parse_uncounted_repetition(concat, ast::RepetitionKind::ZeroOrMore);",
                "    let pos = Position { offset: 0, line: 1, column: 1 };",
                "    let span = Span::new(pos, pos);",
                "    let concat = ast::Concat { span: span.clone(), asts: Vec::new() };",
                "    let parser = ParserI { parser: Parser { pos: Cell::new(pos), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) }, pattern: \"abc\" };",
                "    assert_eq!(_result, Err(parser.error(parser.span(), ast::ErrorKind::RepetitionMissing)));",
                "}"
            ],
            [
                {
                    "start_line": 1045,
                    "start_column": 13,
                    "end_line": 1045,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 35,
                    "end_line": 1045,
                    "end_column": 53,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1045,
                    "start_column": 57,
                    "end_line": 1045,
                    "end_column": 75,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1062,
                    "start_column": 12,
                    "end_line": 1062,
                    "end_column": 23,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1062,
                    "start_column": 27,
                    "end_line": 1062,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}