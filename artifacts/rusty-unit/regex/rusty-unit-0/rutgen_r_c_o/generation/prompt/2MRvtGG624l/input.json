{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/exec.rs\n// crate name is regex\npub type ProgramCache = RefCell<ProgramCacheInner>;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::cmp;\nuse std::sync::Arc;\nuse thread_local::CachedThreadLocal;\nuse syntax::ParserBuilder;\nuse syntax::hir::Hir;\nuse syntax::hir::literal::Literals;\nuse backtrack;\nuse compile::Compiler;\nuse dfa;\nuse error::Error;\nuse input::{ByteInput, CharInput};\nuse literal::LiteralSearcher;\nuse pikevm;\nuse prog::Program;\nuse re_builder::RegexOptions;\nuse re_bytes;\nuse re_set;\nuse re_trait::{RegularExpression, Slot, Locations, as_slots};\nuse re_unicode;\nuse utf8::next_utf8;\npub trait RegularExpression: Sized {\n    type Text: ?Sized;\n    fn slots_len(&self) -> usize;\n    fn locations(&self) -> Locations;\n    fn next_after_empty(&self, text: &Self::Text, i: usize) -> usize;\n    fn shortest_match_at(&self, text: &Self::Text, start: usize) -> Option<usize>;\n    fn is_match_at(&self, text: &Self::Text, start: usize) -> bool;\n    fn find_at(&self, text: &Self::Text, start: usize) -> Option<(usize, usize)>;\n    fn read_captures_at(\n        &self,\n        locs: &mut Locations,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<(usize, usize)>;\n    fn find_iter(self, text: &Self::Text) -> Matches<Self> {\n        Matches {\n            re: self,\n            text: text,\n            last_end: 0,\n            last_match: None,\n        }\n    }\n    fn captures_iter(self, text: &Self::Text) -> CaptureMatches<Self> {\n        CaptureMatches(self.find_iter(text))\n    }\n}\n#[derive(Debug)]\npub struct ExecNoSync<'c> {\n    /// All read only state.\n    ro: &'c Arc<ExecReadOnly>,\n    /// Caches for the various matching engines.\n    cache: &'c ProgramCache,\n}\n#[derive(Debug)]\nstruct ExecReadOnly {\n    /// The original regular expressions given by the caller to compile.\n    res: Vec<String>,\n    /// A compiled program that is used in the NFA simulation and backtracking.\n    /// It can be byte-based or Unicode codepoint based.\n    ///\n    /// N.B. It is not possibly to make this byte-based from the public API.\n    /// It is only used for testing byte based programs in the NFA simulations.\n    nfa: Program,\n    /// A compiled byte based program for DFA execution. This is only used\n    /// if a DFA can be executed. (Currently, only word boundary assertions are\n    /// not supported.) Note that this program contains an embedded `.*?`\n    /// preceding the first capture group, unless the regex is anchored at the\n    /// beginning.\n    dfa: Program,\n    /// The same as above, except the program is reversed (and there is no\n    /// preceding `.*?`). This is used by the DFA to find the starting location\n    /// of matches.\n    dfa_reverse: Program,\n    /// A set of suffix literals extracted from the regex.\n    ///\n    /// Prefix literals are stored on the `Program`, since they are used inside\n    /// the matching engines.\n    suffixes: LiteralSearcher,\n    /// match_type encodes as much upfront knowledge about how we're going to\n    /// execute a search as possible.\n    match_type: MatchType,\n}\n#[derive(Clone, Copy, Debug)]\nenum MatchLiteralType {\n    /// Match literals anywhere in text.\n    Unanchored,\n    /// Match literals only at the start of text.\n    AnchoredStart,\n    /// Match literals only at the end of text.\n    AnchoredEnd,\n}\n#[derive(Clone, Debug)]\npub enum Result<T> {\n    Match(T),\n    NoMatch(usize),\n    Quit,\n}\n#[derive(Clone, Copy, Debug)]\nenum MatchNfaType {\n    /// Choose between Backtrack and PikeVM.\n    Auto,\n    /// NFA bounded backtracking.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// backtracking.)\n    Backtrack,\n    /// The Pike VM.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// the Pike VM.)\n    PikeVM,\n}\nimpl<'c> RegularExpression for ExecNoSync<'c> {\n    type Text = [u8];\n    fn slots_len(&self) -> usize {}\n    fn next_after_empty(&self, _text: &[u8], i: usize) -> usize {}\n    #[inline(always)]\n    fn shortest_match_at(&self, text: &[u8], start: usize) -> Option<usize> {}\n    #[inline(always)]\n    fn is_match_at(&self, text: &[u8], start: usize) -> bool {}\n    #[inline(always)]\n    fn find_at(&self, text: &[u8], start: usize) -> Option<(usize, usize)> {\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            MatchType::Literal(ty) => self.find_literals(ty, text, start),\n            MatchType::Dfa => {\n                match self.find_dfa_forward(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.find_nfa(MatchNfaType::Auto, text, start),\n                }\n            }\n            MatchType::DfaAnchoredReverse => {\n                match self.find_dfa_anchored_reverse(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.find_nfa(MatchNfaType::Auto, text, start),\n                }\n            }\n            MatchType::DfaSuffix => {\n                match self.find_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.find_nfa(MatchNfaType::Auto, text, start),\n                }\n            }\n            MatchType::Nfa(ty) => self.find_nfa(ty, text, start),\n            MatchType::Nothing => None,\n            MatchType::DfaMany => unreachable!(\"BUG: RegexSet cannot be used with find\"),\n        }\n    }\n    fn read_captures_at(\n        &self,\n        locs: &mut Locations,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n}\nimpl<'c> ExecNoSync<'c> {\n    #[inline(always)]\n    fn find_literals(\n        &self,\n        ty: MatchLiteralType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        use self::MatchLiteralType::*;\n        match ty {\n            Unanchored => {\n                let lits = &self.ro.nfa.prefixes;\n                lits.find(&text[start..]).map(|(s, e)| (start + s, start + e))\n            }\n            AnchoredStart => {\n                let lits = &self.ro.nfa.prefixes;\n                if !self.ro.nfa.is_anchored_start\n                    || (self.ro.nfa.is_anchored_start && start == 0)\n                {\n                    lits.find_start(&text[start..]).map(|(s, e)| (start + s, start + e))\n                } else {\n                    None\n                }\n            }\n            AnchoredEnd => {\n                let lits = &self.ro.suffixes;\n                lits.find_end(&text[start..]).map(|(s, e)| (start + s, start + e))\n            }\n        }\n    }\n    #[inline(always)]\n    fn find_dfa_forward(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use dfa::Result::*;\n        let end = match dfa::Fsm::forward(&self.ro.dfa, self.cache, false, text, start) {\n            NoMatch(i) => return NoMatch(i),\n            Quit => return Quit,\n            Match(end) if start == end => return Match((start, start)),\n            Match(end) => end,\n        };\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache,\n            false,\n            &text[start..],\n            end - start,\n        ) {\n            Match(s) => Match((start + s, end)),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }\n    #[inline(always)]\n    fn find_dfa_anchored_reverse(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use dfa::Result::*;\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache,\n            false,\n            &text[start..],\n            text.len() - start,\n        ) {\n            Match(s) => Match((start + s, text.len())),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }\n    #[inline(always)]\n    fn shortest_dfa(&self, text: &[u8], start: usize) -> dfa::Result<usize> {}\n    #[inline(always)]\n    fn shortest_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<usize> {}\n    #[inline(always)]\n    fn exec_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        original_start: usize,\n    ) -> Option<dfa::Result<(usize, usize)>> {}\n    #[inline(always)]\n    fn find_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use dfa::Result::*;\n        let match_start = match self.exec_dfa_reverse_suffix(text, start) {\n            None => return self.find_dfa_forward(text, start),\n            Some(Match((start, _))) => start,\n            Some(r) => return r,\n        };\n        match dfa::Fsm::forward(&self.ro.dfa, self.cache, false, text, match_start) {\n            NoMatch(_) => panic!(\"BUG: reverse match implies forward match\"),\n            Quit => Quit,\n            Match(e) => Match((match_start, e)),\n        }\n    }\n    fn match_nfa(&self, text: &[u8], start: usize) -> bool {}\n    fn match_nfa_type(&self, ty: MatchNfaType, text: &[u8], start: usize) -> bool {}\n    fn shortest_nfa(&self, text: &[u8], start: usize) -> Option<usize> {}\n    fn shortest_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize> {}\n    fn find_nfa(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        let mut slots = [None, None];\n        if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n    fn captures_nfa_with_match(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        match_start: usize,\n        match_end: usize,\n    ) -> Option<(usize, usize)> {}\n    fn captures_nfa(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    fn captures_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    fn exec_nfa(\n        &self,\n        mut ty: MatchNfaType,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    fn exec_pikevm(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    fn exec_backtrack(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    pub fn many_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    #[inline(always)]\n    fn is_anchor_end_match(&self, text: &[u8]) -> bool {\n        if text.len() > (1 << 20) && self.ro.nfa.is_anchored_end {\n            let lcs = self.ro.suffixes.lcs();\n            if lcs.len() >= 1 && !lcs.is_suffix(text) {\n                return false;\n            }\n        }\n        true\n    }\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {}\n}\n\nThe function to be tested is presented as follows:\n/// Finds the start and end location of the leftmost-first match, starting\n/// at the given location.\nfn find_at(&self, text: &[u8], start: usize) -> Option<(usize, usize)> {\n    if !self.is_anchor_end_match(text) {\n        return None;\n    }\n    match self.ro.match_type {\n        MatchType::Literal(ty) => {\n            self.find_literals(ty, text, start)\n        }\n        MatchType::Dfa => {\n            match self.find_dfa_forward(text, start) {\n                dfa::Result::Match((s, e)) => Some((s, e)),\n                dfa::Result::NoMatch(_) => None,\n                dfa::Result::Quit => {\n                    self.find_nfa(MatchNfaType::Auto, text, start)\n                }\n            }\n        }\n        MatchType::DfaAnchoredReverse => {\n            match self.find_dfa_anchored_reverse(text, start) {\n                dfa::Result::Match((s, e)) => Some((s, e)),\n                dfa::Result::NoMatch(_) => None,\n                dfa::Result::Quit => {\n                    self.find_nfa(MatchNfaType::Auto, text, start)\n                }\n            }\n        }\n        MatchType::DfaSuffix => {\n            match self.find_dfa_reverse_suffix(text, start) {\n                dfa::Result::Match((s, e)) => Some((s, e)),\n                dfa::Result::NoMatch(_) => None,\n                dfa::Result::Quit => {\n                    self.find_nfa(MatchNfaType::Auto, text, start)\n                }\n            }\n        }\n        MatchType::Nfa(ty) => self.find_nfa(ty, text, start),\n        MatchType::Nothing => None,\n        MatchType::DfaMany => {\n            unreachable!(\"BUG: RegexSet cannot be used with find\")\n        }\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}