{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/translate.rs\n// crate name is regex_syntax\ntype Result<T> = result::Result<T, Error>;\nuse std::cell::{Cell, RefCell};\nuse std::result;\nuse ast::{self, Ast, Span, Visitor};\nuse hir::{self, Error, ErrorKind, Hir};\nuse unicode::{self, ClassQuery};\n#[derive(Clone, Debug)]\nstruct TranslatorI<'t, 'p> {\n    trans: &'t Translator,\n    pattern: &'p str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Clone, Copy, Debug, Default)]\nstruct Flags {\n    case_insensitive: Option<bool>,\n    multi_line: Option<bool>,\n    dot_matches_new_line: Option<bool>,\n    swap_greed: Option<bool>,\n    unicode: Option<bool>,\n}\n#[derive(Clone, Debug)]\npub struct Translator {\n    /// Our call stack, but on the heap.\n    stack: RefCell<Vec<HirFrame>>,\n    /// The current flag settings.\n    flags: Cell<Flags>,\n    /// Whether we're allowed to produce HIR that can match arbitrary bytes.\n    allow_invalid_utf8: bool,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassPerl {\n    /// The span of this class.\n    pub span: Span,\n    /// The kind of Perl class.\n    pub kind: ClassPerlKind,\n    /// Whether the class is negated or not. e.g., `\\d` is not negated but\n    /// `\\D` is.\n    pub negated: bool,\n}\n#[derive(Debug)]\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n}\n#[derive(Debug)]\npub enum ClassQuery<'a> {\n    /// Return a class corresponding to a Unicode binary property, named by\n    /// a single letter.\n    OneLetter(char),\n    /// Return a class corresponding to a Unicode binary property.\n    ///\n    /// Note that, by special exception (see UTS#18, Section 1.2), both\n    /// general category values and script values are permitted here as if\n    /// they were a binary property.\n    Binary(&'a str),\n    /// Return a class corresponding to all codepoints whose property\n    /// (identified by `property_name`) corresponds to the given value\n    /// (identified by `property_value`).\n    ByValue {\n        /// A property name.\n        property_name: &'a str,\n        /// A property value.\n        property_value: &'a str,\n    },\n}\nimpl<'t, 'p> TranslatorI<'t, 'p> {\n    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {}\n    fn trans(&self) -> &Translator {}\n    fn push(&self, frame: HirFrame) {}\n    fn pop(&self) -> Option<HirFrame> {}\n    fn error(&self, span: Span, kind: ErrorKind) -> Error {}\n    fn flags(&self) -> Flags {\n        self.trans().flags.get()\n    }\n    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {}\n    fn hir_literal(&self, lit: &ast::Literal) -> Result<Hir> {}\n    fn literal_to_char(&self, lit: &ast::Literal) -> Result<hir::Literal> {}\n    fn hir_from_char(&self, span: Span, c: char) -> Result<Hir> {}\n    fn hir_from_char_case_insensitive(&self, span: Span, c: char) -> Result<Hir> {}\n    fn hir_dot(&self, span: Span) -> Result<Hir> {}\n    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {}\n    fn hir_group(&self, group: &ast::Group, expr: Hir) -> Hir {}\n    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {}\n    fn hir_unicode_class(\n        &self,\n        ast_class: &ast::ClassUnicode,\n    ) -> Result<hir::ClassUnicode> {}\n    fn hir_perl_unicode_class(&self, ast_class: &ast::ClassPerl) -> hir::ClassUnicode {\n        use ast::ClassPerlKind::*;\n        use unicode_tables::perl_word::PERL_WORD;\n        assert!(self.flags().unicode());\n        let mut class = match ast_class.kind {\n            Digit => {\n                let query = ClassQuery::Binary(\"Decimal_Number\");\n                unicode::class(query).unwrap()\n            }\n            Space => {\n                let query = ClassQuery::Binary(\"Whitespace\");\n                unicode::class(query).unwrap()\n            }\n            Word => unicode::hir_class(PERL_WORD),\n        };\n        if ast_class.negated {\n            class.negate();\n        }\n        class\n    }\n    fn hir_perl_byte_class(&self, ast_class: &ast::ClassPerl) -> hir::ClassBytes {}\n    fn unicode_fold_and_negate(&self, negated: bool, class: &mut hir::ClassUnicode) {}\n    fn bytes_fold_and_negate(\n        &self,\n        span: &Span,\n        negated: bool,\n        class: &mut hir::ClassBytes,\n    ) -> Result<()> {}\n    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {}\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {}\n    pub fn empty() -> ClassUnicode {}\n    pub fn push(&mut self, range: ClassUnicodeRange) {}\n    pub fn iter(&self) -> ClassUnicodeIter {}\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n    pub fn union(&mut self, other: &ClassUnicode) {}\n    pub fn intersect(&mut self, other: &ClassUnicode) {}\n    pub fn difference(&mut self, other: &ClassUnicode) {}\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {}\n}\nimpl Flags {\n    fn from_ast(ast: &ast::Flags) -> Flags {}\n    fn merge(&mut self, previous: &Flags) {}\n    fn case_insensitive(&self) -> bool {}\n    fn multi_line(&self) -> bool {}\n    fn dot_matches_new_line(&self) -> bool {}\n    fn swap_greed(&self) -> bool {}\n    fn unicode(&self) -> bool {\n        self.unicode.unwrap_or(true)\n    }\n}\npub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode {\n    let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges\n        .iter()\n        .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))\n        .collect();\n    hir::ClassUnicode::new(hir_ranges)\n}\npub fn class<'a>(query: ClassQuery<'a>) -> Result<hir::ClassUnicode> {\n    use self::CanonicalClassQuery::*;\n    match query.canonicalize()? {\n        Binary(name) => {\n            property_set(property_bool::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyNotFound)\n        }\n        GeneralCategory(\"Any\") => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n        GeneralCategory(\"Assigned\") => {\n            let mut cls = property_set(general_category::BY_NAME, \"Unassigned\")\n                .map(hir_class)\n                .ok_or(Error::PropertyNotFound)?;\n            cls.negate();\n            Ok(cls)\n        }\n        GeneralCategory(\"ASCII\") => Ok(hir_class(&[('\\0', '\\x7F')])),\n        GeneralCategory(name) => {\n            property_set(general_category::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        Script(name) => {\n            property_set(script::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        ByValue { property_name: \"Age\", property_value } => {\n            let mut class = hir::ClassUnicode::empty();\n            for set in ages(property_value)? {\n                class.union(&hir_class(set));\n            }\n            Ok(class)\n        }\n        ByValue { property_name: \"Script_Extensions\", property_value } => {\n            property_set(script_extension::BY_NAME, property_value)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        _ => Err(Error::PropertyNotFound),\n    }\n}\n\nThe function to be tested is presented as follows:\nfn hir_perl_unicode_class(\n    &self,\n    ast_class: &ast::ClassPerl,\n) -> hir::ClassUnicode {\n    use ast::ClassPerlKind::*;\n    use unicode_tables::perl_word::PERL_WORD;\n\n    assert!(self.flags().unicode());\n    let mut class = match ast_class.kind {\n        Digit => {\n            let query = ClassQuery::Binary(\"Decimal_Number\");\n            unicode::class(query).unwrap()\n        }\n        Space => {\n            let query = ClassQuery::Binary(\"Whitespace\");\n            unicode::class(query).unwrap()\n        }\n        Word => unicode::hir_class(PERL_WORD),\n    };\n    // We needn't apply case folding here because the Perl Unicode classes\n    // are already closed under Unicode simple case folding.\n    if ast_class.negated {\n        class.negate();\n    }\n    class\n}\n",
  "depend_pt": ""
}