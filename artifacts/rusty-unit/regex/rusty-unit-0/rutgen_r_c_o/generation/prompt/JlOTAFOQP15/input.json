{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/hir/visitor.rs\n// crate name is regex_syntax\nuse hir::{self, Hir, HirKind};\nstruct HeapVisitor<'a> {\n    /// A stack of `Hir` nodes. This is roughly analogous to the call stack\n    /// used in a typical recursive visitor.\n    stack: Vec<(&'a Hir, Frame<'a>)>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Hir {\n    /// The underlying HIR kind.\n    kind: HirKind,\n    /// Analysis info about this HIR, computed during construction.\n    info: HirInfo,\n}\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a hir::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a hir::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Hir,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Hir],\n    },\n}\nenum Frame<'a> {\n    /// A stack frame allocated just before descending into a repetition\n    /// operator's child node.\n    Repetition(&'a ast::Repetition),\n    /// A stack frame allocated just before descending into a group's child\n    /// node.\n    Group(&'a ast::Group),\n    /// The stack frame used while visiting every child node of a concatenation\n    /// of expressions.\n    Concat {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n    /// The stack frame used while visiting every child node of an alternation\n    /// of expressions.\n    Alternation {\n        /// The child node we are currently visiting.\n        head: &'a Ast,\n        /// The remaining child nodes to visit (which may be empty).\n        tail: &'a [Ast],\n    },\n}\nimpl<'a> HeapVisitor<'a> {\n    fn new() -> HeapVisitor<'a> {}\n    fn visit<V: Visitor>(\n        &mut self,\n        mut hir: &'a Hir,\n        mut visitor: V,\n    ) -> Result<V::Output, V::Err> {\n        self.stack.clear();\n        visitor.start();\n        loop {\n            visitor.visit_pre(hir)?;\n            if let Some(x) = self.induct(hir) {\n                let child = x.child();\n                self.stack.push((hir, x));\n                hir = child;\n                continue;\n            }\n            visitor.visit_post(hir)?;\n            loop {\n                let (post_hir, frame) = match self.stack.pop() {\n                    None => return visitor.finish(),\n                    Some((post_hir, frame)) => (post_hir, frame),\n                };\n                if let Some(x) = self.pop(frame) {\n                    if let Frame::Alternation { .. } = x {\n                        visitor.visit_alternation_in()?;\n                    }\n                    hir = x.child();\n                    self.stack.push((post_hir, x));\n                    break;\n                }\n                visitor.visit_post(post_hir)?;\n            }\n        }\n    }\n    fn induct(&mut self, hir: &'a Hir) -> Option<Frame<'a>> {\n        match *hir.kind() {\n            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),\n            HirKind::Group(ref x) => Some(Frame::Group(x)),\n            HirKind::Concat(ref x) if x.is_empty() => None,\n            HirKind::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x[0],\n                    tail: &x[1..],\n                })\n            }\n            HirKind::Alternation(ref x) if x.is_empty() => None,\n            HirKind::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x[0],\n                    tail: &x[1..],\n                })\n            }\n            _ => None,\n        }\n    }\n    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {\n        match induct {\n            Frame::Repetition(_) => None,\n            Frame::Group(_) => None,\n            Frame::Concat { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Concat {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n            Frame::Alternation { tail, .. } => {\n                if tail.is_empty() {\n                    None\n                } else {\n                    Some(Frame::Alternation {\n                        head: &tail[0],\n                        tail: &tail[1..],\n                    })\n                }\n            }\n        }\n    }\n}\nimpl<'a> Frame<'a> {\n    fn child(&self) -> &'a Hir {\n        match *self {\n            Frame::Repetition(rep) => &rep.hir,\n            Frame::Group(group) => &group.hir,\n            Frame::Concat { head, .. } => head,\n            Frame::Alternation { head, .. } => head,\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\nfn visit<V: Visitor>(\n    &mut self,\n    mut hir: &'a Hir,\n    mut visitor: V,\n) -> Result<V::Output, V::Err> {\n    self.stack.clear();\n\n    visitor.start();\n    loop {\n        visitor.visit_pre(hir)?;\n        if let Some(x) = self.induct(hir) {\n            let child = x.child();\n            self.stack.push((hir, x));\n            hir = child;\n            continue;\n        }\n        // No induction means we have a base case, so we can post visit\n        // it now.\n        visitor.visit_post(hir)?;\n\n        // At this point, we now try to pop our call stack until it is\n        // either empty or we hit another inductive case.\n        loop {\n            let (post_hir, frame) = match self.stack.pop() {\n                None => return visitor.finish(),\n                Some((post_hir, frame)) => (post_hir, frame),\n            };\n            // If this is a concat/alternate, then we might have additional\n            // inductive steps to process.\n            if let Some(x) = self.pop(frame) {\n                if let Frame::Alternation {..} = x {\n                    visitor.visit_alternation_in()?;\n                }\n                hir = x.child();\n                self.stack.push((post_hir, x));\n                break;\n            }\n            // Otherwise, we've finished visiting all the child nodes for\n            // this HIR, so we can post visit it now.\n            visitor.visit_post(post_hir)?;\n        }\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}