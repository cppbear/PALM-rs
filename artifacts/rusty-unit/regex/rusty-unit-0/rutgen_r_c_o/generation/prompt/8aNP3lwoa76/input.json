{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/unicode.rs\n// crate name is regex_syntax\ntype Result<T> = result::Result<T, Error>;\nuse std::cmp::Ordering;\nuse std::result;\nuse ucd_util::{self, PropertyValues};\nuse hir;\nuse unicode_tables::age;\nuse unicode_tables::case_folding_simple::CASE_FOLDING_SIMPLE;\nuse unicode_tables::general_category;\nuse unicode_tables::property_bool;\nuse unicode_tables::property_names::PROPERTY_NAMES;\nuse unicode_tables::property_values::PROPERTY_VALUES;\nuse unicode_tables::script;\nuse unicode_tables::script_extension;\n#[derive(Debug)]\nstruct AgeIter {\n    ages: &'static [(&'static str, &'static [(char, char)])],\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct ClassUnicode {\n    set: IntervalSet<ClassUnicodeRange>,\n}\n#[derive(Debug)]\npub enum ClassQuery<'a> {\n    /// Return a class corresponding to a Unicode binary property, named by\n    /// a single letter.\n    OneLetter(char),\n    /// Return a class corresponding to a Unicode binary property.\n    ///\n    /// Note that, by special exception (see UTS#18, Section 1.2), both\n    /// general category values and script values are permitted here as if\n    /// they were a binary property.\n    Binary(&'a str),\n    /// Return a class corresponding to all codepoints whose property\n    /// (identified by `property_name`) corresponds to the given value\n    /// (identified by `property_value`).\n    ByValue {\n        /// A property name.\n        property_name: &'a str,\n        /// A property value.\n        property_value: &'a str,\n    },\n}\n#[derive(Debug)]\npub enum Error {\n    PropertyNotFound,\n    PropertyValueNotFound,\n}\n#[derive(Debug, Eq, PartialEq)]\nenum CanonicalClassQuery {\n    /// The canonical binary property name.\n    Binary(&'static str),\n    /// The canonical general category name.\n    GeneralCategory(&'static str),\n    /// The canonical script name.\n    Script(&'static str),\n    /// An arbitrary association between property and value, both of which\n    /// have been canonicalized.\n    ///\n    /// Note that by construction, the property name of ByValue will never\n    /// be General_Category or Script. Those two cases are subsumed by the\n    /// eponymous variants.\n    ByValue {\n        /// The canonical property name.\n        property_name: &'static str,\n        /// The canonical property value.\n        property_value: &'static str,\n    },\n}\nimpl Iterator for AgeIter {\n    type Item = &'static [(char, char)];\n    fn next(&mut self) -> Option<&'static [(char, char)]> {\n        if self.ages.is_empty() {\n            None\n        } else {\n            let set = self.ages[0];\n            self.ages = &self.ages[1..];\n            Some(set.1)\n        }\n    }\n}\nimpl<'a> ClassQuery<'a> {\n    fn canonicalize(&self) -> Result<CanonicalClassQuery> {\n        match *self {\n            ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),\n            ClassQuery::Binary(name) => self.canonical_binary(name),\n            ClassQuery::ByValue { property_name, property_value } => {\n                let property_name = normalize(property_name);\n                let property_value = normalize(property_value);\n                let canon_name = match canonical_prop(&property_name) {\n                    None => return Err(Error::PropertyNotFound),\n                    Some(canon_name) => canon_name,\n                };\n                Ok(\n                    match canon_name {\n                        \"General_Category\" => {\n                            let canon = match canonical_gencat(&property_value) {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(canon) => canon,\n                            };\n                            CanonicalClassQuery::GeneralCategory(canon)\n                        }\n                        \"Script\" => {\n                            let canon = match canonical_script(&property_value) {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(canon) => canon,\n                            };\n                            CanonicalClassQuery::Script(canon)\n                        }\n                        _ => {\n                            let vals = match property_values(canon_name) {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(vals) => vals,\n                            };\n                            let canon_val = match canonical_value(\n                                vals,\n                                &property_value,\n                            ) {\n                                None => return Err(Error::PropertyValueNotFound),\n                                Some(canon_val) => canon_val,\n                            };\n                            CanonicalClassQuery::ByValue {\n                                property_name: canon_name,\n                                property_value: canon_val,\n                            }\n                        }\n                    },\n                )\n            }\n        }\n    }\n    fn canonical_binary(&self, name: &str) -> Result<CanonicalClassQuery> {}\n}\nimpl ClassUnicode {\n    pub fn new<I>(ranges: I) -> ClassUnicode\n    where\n        I: IntoIterator<Item = ClassUnicodeRange>,\n    {}\n    pub fn empty() -> ClassUnicode {\n        ClassUnicode::new(vec![])\n    }\n    pub fn push(&mut self, range: ClassUnicodeRange) {}\n    pub fn iter(&self) -> ClassUnicodeIter {}\n    pub fn ranges(&self) -> &[ClassUnicodeRange] {}\n    pub fn case_fold_simple(&mut self) {}\n    pub fn negate(&mut self) {\n        self.set.negate();\n    }\n    pub fn union(&mut self, other: &ClassUnicode) {\n        self.set.union(&other.set);\n    }\n    pub fn intersect(&mut self, other: &ClassUnicode) {}\n    pub fn difference(&mut self, other: &ClassUnicode) {}\n    pub fn symmetric_difference(&mut self, other: &ClassUnicode) {}\n}\npub fn class<'a>(query: ClassQuery<'a>) -> Result<hir::ClassUnicode> {\n    use self::CanonicalClassQuery::*;\n    match query.canonicalize()? {\n        Binary(name) => {\n            property_set(property_bool::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyNotFound)\n        }\n        GeneralCategory(\"Any\") => Ok(hir_class(&[('\\0', '\\u{10FFFF}')])),\n        GeneralCategory(\"Assigned\") => {\n            let mut cls = property_set(general_category::BY_NAME, \"Unassigned\")\n                .map(hir_class)\n                .ok_or(Error::PropertyNotFound)?;\n            cls.negate();\n            Ok(cls)\n        }\n        GeneralCategory(\"ASCII\") => Ok(hir_class(&[('\\0', '\\x7F')])),\n        GeneralCategory(name) => {\n            property_set(general_category::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        Script(name) => {\n            property_set(script::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        ByValue { property_name: \"Age\", property_value } => {\n            let mut class = hir::ClassUnicode::empty();\n            for set in ages(property_value)? {\n                class.union(&hir_class(set));\n            }\n            Ok(class)\n        }\n        ByValue { property_name: \"Script_Extensions\", property_value } => {\n            property_set(script_extension::BY_NAME, property_value)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        _ => Err(Error::PropertyNotFound),\n    }\n}\nfn property_set(\n    name_map: &'static [(&'static str, &'static [(char, char)])],\n    canonical: &'static str,\n) -> Option<&'static [(char, char)]> {\n    name_map.binary_search_by_key(&canonical, |x| x.0).ok().map(|i| name_map[i].1)\n}\npub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode {\n    let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges\n        .iter()\n        .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))\n        .collect();\n    hir::ClassUnicode::new(hir_ranges)\n}\nfn ages(canonical_age: &str) -> Result<AgeIter> {\n    const AGES: &'static [(&'static str, &'static [(char, char)])] = &[\n        (\"V1_1\", age::V1_1),\n        (\"V2_0\", age::V2_0),\n        (\"V2_1\", age::V2_1),\n        (\"V3_0\", age::V3_0),\n        (\"V3_1\", age::V3_1),\n        (\"V3_2\", age::V3_2),\n        (\"V4_0\", age::V4_0),\n        (\"V4_1\", age::V4_1),\n        (\"V5_0\", age::V5_0),\n        (\"V5_1\", age::V5_1),\n        (\"V5_2\", age::V5_2),\n        (\"V6_0\", age::V6_0),\n        (\"V6_1\", age::V6_1),\n        (\"V6_2\", age::V6_2),\n        (\"V6_3\", age::V6_3),\n        (\"V7_0\", age::V7_0),\n        (\"V8_0\", age::V8_0),\n        (\"V9_0\", age::V9_0),\n        (\"V10_0\", age::V10_0),\n    ];\n    assert_eq!(AGES.len(), age::BY_NAME.len(), \"ages are out of sync\");\n    let pos = AGES.iter().position(|&(age, _)| canonical_age == age);\n    match pos {\n        None => Err(Error::PropertyValueNotFound),\n        Some(i) => Ok(AgeIter { ages: &AGES[..i + 1] }),\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Looks up a Unicode class given a query. If one doesn't exist, then\n/// `None` is returned.\npub fn class<'a>(query: ClassQuery<'a>) -> Result<hir::ClassUnicode> {\n    use self::CanonicalClassQuery::*;\n\n    match query.canonicalize()? {\n        Binary(name) => {\n            property_set(property_bool::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyNotFound)\n        }\n        GeneralCategory(\"Any\") => {\n            Ok(hir_class(&[('\\0', '\\u{10FFFF}')]))\n        }\n        GeneralCategory(\"Assigned\") => {\n            let mut cls =\n                property_set(general_category::BY_NAME, \"Unassigned\")\n                    .map(hir_class)\n                    .ok_or(Error::PropertyNotFound)?;\n            cls.negate();\n            Ok(cls)\n        }\n        GeneralCategory(\"ASCII\") => {\n            Ok(hir_class(&[('\\0', '\\x7F')]))\n        }\n        GeneralCategory(name) => {\n            property_set(general_category::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        Script(name) => {\n            property_set(script::BY_NAME, name)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        ByValue { property_name: \"Age\", property_value } => {\n            let mut class = hir::ClassUnicode::empty();\n            for set in ages(property_value)? {\n                class.union(&hir_class(set));\n            }\n            Ok(class)\n        }\n        ByValue { property_name: \"Script_Extensions\", property_value } => {\n            property_set(script_extension::BY_NAME, property_value)\n                .map(hir_class)\n                .ok_or(Error::PropertyValueNotFound)\n        }\n        _ => {\n            // What else should we support?\n            Err(Error::PropertyNotFound)\n        }\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}