{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// regex-syntax/src/ast/parse.rs\n// crate name is regex_syntax\ntype Result<T> = result::Result<T, ast::Error>;\nuse std::borrow::Borrow;\nuse std::cell::{Cell, RefCell};\nuse std::mem;\nuse std::result;\nuse ast::{self, Ast, Position, Span};\nuse either::Either;\nuse is_meta_character;\n#[derive(Clone, Debug)]\nstruct ParserI<'s, P> {\n    /// The parser state/configuration.\n    parser: P,\n    /// The full regular expression provided by the user.\n    pattern: &'s str,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Literal {\n    /// The span of this literal.\n    pub span: Span,\n    /// The kind of this literal.\n    pub kind: LiteralKind,\n    /// The Unicode scalar value corresponding to this literal.\n    pub c: char,\n}\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct Span {\n    /// The start byte offset.\n    pub start: Position,\n    /// The end byte offset.\n    pub end: Position,\n}\n#[derive(Clone, Debug)]\npub struct Parser {\n    /// The current position of the parser.\n    pos: Cell<Position>,\n    /// The current capture index.\n    capture_index: Cell<u32>,\n    /// The maximum number of open parens/brackets allowed. If the parser\n    /// exceeds this number, then an error is returned.\n    nest_limit: u32,\n    /// Whether to support octal syntax or not. When `false`, the parser will\n    /// return an error helpfully pointing out that backreferences are not\n    /// supported.\n    octal: bool,\n    /// The initial setting for `ignore_whitespace` as provided by\n    /// Th`ParserBuilder`. is is used when reseting the parser's state.\n    initial_ignore_whitespace: bool,\n    /// Whether whitespace should be ignored. When enabled, comments are\n    /// also permitted.\n    ignore_whitespace: Cell<bool>,\n    /// A list of comments, in order of appearance.\n    comments: RefCell<Vec<ast::Comment>>,\n    /// A stack of grouped sub-expressions, including alternations.\n    stack_group: RefCell<Vec<GroupState>>,\n    /// A stack of nested character classes. This is only non-empty when\n    /// parsing a class.\n    stack_class: RefCell<Vec<ClassState>>,\n    /// A sorted sequence of capture names. This is used to detect duplicate\n    /// capture names and report an error if one is detected.\n    capture_names: RefCell<Vec<ast::CaptureName>>,\n    /// A scratch buffer used in various places. Mostly this is used to\n    /// accumulate relevant characters from parts of a pattern.\n    scratch: RefCell<String>,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Error {\n    /// The kind of error.\n    kind: ErrorKind,\n    /// The original pattern that the parser generated the error from. Every\n    /// span in an error is a valid range into this string.\n    pattern: String,\n    /// The span of this error.\n    span: Span,\n}\n#[derive(Clone, Debug)]\npub struct Parser {\n    ast: ast::parse::Parser,\n    hir: hir::translate::Translator,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Assertion {\n    /// The span of this assertion.\n    pub span: Span,\n    /// The assertion kind, e.g., `\\b` or `^`.\n    pub kind: AssertionKind,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum AssertionKind {\n    /// `^`\n    StartLine,\n    /// `$`\n    EndLine,\n    /// `\\A`\n    StartText,\n    /// `\\z`\n    EndText,\n    /// `\\b`\n    WordBoundary,\n    /// `\\B`\n    NotWordBoundary,\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\nenum Primitive {\n    Literal(ast::Literal),\n    Assertion(ast::Assertion),\n    Dot(Span),\n    Perl(ast::ClassPerl),\n    Unicode(ast::ClassUnicode),\n}\n#[derive(Clone, Debug, Eq, PartialEq)]\npub enum LiteralKind {\n    /// The literal is written verbatim, e.g., `a` or `â˜ƒ`.\n    Verbatim,\n    /// The literal is written as an escape because it is punctuation, e.g.,\n    /// `\\*` or `\\[`.\n    Punctuation,\n    /// The literal is written as an octal escape, e.g., `\\141`.\n    Octal,\n    /// The literal is written as a hex code with a fixed number of digits\n    /// depending on the type of the escape, e.g., `\\x61` or or `\\u0061` or\n    /// `\\U00000061`.\n    HexFixed(HexLiteralKind),\n    /// The literal is written as a hex code with a bracketed number of\n    /// digits. The only restriction is that the bracketed hex code must refer\n    /// to a valid Unicode scalar value.\n    HexBrace(HexLiteralKind),\n    /// The literal is written as a specially recognized escape, e.g., `\\f`\n    /// or `\\n`.\n    Special(SpecialLiteralKind),\n}\nimpl<'s, P: Borrow<Parser>> ParserI<'s, P> {\n    fn parse(&self) -> Result<Ast> {}\n    fn parse_with_comments(&self) -> Result<ast::WithComments> {}\n    fn parse_uncounted_repetition(\n        &self,\n        mut concat: ast::Concat,\n        kind: ast::RepetitionKind,\n    ) -> Result<ast::Concat> {}\n    fn parse_counted_repetition(&self, mut concat: ast::Concat) -> Result<ast::Concat> {}\n    fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {}\n    fn parse_capture_name(&self, capture_index: u32) -> Result<ast::CaptureName> {}\n    fn parse_flags(&self) -> Result<ast::Flags> {}\n    fn parse_flag(&self) -> Result<ast::Flag> {}\n    fn parse_primitive(&self) -> Result<Primitive> {\n        match self.char() {\n            '\\\\' => self.parse_escape(),\n            '.' => {\n                let ast = Primitive::Dot(self.span_char());\n                self.bump();\n                Ok(ast)\n            }\n            '^' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::StartLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            '$' => {\n                let ast = Primitive::Assertion(ast::Assertion {\n                    span: self.span_char(),\n                    kind: ast::AssertionKind::EndLine,\n                });\n                self.bump();\n                Ok(ast)\n            }\n            c => {\n                let ast = Primitive::Literal(ast::Literal {\n                    span: self.span_char(),\n                    kind: ast::LiteralKind::Verbatim,\n                    c: c,\n                });\n                self.bump();\n                Ok(ast)\n            }\n        }\n    }\n    fn parse_escape(&self) -> Result<Primitive> {\n        assert_eq!(self.char(), '\\\\');\n        let start = self.pos();\n        if !self.bump() {\n            return Err(\n                self\n                    .error(\n                        Span::new(start, self.pos()),\n                        ast::ErrorKind::EscapeUnexpectedEof,\n                    ),\n            );\n        }\n        let c = self.char();\n        match c {\n            '0'..='7' => {\n                if !self.parser().octal {\n                    return Err(\n                        self\n                            .error(\n                                Span::new(start, self.span_char().end),\n                                ast::ErrorKind::UnsupportedBackreference,\n                            ),\n                    );\n                }\n                let mut lit = self.parse_octal();\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            '8'..='9' if !self.parser().octal => {\n                return Err(\n                    self\n                        .error(\n                            Span::new(start, self.span_char().end),\n                            ast::ErrorKind::UnsupportedBackreference,\n                        ),\n                );\n            }\n            'x' | 'u' | 'U' => {\n                let mut lit = self.parse_hex()?;\n                lit.span.start = start;\n                return Ok(Primitive::Literal(lit));\n            }\n            'p' | 'P' => {\n                let mut cls = self.parse_unicode_class()?;\n                cls.span.start = start;\n                return Ok(Primitive::Unicode(cls));\n            }\n            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {\n                let mut cls = self.parse_perl_class();\n                cls.span.start = start;\n                return Ok(Primitive::Perl(cls));\n            }\n            _ => {}\n        }\n        self.bump();\n        let span = Span::new(start, self.pos());\n        if is_meta_character(c) {\n            return Ok(\n                Primitive::Literal(ast::Literal {\n                    span: span,\n                    kind: ast::LiteralKind::Punctuation,\n                    c: c,\n                }),\n            );\n        }\n        let special = |kind, c| Ok(\n            Primitive::Literal(ast::Literal {\n                span: span,\n                kind: ast::LiteralKind::Special(kind),\n                c: c,\n            }),\n        );\n        match c {\n            'a' => special(ast::SpecialLiteralKind::Bell, '\\x07'),\n            'f' => special(ast::SpecialLiteralKind::FormFeed, '\\x0C'),\n            't' => special(ast::SpecialLiteralKind::Tab, '\\t'),\n            'n' => special(ast::SpecialLiteralKind::LineFeed, '\\n'),\n            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\\r'),\n            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\\x0B'),\n            ' ' if self.ignore_whitespace() => {\n                special(ast::SpecialLiteralKind::Space, ' ')\n            }\n            'A' => {\n                Ok(\n                    Primitive::Assertion(ast::Assertion {\n                        span: span,\n                        kind: ast::AssertionKind::StartText,\n                    }),\n                )\n            }\n            'z' => {\n                Ok(\n                    Primitive::Assertion(ast::Assertion {\n                        span: span,\n                        kind: ast::AssertionKind::EndText,\n                    }),\n                )\n            }\n            'b' => {\n                Ok(\n                    Primitive::Assertion(ast::Assertion {\n                        span: span,\n                        kind: ast::AssertionKind::WordBoundary,\n                    }),\n                )\n            }\n            'B' => {\n                Ok(\n                    Primitive::Assertion(ast::Assertion {\n                        span: span,\n                        kind: ast::AssertionKind::NotWordBoundary,\n                    }),\n                )\n            }\n            _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),\n        }\n    }\n    fn parse_octal(&self) -> ast::Literal {}\n    fn parse_hex(&self) -> Result<ast::Literal> {}\n    fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {}\n    fn parse_hex_brace(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {}\n    fn parse_decimal(&self) -> Result<u32> {}\n    fn parse_set_class(&self) -> Result<ast::Class> {}\n    fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {}\n    fn parse_set_class_item(&self) -> Result<Primitive> {}\n    fn parse_set_class_open(&self) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {}\n    fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {}\n    fn parse_unicode_class(&self) -> Result<ast::ClassUnicode> {}\n    fn parse_perl_class(&self) -> ast::ClassPerl {}\n}\n\nThe function to be tested is presented as follows:\n/// Parse a primitive AST. e.g., A literal, non-set character class or\n/// assertion.\n///\n/// This assumes that the parser expects a primitive at the current\n/// location. i.e., All other non-primitive cases have been handled.\n/// For example, if the parser's position is at `|`, then `|` will be\n/// treated as a literal (e.g., inside a character class).\n///\n/// This advances the parser to the first character immediately following\n/// the primitive.\nfn parse_primitive(&self) -> Result<Primitive> {\n    match self.char() {\n        '\\\\' => self.parse_escape(),\n        '.' => {\n            let ast = Primitive::Dot(self.span_char());\n            self.bump();\n            Ok(ast)\n        }\n        '^' => {\n            let ast = Primitive::Assertion(ast::Assertion {\n                span: self.span_char(),\n                kind: ast::AssertionKind::StartLine,\n            });\n            self.bump();\n            Ok(ast)\n        }\n        '$' => {\n            let ast = Primitive::Assertion(ast::Assertion {\n                span: self.span_char(),\n                kind: ast::AssertionKind::EndLine,\n            });\n            self.bump();\n            Ok(ast)\n        }\n        c => {\n            let ast = Primitive::Literal(ast::Literal {\n                span: self.span_char(),\n                kind: ast::LiteralKind::Verbatim,\n                c: c,\n            });\n            self.bump();\n            Ok(ast)\n        }\n    }\n}\n",
  "depend_pt": ""
}