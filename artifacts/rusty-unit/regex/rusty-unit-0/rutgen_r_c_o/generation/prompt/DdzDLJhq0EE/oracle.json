{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/literal/mod.rs\n// crate name is regex\nuse std::cmp;\nuse std::mem;\nuse aho_corasick::{Automaton, AcAutomaton, FullAcAutomaton};\nuse memchr::{memchr, memchr2, memchr3};\nuse syntax::hir::literal::{Literal, Literals};\nuse freqs::BYTE_FREQUENCIES;\nuse self::teddy_avx2::Teddy as TeddyAVX2;\nuse self::teddy_ssse3::Teddy as TeddySSSE3;\n#[derive(Clone, Debug)]\npub struct FreqyPacked {\n    /// The pattern.\n    pat: Vec<u8>,\n    /// The number of Unicode characters in the pattern. This is useful for\n    /// determining the effective length of a pattern when deciding which\n    /// optimizations to perform. A trailing incomplete UTF-8 sequence counts\n    /// as one character.\n    char_len: usize,\n    /// The rarest byte in the pattern, according to pre-computed frequency\n    /// analysis.\n    rare1: u8,\n    /// The offset of the rarest byte in `pat`.\n    rare1i: usize,\n    /// The second rarest byte in the pattern, according to pre-computed\n    /// frequency analysis. (This may be equivalent to the rarest byte.)\n    ///\n    /// The second rarest byte is used as a type of guard for quickly detecting\n    /// a mismatch after memchr locates an instance of the rarest byte. This\n    /// is a hedge against pathological cases where the pre-computed frequency\n    /// analysis may be off. (But of course, does not prevent *all*\n    /// pathological cases.)\n    rare2: u8,\n    /// The offset of the second rarest byte in `pat`.\n    rare2i: usize,\n}\nimpl FreqyPacked {\n    fn new(pat: Vec<u8>) -> FreqyPacked {\n        if pat.is_empty() {\n            return FreqyPacked::empty();\n        }\n        let mut rare1 = pat[0];\n        let mut rare2 = pat[0];\n        for b in pat[1..].iter().cloned() {\n            if freq_rank(b) < freq_rank(rare1) {\n                rare1 = b;\n            }\n        }\n        for &b in &pat {\n            if rare1 == rare2 {\n                rare2 = b\n            } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {\n                rare2 = b;\n            }\n        }\n        let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n        let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n        let char_len = char_len_lossy(&pat);\n        FreqyPacked {\n            pat: pat,\n            char_len: char_len,\n            rare1: rare1,\n            rare1i: rare1i,\n            rare2: rare2,\n            rare2i: rare2i,\n        }\n    }\n    fn empty() -> FreqyPacked {\n        FreqyPacked {\n            pat: vec![],\n            char_len: 0,\n            rare1: 0,\n            rare1i: 0,\n            rare2: 0,\n            rare2i: 0,\n        }\n    }\n    #[inline(always)]\n    pub fn find(&self, haystack: &[u8]) -> Option<usize> {}\n    #[inline(always)]\n    pub fn is_suffix(&self, text: &[u8]) -> bool {}\n    pub fn len(&self) -> usize {}\n    pub fn char_len(&self) -> usize {}\n    fn approximate_size(&self) -> usize {}\n}\nfn char_len_lossy(bytes: &[u8]) -> usize {\n    String::from_utf8_lossy(bytes).chars().count()\n}\nfn freq_rank(b: u8) -> usize {\n    BYTE_FREQUENCIES[b as usize] as usize\n}\n\nThe function to be tested is presented as follows:\nfn new(pat: Vec<u8>) -> FreqyPacked {\n    if pat.is_empty() {\n        return FreqyPacked::empty();\n    }\n\n    // Find the rarest two bytes. Try to make them distinct (but it's not\n    // required).\n    let mut rare1 = pat[0];\n    let mut rare2 = pat[0];\n    for b in pat[1..].iter().cloned() {\n        if freq_rank(b) < freq_rank(rare1) {\n            rare1 = b;\n        }\n    }\n    for &b in &pat {\n        if rare1 == rare2 {\n            rare2 = b\n        } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {\n            rare2 = b;\n        }\n    }\n\n    // And find the offsets of their last occurrences.\n    let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n\n    let char_len = char_len_lossy(&pat);\n    FreqyPacked {\n        pat: pat,\n        char_len: char_len,\n        rare1: rare1,\n        rare1i: rare1i,\n        rare2: rare2,\n        rare2i: rare2i,\n    }\n}\n",
  "depend_pt": ""
}