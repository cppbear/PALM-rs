{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/exec.rs\n// crate name is regex\npub type ProgramCache = RefCell<ProgramCacheInner>;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::cmp;\nuse std::sync::Arc;\nuse thread_local::CachedThreadLocal;\nuse syntax::ParserBuilder;\nuse syntax::hir::Hir;\nuse syntax::hir::literal::Literals;\nuse backtrack;\nuse compile::Compiler;\nuse dfa;\nuse error::Error;\nuse input::{ByteInput, CharInput};\nuse literal::LiteralSearcher;\nuse pikevm;\nuse prog::Program;\nuse re_builder::RegexOptions;\nuse re_bytes;\nuse re_set;\nuse re_trait::{RegularExpression, Slot, Locations, as_slots};\nuse re_unicode;\nuse utf8::next_utf8;\npub struct Exec {\n    /// All read only state.\n    ro: Arc<ExecReadOnly>,\n    /// Caches for the various matching engines.\n    cache: CachedThreadLocal<ProgramCache>,\n}\n#[derive(Debug)]\nstruct ExecReadOnly {\n    /// The original regular expressions given by the caller to compile.\n    res: Vec<String>,\n    /// A compiled program that is used in the NFA simulation and backtracking.\n    /// It can be byte-based or Unicode codepoint based.\n    ///\n    /// N.B. It is not possibly to make this byte-based from the public API.\n    /// It is only used for testing byte based programs in the NFA simulations.\n    nfa: Program,\n    /// A compiled byte based program for DFA execution. This is only used\n    /// if a DFA can be executed. (Currently, only word boundary assertions are\n    /// not supported.) Note that this program contains an embedded `.*?`\n    /// preceding the first capture group, unless the regex is anchored at the\n    /// beginning.\n    dfa: Program,\n    /// The same as above, except the program is reversed (and there is no\n    /// preceding `.*?`). This is used by the DFA to find the starting location\n    /// of matches.\n    dfa_reverse: Program,\n    /// A set of suffix literals extracted from the regex.\n    ///\n    /// Prefix literals are stored on the `Program`, since they are used inside\n    /// the matching engines.\n    suffixes: LiteralSearcher,\n    /// match_type encodes as much upfront knowledge about how we're going to\n    /// execute a search as possible.\n    match_type: MatchType,\n}\nimpl Exec {\n    #[inline(always)]\n    pub fn searcher(&self) -> ExecNoSync {}\n    #[inline(always)]\n    pub fn searcher_str(&self) -> ExecNoSyncStr {}\n    pub fn into_regex(self) -> re_unicode::Regex {}\n    pub fn into_regex_set(self) -> re_set::unicode::RegexSet {}\n    pub fn into_byte_regex(self) -> re_bytes::Regex {}\n    pub fn into_byte_regex_set(self) -> re_set::bytes::RegexSet {}\n    pub fn regex_strings(&self) -> &[String] {}\n    pub fn capture_names(&self) -> &[Option<String>] {\n        &self.ro.nfa.captures\n    }\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {}\n}\n\nThe function to be tested is presented as follows:\n/// Return a slice of capture names.\n///\n/// Any capture that isn't named is None.\npub fn capture_names(&self) -> &[Option<String>] {\n    &self.ro.nfa.captures\n}\n",
  "depend_pt": ""
}