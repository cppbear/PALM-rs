{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/exec.rs\n// crate name is regex\npub type ProgramCache = RefCell<ProgramCacheInner>;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::cmp;\nuse std::sync::Arc;\nuse thread_local::CachedThreadLocal;\nuse syntax::ParserBuilder;\nuse syntax::hir::Hir;\nuse syntax::hir::literal::Literals;\nuse backtrack;\nuse compile::Compiler;\nuse dfa;\nuse error::Error;\nuse input::{ByteInput, CharInput};\nuse literal::LiteralSearcher;\nuse pikevm;\nuse prog::Program;\nuse re_builder::RegexOptions;\nuse re_bytes;\nuse re_set;\nuse re_trait::{RegularExpression, Slot, Locations, as_slots};\nuse re_unicode;\nuse utf8::next_utf8;\npub trait RegularExpression: Sized {\n    type Text: ?Sized;\n    fn slots_len(&self) -> usize;\n    fn locations(&self) -> Locations;\n    fn next_after_empty(&self, text: &Self::Text, i: usize) -> usize;\n    fn shortest_match_at(&self, text: &Self::Text, start: usize) -> Option<usize>;\n    fn is_match_at(&self, text: &Self::Text, start: usize) -> bool;\n    fn find_at(&self, text: &Self::Text, start: usize) -> Option<(usize, usize)>;\n    fn read_captures_at(\n        &self,\n        locs: &mut Locations,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<(usize, usize)>;\n    fn find_iter(self, text: &Self::Text) -> Matches<Self> {\n        Matches {\n            re: self,\n            text: text,\n            last_end: 0,\n            last_match: None,\n        }\n    }\n    fn captures_iter(self, text: &Self::Text) -> CaptureMatches<Self> {\n        CaptureMatches(self.find_iter(text))\n    }\n}\n#[derive(Debug)]\npub struct ExecNoSync<'c> {\n    /// All read only state.\n    ro: &'c Arc<ExecReadOnly>,\n    /// Caches for the various matching engines.\n    cache: &'c ProgramCache,\n}\n#[derive(Clone, Debug)]\npub struct LiteralSearcher {\n    complete: bool,\n    lcp: FreqyPacked,\n    lcs: FreqyPacked,\n    matcher: Matcher,\n}\n#[derive(Debug)]\nstruct ExecReadOnly {\n    /// The original regular expressions given by the caller to compile.\n    res: Vec<String>,\n    /// A compiled program that is used in the NFA simulation and backtracking.\n    /// It can be byte-based or Unicode codepoint based.\n    ///\n    /// N.B. It is not possibly to make this byte-based from the public API.\n    /// It is only used for testing byte based programs in the NFA simulations.\n    nfa: Program,\n    /// A compiled byte based program for DFA execution. This is only used\n    /// if a DFA can be executed. (Currently, only word boundary assertions are\n    /// not supported.) Note that this program contains an embedded `.*?`\n    /// preceding the first capture group, unless the regex is anchored at the\n    /// beginning.\n    dfa: Program,\n    /// The same as above, except the program is reversed (and there is no\n    /// preceding `.*?`). This is used by the DFA to find the starting location\n    /// of matches.\n    dfa_reverse: Program,\n    /// A set of suffix literals extracted from the regex.\n    ///\n    /// Prefix literals are stored on the `Program`, since they are used inside\n    /// the matching engines.\n    suffixes: LiteralSearcher,\n    /// match_type encodes as much upfront knowledge about how we're going to\n    /// execute a search as possible.\n    match_type: MatchType,\n}\n#[derive(Clone, Copy, Debug)]\nenum MatchLiteralType {\n    /// Match literals anywhere in text.\n    Unanchored,\n    /// Match literals only at the start of text.\n    AnchoredStart,\n    /// Match literals only at the end of text.\n    AnchoredEnd,\n}\nimpl<'c> ExecNoSync<'c> {\n    #[inline(always)]\n    fn find_literals(\n        &self,\n        ty: MatchLiteralType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        use self::MatchLiteralType::*;\n        match ty {\n            Unanchored => {\n                let lits = &self.ro.nfa.prefixes;\n                lits.find(&text[start..]).map(|(s, e)| (start + s, start + e))\n            }\n            AnchoredStart => {\n                let lits = &self.ro.nfa.prefixes;\n                if !self.ro.nfa.is_anchored_start\n                    || (self.ro.nfa.is_anchored_start && start == 0)\n                {\n                    lits.find_start(&text[start..]).map(|(s, e)| (start + s, start + e))\n                } else {\n                    None\n                }\n            }\n            AnchoredEnd => {\n                let lits = &self.ro.suffixes;\n                lits.find_end(&text[start..]).map(|(s, e)| (start + s, start + e))\n            }\n        }\n    }\n    #[inline(always)]\n    fn find_dfa_forward(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {}\n    #[inline(always)]\n    fn find_dfa_anchored_reverse(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {}\n    #[inline(always)]\n    fn shortest_dfa(&self, text: &[u8], start: usize) -> dfa::Result<usize> {}\n    #[inline(always)]\n    fn shortest_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<usize> {}\n    #[inline(always)]\n    fn exec_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        original_start: usize,\n    ) -> Option<dfa::Result<(usize, usize)>> {}\n    #[inline(always)]\n    fn find_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {}\n    fn match_nfa(&self, text: &[u8], start: usize) -> bool {}\n    fn match_nfa_type(&self, ty: MatchNfaType, text: &[u8], start: usize) -> bool {}\n    fn shortest_nfa(&self, text: &[u8], start: usize) -> Option<usize> {}\n    fn shortest_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize> {}\n    fn find_nfa(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    fn captures_nfa_with_match(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        match_start: usize,\n        match_end: usize,\n    ) -> Option<(usize, usize)> {}\n    fn captures_nfa(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    fn captures_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {}\n    fn exec_nfa(\n        &self,\n        mut ty: MatchNfaType,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    fn exec_pikevm(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    fn exec_backtrack(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    pub fn many_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: &[u8],\n        start: usize,\n    ) -> bool {}\n    #[inline(always)]\n    fn is_anchor_end_match(&self, text: &[u8]) -> bool {}\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {}\n}\nimpl LiteralSearcher {\n    pub fn empty() -> Self {\n        Self::new(Literals::empty(), Matcher::Empty)\n    }\n    pub fn prefixes(lits: Literals) -> Self {\n        let matcher = Matcher::prefixes(&lits);\n        Self::new(lits, matcher)\n    }\n    pub fn suffixes(lits: Literals) -> Self {\n        let matcher = Matcher::suffixes(&lits);\n        Self::new(lits, matcher)\n    }\n    fn new(lits: Literals, matcher: Matcher) -> Self {\n        let complete = lits.all_complete();\n        LiteralSearcher {\n            complete: complete,\n            lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n            lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n            matcher: matcher,\n        }\n    }\n    pub fn complete(&self) -> bool {}\n    #[inline(always)]\n    pub fn find(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => Some((0, 0)),\n            Bytes(ref sset) => sset.find(haystack).map(|i| (i, i + 1)),\n            FreqyPacked(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n            BoyerMoore(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n            AC(ref aut) => aut.find(haystack).next().map(|m| (m.start, m.end)),\n            TeddySSSE3(ref t) => t.find(haystack).map(|m| (m.start, m.end)),\n            TeddyAVX2(ref t) => t.find(haystack).map(|m| (m.start, m.end)),\n        }\n    }\n    pub fn find_start(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[0..lit.len()] {\n                return Some((0, lit.len()));\n            }\n        }\n        None\n    }\n    pub fn find_end(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[haystack.len() - lit.len()..] {\n                return Some((haystack.len() - lit.len(), haystack.len()));\n            }\n        }\n        None\n    }\n    pub fn iter(&self) -> LiteralIter {\n        match self.matcher {\n            Matcher::Empty => LiteralIter::Empty,\n            Matcher::Bytes(ref sset) => LiteralIter::Bytes(&sset.dense),\n            Matcher::FreqyPacked(ref s) => LiteralIter::Single(&s.pat),\n            Matcher::BoyerMoore(ref s) => LiteralIter::Single(&s.pattern),\n            Matcher::AC(ref ac) => LiteralIter::AC(ac.patterns()),\n            Matcher::TeddySSSE3(ref ted) => LiteralIter::TeddySSSE3(ted.patterns()),\n            Matcher::TeddyAVX2(ref ted) => LiteralIter::TeddyAVX2(ted.patterns()),\n        }\n    }\n    pub fn lcp(&self) -> &FreqyPacked {}\n    pub fn lcs(&self) -> &FreqyPacked {}\n    pub fn is_empty(&self) -> bool {}\n    pub fn len(&self) -> usize {}\n    pub fn approximate_size(&self) -> usize {}\n}\n\nThe function to be tested is presented as follows:\n/// Finds the leftmost-first match using only literal search.\nfn find_literals(\n    &self,\n    ty: MatchLiteralType,\n    text: &[u8],\n    start: usize,\n) -> Option<(usize, usize)> {\n    use self::MatchLiteralType::*;\n    match ty {\n        Unanchored => {\n            let lits = &self.ro.nfa.prefixes;\n            lits.find(&text[start..])\n                .map(|(s, e)| (start + s, start + e))\n        }\n        AnchoredStart => {\n            let lits = &self.ro.nfa.prefixes;\n            if !self.ro.nfa.is_anchored_start\n                || (self.ro.nfa.is_anchored_start && start == 0) {\n                lits.find_start(&text[start..])\n                    .map(|(s, e)| (start + s, start + e))\n            } else {\n                None\n            }\n        }\n        AnchoredEnd => {\n            let lits = &self.ro.suffixes;\n            lits.find_end(&text[start..])\n                .map(|(s, e)| (start + s, start + e))\n        }\n    }\n}\n",
  "depend_pt": ""
}