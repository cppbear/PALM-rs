{
  "name": "regex_syntax::ast::visitor::<ast::visitor::ClassInduct<'a> as std::fmt::Debug>::fmt",
  "name_with_impl": "regex_syntax::ast::visitor::{impl#5}::fmt",
  "mod_info": {
    "name": "ast::visitor",
    "loc": "regex-syntax/src/ast/mod.rs:23:1:23:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/ast/visitor.rs:527:5:556:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::BinaryOp(it) is true\n",
        "// constraint: it.kind matches ast::ClassSetBinaryOpKind::SymmetricDifference is true\n"
      ],
      "input_infer": "ClassInduct::BinaryOp(kind: ast::ClassSetBinaryOpKind::SymmetricDifference) with valid lhs and rhs ClassSet inputs\n",
      "answers": [
        {
          "uses": [
            "use ast::ClassSetBinaryOpKind;",
            "use ast::ClassSetBinaryOp;",
            "use ast::ClassSet;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSet, ClassSetBinaryOpKind, ClassSetBinaryOp};",
                "    ",
                "    let span = Span::new(0, 10); // Initialize with a valid span",
                "    let lhs = Box::new(ClassSet::new()); // Initialize a valid lhs ClassSet",
                "    let rhs = Box::new(ClassSet::new()); // Initialize a valid rhs ClassSet",
                "",
                "    let binary_op = ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                "        lhs,",
                "        rhs,",
                "    };",
                "",
                "    let induct = ClassInduct::BinaryOp(&binary_op);",
                "    ",
                "    let _ = fmt(&induct); // Call fmt with the constructed ClassInduct",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 10);",
                  "    let lhs = Box::new(ClassSet::new());",
                  "    let rhs = Box::new(ClassSet::new());",
                  "    let binary_op = ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs, rhs };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    assert_eq!(fmt(&induct).unwrap(), \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSet, ClassSetBinaryOpKind, ClassSetBinaryOp};",
                  "    ",
                  "    let span = Span::new(0, 10); // Initialize with a valid span",
                  "    let lhs = Box::new(ClassSet::new()); // Initialize a valid lhs ClassSet",
                  "    let rhs = Box::new(ClassSet::new()); // Initialize a valid rhs ClassSet",
                  "",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs,",
                  "        rhs,",
                  "    };",
                  "",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    ",
                  "    let _ = fmt(&induct); // Call fmt with the constructed ClassInduct",
                  "    let span = Span::new(0, 10);",
                  "    let lhs = Box::new(ClassSet::new());",
                  "    let rhs = Box::new(ClassSet::new());",
                  "    let binary_op = ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs, rhs };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    assert_eq!(fmt(&induct).unwrap(), \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span::new(0, 10); // Initialize with a valid span\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:16\n    |\n584 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:571:34\n    |\n571 |     let lhs = Box::new(ClassSet::new()); // Initialize a valid lhs ClassSet\n    |                                  ^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `new` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:34\n    |\n572 |     let rhs = Box::new(ClassSet::new()); // Initialize a valid rhs ClassSet\n    |                                  ^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `new` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct); // Call fmt with the constructed ClassInduct\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(); // Call fmt with the constructed ClassInduct\n    |             ~       ~~~~~~~\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:34\n    |\n585 |     let lhs = Box::new(ClassSet::new());\n    |                                  ^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `new` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:586:34\n    |\n586 |     let rhs = Box::new(ClassSet::new());\n    |                                  ^^^ variant or associated item not found in `ClassSet`\n    |\n   ::: regex-syntax/src/ast/mod.rs:930:1\n    |\n930 | pub enum ClassSet {\n    | ----------------- variant or associated item `new` not found for this enum\n    |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n   --> regex-syntax/src/ast/mod.rs:940:5\n    |\n940 |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:16\n    |\n589 |     assert_eq!(fmt(&induct).unwrap(), \"BinaryOp(SymmetricDifference)\");\n    |                ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     assert_eq!((&induct).fmt().unwrap(), \"BinaryOp(SymmetricDifference)\");\n    |                ~       ~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::BinaryOp(it) is true\n",
        "// constraint: it.kind matches ast::ClassSetBinaryOpKind::Difference is true\n",
        "// constraint: it.kind matches ast::ClassSetBinaryOpKind::Difference is true\n"
      ],
      "input_infer": "ClassInduct::BinaryOp with it.kind = ClassSetBinaryOpKind::Difference, lhs and rhs as valid ClassSet instances with at least one range or item each\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })],",
                "    });",
                "    let rhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })],",
                "    });",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ClassSetBinaryOpKind::Difference,",
                "        lhs,",
                "        rhs,",
                "    });",
                "    let _ = format!(\"{:?}\", binary_op);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 1 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = Box::new(ClassSet {",
                  "        items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })],",
                  "    });",
                  "    let rhs = Box::new(ClassSet {",
                  "        items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })],",
                  "    });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs,",
                  "        rhs,",
                  "    });",
                  "    let _ = format!(\"{:?}\", binary_op);",
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 1 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:24\n    |\n568 |     let lhs = Box::new(ClassSet {\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:21\n    |\n569 |         items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })],\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |         items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })],\n    |                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:24\n    |\n571 |     let rhs = Box::new(ClassSet {\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:572:21\n    |\n572 |         items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })],\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |         items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })],\n    |                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |                                           ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:15\n    |\n575 |         span: Span { start: 0, end: 1 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |         kind: ClassSetBinaryOpKind::Difference,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:24\n    |\n581 |     let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })] });\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:581:47\n    |\n581 |     let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })] });\n    |                                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:67\n    |\n581 |     let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })] });\n    |                                                                   ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:24\n    |\n582 |     let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })] });\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:582:47\n    |\n582 |     let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })] });\n    |                                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:67\n    |\n582 |     let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })] });\n    |                                                                   ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:43\n    |\n583 |     let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 1 }, kind: ClassSetBinaryOpKind::Difference, lhs...\n    |                                           ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:68\n    |\n583 |     let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 1 }, kind: ClassSetBinaryOpKind::Difference, lhs...\n    |                                                                    ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:583:101\n    |\n583 | ... Span { start: 0, end: 1 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Literal(Literal::new('a'))],",
                "    });",
                "    let rhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Literal(Literal::new('b'))],",
                "    });",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span: Span { start: 0, end: 2 },",
                "        kind: ClassSetBinaryOpKind::Difference,",
                "        lhs,",
                "        rhs,",
                "    });",
                "    let _ = format!(\"{:?}\", binary_op);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('a'))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('b'))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 2 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = Box::new(ClassSet {",
                  "        items: vec![ClassSetItem::Literal(Literal::new('a'))],",
                  "    });",
                  "    let rhs = Box::new(ClassSet {",
                  "        use ast::ClassSetItem; ",
                  "    });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span { start: 0, end: 2 },",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs,",
                  "        rhs,",
                  "    });",
                  "    let _ = format!(\"{:?}\", binary_op);",
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('a'))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('b'))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 2 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected identifier, found keyword `use`\n   --> regex-syntax/src/ast/visitor.rs:572:9\n    |\n571 |     let rhs = Box::new(ClassSet {\n    |                        -------- while parsing this struct\n572 |         use ast::ClassSetItem; \n    |         ^^^ expected identifier, found keyword\n\nerror: expected identifier or integer\n   --> regex-syntax/src/ast/visitor.rs:572:9\n    |\n572 |         use ast::ClassSetItem; \n    |         ^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/ast/visitor.rs:560:8\n    |\n560 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_fmt_02` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:1\n    |\n566 | / fn test_fmt_02()\n567 | | {\n568 | |     let lhs = Box::new(ClassSet {\n569 | |         items: vec![ClassSetItem::Literal(Literal::new('a'))],\n...   |\n584 | |     assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");\n585 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))],",
                "    });",
                "    let rhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))],",
                "    });",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span: Span { start: 0, end: 3 },",
                "        kind: ClassSetBinaryOpKind::Difference,",
                "        lhs,",
                "        rhs,",
                "    });",
                "    let _ = format!(\"{:?}\", binary_op);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 3 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = Box::new(ClassSet {",
                  "        items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))],",
                  "    });",
                  "    let rhs = Box::new(ClassSet {",
                  "        items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))],",
                  "    });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span { start: 0, end: 3 },",
                  "",
                  "        lhs,",
                  "        rhs,",
                  "    });",
                  "    let _ = format!(\"{:?}\", binary_op);",
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 3 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:24\n    |\n568 |     let lhs = Box::new(ClassSet {\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:21\n    |\n569 |         items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))],\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |         items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))],\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:24\n    |\n571 |     let rhs = Box::new(ClassSet {\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:572:21\n    |\n572 |         items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))],\n    |                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |         items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))],\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |                                           ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:15\n    |\n575 |         span: Span { start: 0, end: 3 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:24\n    |\n581 |     let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))] });\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:581:47\n    |\n581 |     let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))] });\n    |                                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:581:67\n    |\n581 |     let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))] });\n    |                                                                   ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:24\n    |\n582 |     let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))] });\n    |                        ^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:582:47\n    |\n582 |     let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))] });\n    |                                               ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:582:67\n    |\n582 |     let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))] });\n    |                                                                   ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:43\n    |\n583 |     let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 3 }, kind: ClassSetBinaryOpKind::Difference, lhs...\n    |                                           ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:68\n    |\n583 |     let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 3 }, kind: ClassSetBinaryOpKind::Difference, lhs...\n    |                                                                    ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:583:101\n    |\n583 | ... Span { start: 0, end: 3 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))],",
                "    });",
                "    let rhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))],",
                "    });",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span: Span { start: 0, end: 5 },",
                "        kind: ClassSetBinaryOpKind::Difference,",
                "        lhs,",
                "        rhs,",
                "    });",
                "    let _ = format!(\"{:?}\", binary_op);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 5 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = Box::new(ClassSet {",
                  "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))],",
                  "    });",
                  "    let rhs = Box::new(ClassSet {",
                  "        use ast::ClassAscii;  ",
                  "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))],  ",
                  "    });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span: Span { start: 0, end: 5 },",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs,",
                  "        rhs,",
                  "    });",
                  "    let _ = format!(\"{:?}\", binary_op);",
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 5 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected identifier, found keyword `use`\n   --> regex-syntax/src/ast/visitor.rs:572:9\n    |\n571 |     let rhs = Box::new(ClassSet {\n    |                        -------- while parsing this struct\n572 |         use ast::ClassAscii;  \n    |         ^^^ expected identifier, found keyword\n\nerror: expected identifier or integer\n   --> regex-syntax/src/ast/visitor.rs:572:9\n    |\n572 |         use ast::ClassAscii;  \n    |         ^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/ast/visitor.rs:560:8\n    |\n560 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_fmt_04` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:1\n    |\n566 | / fn test_fmt_04()\n567 | | {\n568 | |     let lhs = Box::new(ClassSet {\n569 | |         items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))],\n...   |\n585 | |     assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");\n586 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))],",
                "    });",
                "    let rhs = Box::new(ClassSet {",
                "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))],",
                "    });",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span: Span { start: 0, end: 6 },",
                "        kind: ClassSetBinaryOpKind::Difference,",
                "        lhs,",
                "        rhs,",
                "    });",
                "    let _ = format!(\"{:?}\", binary_op);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 6 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = Box::new(ClassSet {",
                  "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))],",
                  "    });",
                  "    let rhs = Box::new(ClassSet {",
                  "        use ast::Literal;",
                  "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))],",
                  "    });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs,",
                  "        rhs,",
                  "    });",
                  "    let _ = format!(\"{:?}\", binary_op);",
                  "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))] });",
                  "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))] });",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 6 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected identifier, found keyword `use`\n   --> regex-syntax/src/ast/visitor.rs:572:9\n    |\n571 |     let rhs = Box::new(ClassSet {\n    |                        -------- while parsing this struct\n572 |         use ast::Literal;\n    |         ^^^ expected identifier, found keyword\n\nerror: expected identifier or integer\n   --> regex-syntax/src/ast/visitor.rs:572:9\n    |\n572 |         use ast::Literal;\n    |         ^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/ast/visitor.rs:560:8\n    |\n560 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_fmt_05` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:1\n    |\n566 | / fn test_fmt_05()\n567 | | {\n568 | |     let lhs = Box::new(ClassSet {\n569 | |         items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))],\n...   |\n585 | |     assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");\n586 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::BinaryOp(it) is true\n",
        "// constraint: it.kind matches ast::ClassSetBinaryOpKind::Intersection is true\n",
        "// constraint: it.kind matches ast::ClassSetBinaryOpKind::Intersection is true\n"
      ],
      "input_infer": "ClassInduct::BinaryOp(ClassSetBinaryOp { kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSetItem::Union(...)), rhs: Box::new(ClassSetItem::Empty(...)) })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 10); // Initialize Span appropriately",
                "    let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![])); // Replace with actual initialization",
                "    let empty_item = ClassSetItem::Empty(span.clone());",
                "    ",
                "    let binary_op = ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(union_item),",
                "        rhs: Box::new(empty_item),",
                "    };",
                "    ",
                "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                "    ",
                "    let mut output = String::new();",
                "    class_induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 10);",
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let empty_item = ClassSetItem::Empty(span.clone());",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(union_item),",
                  "    rhs: Box::new(empty_item),",
                  "    };",
                  "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut output = String::new();",
                  "    class_induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"BinaryOp(Intersection)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 10); // Initialize Span appropriately",
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![])); // Replace with actual initialization",
                  "    let empty_item = ClassSetItem::Empty(span.clone());",
                  "    ",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(union_item),",
                  "        rhs: Box::new(empty_item),",
                  "    };",
                  "    ",
                  "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                  "    ",
                  "    let mut output = String::new();",
                  "    class_induct.fmt(&mut output).unwrap();",
                  "    let span = Span::new(0, 10);",
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let empty_item = ClassSetItem::Empty(span.clone());",
                  "    let binary_op = ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(union_item),",
                  "    rhs: Box::new(empty_item),",
                  "    };",
                  "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut output = String::new();",
                  "    class_induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"BinaryOp(Intersection)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:16\n    |\n568 |     let span = Span::new(0, 10); // Initialize Span appropriately\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:22\n    |\n569 |     let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![])); // Replace with actual initialization\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![])); // Replace with actual initialization\n    |                                          ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:22\n    |\n570 |     let empty_item = ClassSetItem::Empty(span.clone());\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:21\n    |\n572 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:574:15\n    |\n574 |         kind: ClassSetBinaryOpKind::Intersection,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:16\n    |\n583 |     let span = Span::new(0, 10);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:22\n    |\n584 |     let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:584:42\n    |\n584 |     let union_item = ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                          ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:22\n    |\n585 |     let empty_item = ClassSetItem::Empty(span.clone());\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:21\n    |\n586 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:588:11\n    |\n588 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     class_induct.fmt(&mut output).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n    |\n   ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:642:8\n    |\n642 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n    |        --- the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     class_induct.fmt(&mut output).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n    |\n   ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:642:8\n    |\n642 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n    |        --- the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 5); // Initialize Span appropriately",
                "    let union_item1 = ClassSetItem::Union(ClassSetUnion::new(vec![])); // Replace with actual initialization",
                "    let union_item2 = ClassSetItem::Union(ClassSetUnion::new(vec![])); // Replace with actual initialization",
                "    ",
                "    let binary_op = ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(union_item1),",
                "        rhs: Box::new(union_item2),",
                "    };",
                "    ",
                "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                "    ",
                "    let mut output = String::new();",
                "    class_induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 8); // Initialize Span appropriately",
                "    let literal_item = ClassSetItem::Literal(Literal::new('a')); // Replace with actual initialization",
                "    let empty_item = ClassSetItem::Empty(span.clone());",
                "    ",
                "    let binary_op = ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(literal_item),",
                "        rhs: Box::new(empty_item),",
                "    };",
                "    ",
                "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                "    ",
                "    let mut output = String::new();",
                "    class_induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 8);",
                  "    let literal_item = ClassSetItem::Literal(Literal::new('a'));",
                  "    let empty_item = ClassSetItem::Empty(span.clone());",
                  "    let binary_op = ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(literal_item), rhs: Box::new(empty_item) };",
                  "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut output = String::new();",
                  "    class_induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"BinaryOp(Intersection)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 8); // Initialize Span appropriately",
                  "    let literal_item = ClassSetItem::Literal(Literal::new('a')); // Replace with actual initialization",
                  "    let empty_item = ClassSetItem::Empty(span.clone());",
                  "    ",
                  "    let binary_op = ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(literal_item),",
                  "        rhs: Box::new(empty_item),",
                  "    };",
                  "    ",
                  "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                  "    ",
                  "    let mut output = String::new();",
                  "    class_induct.fmt(&mut output).unwrap();",
                  "    let span = Span::new(0, 8);",
                  "    let literal_item = ClassSetItem::Literal(Literal::new('a'));",
                  "    let empty_item = ClassSetItem::Empty(span.clone());",
                  "    let binary_op = ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(literal_item), rhs: Box::new(empty_item) };",
                  "    let class_induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut output = String::new();",
                  "    class_induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"BinaryOp(Intersection)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:16\n    |\n568 |     let span = Span::new(0, 8); // Initialize Span appropriately\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |     let literal_item = ClassSetItem::Literal(Literal::new('a')); // Replace with actual initialization\n    |                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:46\n    |\n569 |     let literal_item = ClassSetItem::Literal(Literal::new('a')); // Replace with actual initialization\n    |                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:22\n    |\n570 |     let empty_item = ClassSetItem::Empty(span.clone());\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:21\n    |\n572 |     let binary_op = ClassSetBinaryOp {\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:574:15\n    |\n574 |         kind: ClassSetBinaryOpKind::Intersection,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:16\n    |\n583 |     let span = Span::new(0, 8);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:24\n    |\n584 |     let literal_item = ClassSetItem::Literal(Literal::new('a'));\n    |                        ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:584:46\n    |\n584 |     let literal_item = ClassSetItem::Literal(Literal::new('a'));\n    |                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:585:22\n    |\n585 |     let empty_item = ClassSetItem::Empty(span.clone());\n    |                      ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:21\n    |\n586 |     let binary_op = ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(literal_item), rhs: Box::new(empty_i...\n    |                     ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:586:52\n    |\n586 |     let binary_op = ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(literal_item), rhs: Box::new(empty_i...\n    |                                                    ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     class_induct.fmt(&mut output).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n    |\n   ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:642:8\n    |\n642 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n    |        --- the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n589 |     class_induct.fmt(&mut output).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n    |\n   ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:642:8\n    |\n642 |     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n    |        --- the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Union(_) is true\n"
      ],
      "input_infer": "1 <= lhs <= 100, 1 <= rhs <= 100\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Empty)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Literal)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Range)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Ascii)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Perl)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Intersection;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Intersection;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Difference;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Difference)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Intersection;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Difference;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::SymmetricDifference;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Intersection;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    use ast::Span;  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Intersection;",
                  "",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Difference;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::new(1, 5));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::D);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Intersection;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::Difference;",
                  "",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let kind = ast::ClassSetBinaryOpKind::SymmetricDifference;",
                  "    let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };",
                  "    let induct = ClassInduct::BinaryOp(&binary_op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::D);\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::D);\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::D);\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:600:41\n    |\n600 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:603:13\n    |\n603 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n603 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::D);\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:600:41\n    |\n600 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:65\n    |\n605 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:97\n    |\n605 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:605:121\n    |\n605 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:603:13\n    |\n603 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n603 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:608:13\n    |\n608 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n608 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::D);\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:600:41\n    |\n600 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0425]: cannot find value `binary_op` in this scope\n   --> regex-syntax/src/ast/visitor.rs:606:41\n    |\n606 |     let induct = ClassInduct::BinaryOp(&binary_op);\n    |                                         ^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:610:65\n    |\n610 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:610:97\n    |\n610 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^^^^^^ -  - expected `Position`, found integer\n    |                                                   |\n    |                                                   expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:603:13\n    |\n603 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n603 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:608:13\n    |\n608 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n608 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/visitor.rs:610:121\n    |\n610 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                                         ^^^^^^^^^ -  - expected `Position`, found integer\n    |                                                                                                                                   |\n    |                                                                                                                                   expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:613:13\n    |\n613 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n613 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Empty(Span::new(1, 5));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:43\n    |\n576 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::D);\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:65\n    |\n605 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:97\n    |\n605 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:605:121\n    |\n605 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:615:65\n    |\n615 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:615:97\n    |\n615 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                 ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:615:121\n    |\n615 |     let binary_op = ast::ClassSetBinaryOp { kind, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()), span: Span::new(0, 1) };\n    |                                                                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:603:13\n    |\n603 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n603 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:608:13\n    |\n608 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n608 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:613:13\n    |\n613 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n613 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:618:13\n    |\n618 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n618 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Empty)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Range)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Ascii)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Perl)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(...)));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(..));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Empty(Span::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(...)));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  \n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |                                                   ~~\nhelp: or `..=` for an inclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..=));\n    |                                                   ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n576 -     let item = ast::ClassSetItem::Empty(Span::new(...));\n576 +     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  \n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:41\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433, E0586.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                                            ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));\n    |                                                            ~~\nhelp: or `..=` for an inclusive range\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..=));\n    |                                                            ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                                            ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n572 -     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n572 +     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |                                                   ~~\nhelp: or `..=` for an inclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..=));\n    |                                                   ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n576 -     let item = ast::ClassSetItem::Empty(Span::new(...));\n576 +     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:41\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));  \n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433, E0586.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |                                                            ~~\nhelp: or `..=` for an inclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..=));\n    |                                                            ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n580 -     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n580 +     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:584:57\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n    |                                                         ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(..));\n    |                                                         ~~\nhelp: or `..=` for an inclusive range\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(..=));\n    |                                                         ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:584:57\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n    |                                                         ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n584 -     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n584 +     let item = ast::ClassSetItem::Ascii(ClassAscii::new(..));\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:41\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433, E0586.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                                            ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));\n    |                                                            ~~\nhelp: or `..=` for an inclusive range\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..=));\n    |                                                            ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                                            ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n572 -     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n572 +     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |                                                   ~~\nhelp: or `..=` for an inclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..=));\n    |                                                   ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n576 -     let item = ast::ClassSetItem::Empty(Span::new(...));\n576 +     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |                                                            ~~\nhelp: or `..=` for an inclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..=));\n    |                                                            ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n580 -     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n580 +     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:41\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(..));  \n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..));  \n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433, E0586.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |                                                            ~~\nhelp: or `..=` for an inclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..=));\n    |                                                            ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n580 -     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n580 +     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:584:57\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n    |                                                         ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(..));\n    |                                                         ~~\nhelp: or `..=` for an inclusive range\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(..=));\n    |                                                         ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:584:57\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n    |                                                         ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n584 -     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n584 +     let item = ast::ClassSetItem::Ascii(ClassAscii::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:588:61\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n    |                                                             ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..));\n    |                                                             ~~\nhelp: or `..=` for an inclusive range\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..=));\n    |                                                             ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:588:61\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n    |                                                             ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n588 -     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n588 +     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:592:55\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n    |                                                       ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(..));\n    |                                                       ~~\nhelp: or `..=` for an inclusive range\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(..=));\n    |                                                       ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:592:55\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n    |                                                       ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n592 -     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n592 +     let item = ast::ClassSetItem::Perl(ClassPerl::new(..));\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  \n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:41\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..));  \n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:41\n    |\n584 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(...));\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433, E0586.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                                            ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));\n    |                                                            ~~\nhelp: or `..=` for an inclusive range\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..=));\n    |                                                            ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                                            ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n572 -     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n572 +     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |                                                   ~~\nhelp: or `..=` for an inclusive range\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(..=));\n    |                                                   ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:576:51\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                                   ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n576 -     let item = ast::ClassSetItem::Empty(Span::new(...));\n576 +     let item = ast::ClassSetItem::Empty(Span::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |                                                            ~~\nhelp: or `..=` for an inclusive range\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(..=));\n    |                                                            ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                                            ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n580 -     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n580 +     let item = ast::ClassSetItem::Range(ClassSetRange::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:588:61\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n    |                                                             ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..));\n    |                                                             ~~\nhelp: or `..=` for an inclusive range\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..=));\n    |                                                             ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:588:61\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n    |                                                             ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n588 -     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n588 +     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:592:55\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n    |                                                       ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(..));\n    |                                                       ~~\nhelp: or `..=` for an inclusive range\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(..=));\n    |                                                       ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:592:55\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n    |                                                       ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n592 -     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n592 +     let item = ast::ClassSetItem::Perl(ClassPerl::new(..));\n    |\n\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/visitor.rs:596:74\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(...)));\n    |                                                                          ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(..)));\n    |                                                                          ~~\nhelp: or `..=` for an inclusive range\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(..=)));\n    |                                                                          ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/visitor.rs:596:74\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(...)));\n    |                                                                          ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n596 -     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(...)));\n596 +     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(..)));\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:41\n    |\n576 |     let item = ast::ClassSetItem::Empty(Span::new(...));\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:41\n    |\n580 |     let item = ast::ClassSetItem::Range(ClassSetRange::new(...));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:588:43\n    |\n588 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(...));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:592:40\n    |\n592 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(...));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(...)));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:579:13\n    |\n579 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n579 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:591:13\n    |\n591 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n591 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433, E0586.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 27 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(...));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  ",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(..));  \n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"alnum\"));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"alnum\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:568:41\n    |\n568 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"alnum\"));\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:41\n    |\n572 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:568:43\n    |\n568 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:572:43\n    |\n572 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Literal)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Range)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Ascii)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");"
                ],
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketted(Box::new(ClassBracketed::new()));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketted(Box::new(ClassBracketed::new()));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:43\n    |\n573 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:43\n    |\n573 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:43\n    |\n573 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:581:41\n    |\n581 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:43\n    |\n573 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:581:41\n    |\n581 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:585:43\n    |\n585 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:588:13\n    |\n588 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n588 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let item = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\"));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:43\n    |\n573 |     let item = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:581:41\n    |\n581 |     let item = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"));\n    |                                         ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:585:43\n    |\n585 |     let item = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\"));\n    |                                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:589:55\n    |\n589 |     let item = ast::ClassSetItem::Bracketted(Box::new(ClassBracketed::new()));\n    |                                                       ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:588:13\n    |\n588 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n588 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `Bracketted` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:589:35\n    |\n589 |     let item = ast::ClassSetItem::Bracketted(Box::new(ClassBracketed::new()));\n    |                                   ^^^^^^^^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `Bracketted` not found for this enum\n    |\nhelp: there is a variant with a similar name\n    |\n589 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                   ~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:565:54\n    |\n565 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:569:54\n    |\n569 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:565:41\n    |\n565 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                         ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0423`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = ClassSet::new();",
                "    let rhs = ClassSet::new();",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(1, 5),",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(lhs),",
                "        rhs: Box::new(rhs),",
                "    };",
                "    let induct = ClassInduct::BinaryOp(&op);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(1, 5),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Intersection)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(1, 5),",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(1, 5),",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Intersection)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:565:15\n    |\n565 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:14\n    |\n567 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(1, 5),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::Intersection,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:15\n    |\n577 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:14\n    |\n578 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(1, 5),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     kind: ClassSetBinaryOpKind::Intersection,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = ClassSet::new();",
                "    let rhs = ClassSet::new();",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(5, 10),",
                "        kind: ClassSetBinaryOpKind::Difference,",
                "        lhs: Box::new(lhs),",
                "        rhs: Box::new(rhs),",
                "    };",
                "    let induct = ClassInduct::BinaryOp(&op);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Difference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(5, 10),",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(5, 10),",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(Difference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:565:15\n    |\n565 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:14\n    |\n567 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(5, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::Difference,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:15\n    |\n577 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:14\n    |\n578 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(5, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     kind: ClassSetBinaryOpKind::Difference,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let lhs = ClassSet::new();",
                "    let rhs = ClassSet::new();",
                "    let op = ClassSetBinaryOp {",
                "        span: Span::new(10, 20),",
                "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                "        lhs: Box::new(lhs),",
                "        rhs: Box::new(rhs),",
                "    };",
                "    let induct = ClassInduct::BinaryOp(&op);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(10, 20),",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "        span: Span::new(10, 20),",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let op = ClassSetBinaryOp {",
                  "    span: Span::new(10, 20),",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    };",
                  "    let induct = ClassInduct::BinaryOp(&op);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&induct, &mut buf);",
                  "    assert_eq!(buf, \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:565:15\n    |\n565 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:14\n    |\n567 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(10, 20),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n    |               ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:576:15\n    |\n576 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:15\n    |\n577 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:14\n    |\n578 |     let op = ClassSetBinaryOp {\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(10, 20),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n    |           ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&induct).fmt(&mut buf);\n    |             ~       ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Bracketed(_) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Bracketed(_) is true\n"
      ],
      "input_infer": "0 <= span.start <= 1000, 0 <= span.end <= 1000, kind in {Empty, Literal, Range, Ascii, Unicode, Perl, Bracketed, Union}, lhs != rhs, 1 <= lhs.elements.count <= 10, 1 <= rhs.elements.count <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let item = ast::ClassSetItem::Empty(span);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    assert_eq!(format!(\"{:?}\", induct), \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Empty(span);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
                  "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:41\n    |\n579 |     let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });\n    |                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:41\n    |\n579 |     let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });\n    |                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:43\n    |\n581 |     let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });\n    |                                           ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:41\n    |\n579 |     let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });\n    |                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:43\n    |\n581 |     let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });\n    |                                           ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:40\n    |\n583 |     let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:41\n    |\n579 |     let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });\n    |                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:43\n    |\n581 |     let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });\n    |                                           ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:40\n    |\n583 |     let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:41\n    |\n585 |     let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:41\n    |\n579 |     let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });\n    |                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:43\n    |\n581 |     let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });\n    |                                           ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:40\n    |\n583 |     let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:41\n    |\n585 |     let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0063]: missing fields `kind`, `lhs`, `rhs` and 1 other field in initializer of `ClassSetBinaryOp`\n   --> regex-syntax/src/ast/visitor.rs:587:44\n    |\n587 |     let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });\n    |                                            ^^^^^^^^^^^^^^^^^^^^^ missing `kind`, `lhs`, `rhs` and 1 other field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0063, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:41\n    |\n579 |     let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });\n    |                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:43\n    |\n581 |     let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });\n    |                                           ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:40\n    |\n583 |     let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:41\n    |\n585 |     let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0063]: missing fields `kind`, `lhs`, `rhs` and 1 other field in initializer of `ClassSetBinaryOp`\n   --> regex-syntax/src/ast/visitor.rs:587:44\n    |\n587 |     let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });\n    |                                            ^^^^^^^^^^^^^^^^^^^^^ missing `kind`, `lhs`, `rhs` and 1 other field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0063, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span { start: 0, end: 1 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:54\n    |\n571 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));\n    |                                                      ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:43\n    |\n575 |     let item = ast::ClassSetItem::Literal(Literal { /* fields */ });\n    |                                           ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassAscii` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:41\n    |\n579 |     let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });\n    |                                         ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:43\n    |\n581 |     let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });\n    |                                           ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:40\n    |\n583 |     let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:41\n    |\n585 |     let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });\n    |                                         ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n568 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0063]: missing fields `kind`, `lhs`, `rhs` and 1 other field in initializer of `ClassSetBinaryOp`\n   --> regex-syntax/src/ast/visitor.rs:587:44\n    |\n587 |     let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });\n    |                                            ^^^^^^^^^^^^^^^^^^^^^ missing `kind`, `lhs`, `rhs` and 1 other field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0063, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 2, end: 3 };",
                "    let literal = Literal::from('a');",
                "    let item = ast::ClassSetItem::Literal(literal);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    assert_eq!(result_empty, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    assert_eq!(result_range, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    assert_eq!(result_ascii, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    assert_eq!(result_unicode, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    assert_eq!(result_perl, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    assert_eq!(result_bracketed, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    assert_eq!(result_union, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    assert_eq!(result_binary_op_intersection, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    assert_eq!(result_binary_op_difference, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
                  "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
                  "    assert_eq!(result_binary_op_sym_difference, Ok(()));"
                ],
                [
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
                  "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    assert_eq!(result_empty, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    assert_eq!(result_range, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    assert_eq!(result_ascii, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    assert_eq!(result_unicode, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    assert_eq!(result_perl, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    assert_eq!(result_bracketed, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    assert_eq!(result_union, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    assert_eq!(result_binary_op_intersection, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    assert_eq!(result_binary_op_difference, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
                  "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
                  "    assert_eq!(result_binary_op_sym_difference, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 2, end: 3 };",
                  "    let literal = Literal::from('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    let result_empty = induct_empty.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    let result_range = induct_range.fmt(&mut formatter);",
                  "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
                  "    let induct_ascii = ClassInduct::Item(&item_ascii);",
                  "    let result_ascii = induct_ascii.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    let result_unicode = induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    let result_perl = induct_perl.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    let result_union = induct_union.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
                  "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
                  "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:577:26\n    |\n577 |     assert_eq!(formatter.to_string(), \"Item(Literal)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     assert_eq!(formatter.to_string(), \"Item(Empty)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:583:26\n    |\n583 |     assert_eq!(formatter.to_string(), \"Item(Range)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:586:26\n    |\n586 |     assert_eq!(formatter.to_string(), \"Item(Ascii)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:589:26\n    |\n589 |     assert_eq!(formatter.to_string(), \"Item(Unicode)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:592:26\n    |\n592 |     assert_eq!(formatter.to_string(), \"Item(Perl)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:595:26\n    |\n595 |     assert_eq!(formatter.to_string(), \"Item(Bracketed)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:598:26\n    |\n598 |     assert_eq!(formatter.to_string(), \"Item(Union)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:71\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);\n    |                                                                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 27 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:71\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);\n    |                                                                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:601:26\n    |\n601 |     assert_eq!(formatter.to_string(), \"BinaryOp(Intersection)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:121\n    |\n601 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:153\n    |\n601 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:71\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);\n    |                                                                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:603:67\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n603 |     let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);\n    |                                                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:121\n    |\n601 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:153\n    |\n601 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:71\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);\n    |                                                                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:603:67\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n603 |     let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);\n    |                                                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:604:26\n    |\n604 |     assert_eq!(formatter.to_string(), \"BinaryOp(Difference)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:121\n    |\n601 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:153\n    |\n601 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:134\n    |\n604 | ...aryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:166\n    |\n604 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:71\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);\n    |                                                                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:603:67\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n603 |     let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);\n    |                                                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:606:75\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n606 |     let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);\n    |                                                                           ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 33 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 2, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal::from('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:580:47\n    |\n580 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:595:47\n    |\n595 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:121\n    |\n601 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:153\n    |\n601 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:134\n    |\n604 | ...aryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:166\n    |\n604 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     let result_empty = induct_empty.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     let result_range = induct_range.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     let result_ascii = induct_ascii.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:41\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     let result_unicode = induct_unicode.fmt(&mut formatter);\n    |                                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:35\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     let result_perl = induct_perl.fmt(&mut formatter);\n    |                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:45\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     let result_bracketed = induct_bracketed.fmt(&mut formatter);\n    |                                             ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:37\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     let result_union = induct_union.fmt(&mut formatter);\n    |                                     ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:71\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);\n    |                                                                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:603:67\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n603 |     let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);\n    |                                                                   ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:606:75\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n606 |     let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);\n    |                                                                           ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:607:26\n    |\n607 |     assert_eq!(formatter.to_string(), \"BinaryOp(SymmetricDifference)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 4, end: 5 };",
                "    let range = ClassSetRange::new('a', 'z');",
                "    let item = ast::ClassSetItem::Range(range);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(induct.fmt(&mut formatter).is_ok(), true);"
                ],
                [
                  "    let span = Span { start: 4, end: 5 };",
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Range(range);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(induct.fmt(&mut formatter).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Range(range);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 4, end: 5 };",
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 4, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let range = ClassSetRange::new('a', 'z');\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 4, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let range = ClassSetRange::new('a', 'z');\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:573:54\n    |\n573 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     assert_eq!(induct.fmt(&mut formatter).is_ok(), true);\n    |                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 4, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let range = ClassSetRange::new('a', 'z');\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 4, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let range = ClassSetRange::new('a', 'z');\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:573:54\n    |\n573 |     let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));\n    |                                                      ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |     assert_eq!(formatter.to_string(), \"Item(Bracketed)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 6, end: 7 };",
                "    let ascii = ClassAscii::Alphanumeric;",
                "    let item = ast::ClassSetItem::Ascii(ascii);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    induct_binary_intersection.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    induct_binary_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    induct_binary_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    induct_binary_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    induct_binary_difference.fmt(&mut formatter);",
                  "    let binary_op_symmetric_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_symmetric_difference = ClassInduct::BinaryOp(&binary_op_symmetric_difference);",
                  "    induct_binary_symmetric_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    induct_binary_intersection.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    induct_binary_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    induct_binary_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 6, end: 7 };",
                  "    let ascii = ClassAscii::Alphanumeric;",
                  "    let item = ast::ClassSetItem::Ascii(ascii);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let item_empty = ast::ClassSetItem::Empty(span);",
                  "    let induct_empty = ClassInduct::Item(&item_empty);",
                  "    induct_empty.fmt(&mut formatter);",
                  "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
                  "    let induct_literal = ClassInduct::Item(&item_literal);",
                  "    induct_literal.fmt(&mut formatter);",
                  "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&item_range);",
                  "    induct_range.fmt(&mut formatter);",
                  "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
                  "    let induct_unicode = ClassInduct::Item(&item_unicode);",
                  "    induct_unicode.fmt(&mut formatter);",
                  "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
                  "    let induct_perl = ClassInduct::Item(&item_perl);",
                  "    induct_perl.fmt(&mut formatter);",
                  "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let induct_union = ClassInduct::Item(&item_union);",
                  "    induct_union.fmt(&mut formatter);",
                  "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
                  "    induct_bracketed.fmt(&mut formatter);",
                  "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
                  "    induct_binary_intersection.fmt(&mut formatter);",
                  "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
                  "    induct_binary_difference.fmt(&mut formatter);",
                  "    let binary_op_symmetric_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
                  "    let induct_binary_symmetric_difference = ClassInduct::BinaryOp(&binary_op_symmetric_difference);",
                  "    induct_binary_symmetric_difference.fmt(&mut formatter);",
                  "    assert_eq!(formatter.output(), \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:26\n    |\n577 |     assert_eq!(formatter.output(), \"Item(Ascii)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     assert_eq!(formatter.output(), \"Item(Empty)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:583:26\n    |\n583 |     assert_eq!(formatter.output(), \"Item(Literal)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:586:26\n    |\n586 |     assert_eq!(formatter.output(), \"Item(Range)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     induct_unicode.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:589:26\n    |\n589 |     assert_eq!(formatter.output(), \"Item(Unicode)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     induct_unicode.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     induct_perl.fmt(&mut formatter);\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:592:26\n    |\n592 |     assert_eq!(formatter.output(), \"Item(Perl)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:592:47\n    |\n592 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     induct_unicode.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     induct_perl.fmt(&mut formatter);\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_union.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:595:26\n    |\n595 |     assert_eq!(formatter.output(), \"Item(Union)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:592:47\n    |\n592 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:595:64\n    |\n595 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     induct_unicode.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     induct_perl.fmt(&mut formatter);\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_union.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:22\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     induct_bracketed.fmt(&mut formatter);\n    |                      ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:598:26\n    |\n598 |     assert_eq!(formatter.output(), \"Item(Bracketed)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:592:47\n    |\n592 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:595:64\n    |\n595 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     induct_unicode.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     induct_perl.fmt(&mut formatter);\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_union.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:22\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     induct_bracketed.fmt(&mut formatter);\n    |                      ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:32\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     induct_binary_intersection.fmt(&mut formatter);\n    |                                ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:601:26\n    |\n601 |     assert_eq!(formatter.output(), \"BinaryOp(Intersection)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:592:47\n    |\n592 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:595:64\n    |\n595 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:121\n    |\n601 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:153\n    |\n601 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     induct_unicode.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     induct_perl.fmt(&mut formatter);\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_union.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:22\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     induct_bracketed.fmt(&mut formatter);\n    |                      ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:32\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     induct_binary_intersection.fmt(&mut formatter);\n    |                                ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:603:30\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n603 |     induct_binary_difference.fmt(&mut formatter);\n    |                              ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:604:26\n    |\n604 |     assert_eq!(formatter.output(), \"BinaryOp(Difference)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 6, end: 7 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let ascii = ClassAscii::Alphanumeric;\n    |                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:51\n    |\n586 |     let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:589:45\n    |\n589 |     let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:592:47\n    |\n592 |     let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:595:64\n    |\n595 |     let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:125\n    |\n598 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:598:157\n    |\n598 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:121\n    |\n601 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:601:153\n    |\n601 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:140\n    |\n604 | ...aryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:604:172\n    |\n604 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n579 |     induct_empty.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_literal.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:585:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n585 |     induct_range.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:588:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n588 |     induct_unicode.fmt(&mut formatter);\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:591:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n591 |     induct_perl.fmt(&mut formatter);\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_union.fmt(&mut formatter);\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:597:22\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n597 |     induct_bracketed.fmt(&mut formatter);\n    |                      ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:600:32\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n600 |     induct_binary_intersection.fmt(&mut formatter);\n    |                                ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:603:30\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n603 |     induct_binary_difference.fmt(&mut formatter);\n    |                              ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:606:40\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n606 |     induct_binary_symmetric_difference.fmt(&mut formatter);\n    |                                        ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:607:26\n    |\n607 |     assert_eq!(formatter.output(), \"BinaryOp(SymmetricDifference)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 8, end: 9 };",
                "    let unicode = ClassUnicode::new(\"L\");",
                "    let item = ast::ClassSetItem::Unicode(unicode);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 8, end: 9 };",
                  "    let unicode = ClassUnicode::new(\"L\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 8, end: 9 };",
                  "    let unicode = ClassUnicode::new(\"L\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 8, end: 9 };",
                  "    let unicode = ClassUnicode::new(\"L\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 8, end: 9 };",
                  "    let unicode = ClassUnicode::new(\"L\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 8, end: 9 };",
                  "    let unicode = ClassUnicode::new(\"L\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 8, end: 9 };",
                  "    let unicode = ClassUnicode::new(\"L\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 8, end: 9 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let unicode = ClassUnicode::new(\"L\");\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 8, end: 9 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let unicode = ClassUnicode::new(\"L\");\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 8, end: 9 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let unicode = ClassUnicode::new(\"L\");\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 8, end: 9 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let unicode = ClassUnicode::new(\"L\");\n    |                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:577:26\n    |\n577 |     assert_eq!(formatter.to_string(), \"Item(Unicode)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 10, end: 11 };",
                "    let perl = ClassPerl::Digit;",
                "    let item = ast::ClassSetItem::Perl(perl);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 10, end: 11 };",
                  "    let perl = ClassPerl::Digit;",
                  "    let item = ast::ClassSetItem::Perl(perl);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(formatter.to_string(), \"Item(Perl)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 10, end: 11 };",
                  "    let perl = ClassPerl::Digit;",
                  "    let item = ast::ClassSetItem::Perl(perl);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 10, end: 11 };",
                  "    let perl = ClassPerl::Digit;",
                  "    let item = ast::ClassSetItem::Perl(perl);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(formatter.to_string(), \"Item(Perl)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 10, end: 11 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:566:16\n    |\n566 |     let perl = ClassPerl::Digit;\n    |                ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 10, end: 11 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:572:16\n    |\n572 |     let perl = ClassPerl::Digit;\n    |                ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:577:26\n    |\n577 |     assert_eq!(formatter.to_string(), \"Item(Perl)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 12, end: 13 };",
                "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
                "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 12, end: 13 };",
                  "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 12, end: 13 };",
                  "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 12, end: 13 };",
                  "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 12, end: 13 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:566:21\n    |\n566 |     let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);\n    |                     ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:73\n    |\n566 |     let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);\n    |                                                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 12, end: 13 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:572:21\n    |\n572 |     let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);\n    |                     ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:73\n    |\n572 |     let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);\n    |                                                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:577:26\n    |\n577 |     assert_eq!(formatter.to_string(), \"Item(Bracketed)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 14, end: 15 };",
                "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
                "    let item = ast::ClassSetItem::Union(union);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    induct.fmt(&mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 14, end: 15 };",
                  "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: 14, end: 15 };",
                  "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 14, end: 15 };",
                  "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 14, end: 15 };",
                  "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 14, end: 15 };",
                  "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    induct.fmt(&mut formatter);",
                  "    let span = Span { start: 14, end: 15 };",
                  "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = induct.fmt(&mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 14, end: 15 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:68\n    |\n566 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 14, end: 15 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:68\n    |\n572 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 14, end: 15 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:68\n    |\n566 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span { start: 14, end: 15 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:572:17\n    |\n572 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:68\n    |\n572 |     let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);\n    |                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n570 |     induct.fmt(&mut formatter);\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:575:25\n    |\n575 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n575 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:576:25\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n576 |     let result = induct.fmt(&mut formatter);\n    |                         ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:577:26\n    |\n577 |     assert_eq!(formatter.to_string(), \"Item(Union)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Perl(_) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Perl(_) is true\n"
      ],
      "input_infer": "ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::SomeVariant)) where ClassPerl::SomeVariant represents a valid variant of ClassPerl\n",
      "answers": [
        {
          "uses": [
            "use ast::ClassAscii;",
            "use ast::Literal;",
            "use ast::ClassSetUnion;",
            "use ast::ClassSetRange;",
            "use ast::ClassUnicode;",
            "use ast::ClassSetItem;",
            "use ast::Span;",
            "use ast::ClassPerl;",
            "use ast::ClassBracketed;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassPerl};",
                "",
                "    let perl_item = ClassSetItem::Perl(ClassPerl::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                "    let class_induct = ClassInduct::Item(&perl_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let perl_item = ClassSetItem::Perl(ClassPerl::SomeVariant);",
                  "    assert_eq!(format!(\"{:?}\", class_induct), \"Item(Perl)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassPerl};",
                  "",
                  "    let perl_item = ClassSetItem::Perl(ClassPerl::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&perl_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let perl_item = ClassSetItem::Perl(ClassPerl::SomeVariant);",
                  "    assert_eq!(format!(\"{:?}\", class_induct), \"Item(Perl)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassPerl` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:51\n    |\n567 |     let perl_item = ClassSetItem::Perl(ClassPerl::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n    |                                                   ^^^^^^^^^^^ associated item not found in `ClassPerl`\n    |\n   ::: regex-syntax/src/ast/mod.rs:739:1\n    |\n739 | pub struct ClassPerl {\n    | -------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassPerl` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:51\n    |\n572 |     let perl_item = ClassSetItem::Perl(ClassPerl::SomeVariant);\n    |                                                   ^^^^^^^^^^^ associated item not found in `ClassPerl`\n    |\n   ::: regex-syntax/src/ast/mod.rs:739:1\n    |\n739 | pub struct ClassPerl {\n    | -------------------- associated item `SomeVariant` not found for this struct\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span};",
                "",
                "    let empty_item = ClassSetItem::Empty(Span::new(0, 1)); // Assuming Span has a method `new` for initialization.",
                "    let class_induct = ClassInduct::Item(&empty_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let empty_item = ClassSetItem::Empty(Span::new(0, 1));",
                  "    let class_induct = ClassInduct::Item(&empty_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let empty_item = ClassSetItem::Empty(Span::new(0, 1));",
                  "    let class_induct = ClassInduct::Item(&empty_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Empty)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span};",
                  "",
                  "    let empty_item = ClassSetItem::Empty(Span::new(0, 1)); // Assuming Span has a method `new` for initialization.",
                  "    let class_induct = ClassInduct::Item(&empty_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let empty_item = ClassSetItem::Empty(Span::new(0, 1));",
                  "    let class_induct = ClassInduct::Item(&empty_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span};",
                  "",
                  "    let empty_item = ClassSetItem::Empty(Span::new(0, 1)); // Assuming Span has a method `new` for initialization.",
                  "    let class_induct = ClassInduct::Item(&empty_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let empty_item = ClassSetItem::Empty(Span::new(0, 1));",
                  "    let class_induct = ClassInduct::Item(&empty_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Empty)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/visitor.rs:567:42\n    |\n567 |     let empty_item = ClassSetItem::Empty(Span::new(0, 1)); // Assuming Span has a method `new` for initialization.\n    |                                          ^^^^^^^^^ -  - expected `Position`, found integer\n    |                                                    |\n    |                                                    expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/visitor.rs:572:42\n    |\n572 |     let empty_item = ClassSetItem::Empty(Span::new(0, 1));\n    |                                          ^^^^^^^^^ -  - expected `Position`, found integer\n    |                                                    |\n    |                                                    expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0423, E0432, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/visitor.rs:567:42\n    |\n567 |     let empty_item = ClassSetItem::Empty(Span::new(0, 1)); // Assuming Span has a method `new` for initialization.\n    |                                          ^^^^^^^^^ -  - expected `Position`, found integer\n    |                                                    |\n    |                                                    expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/visitor.rs:572:42\n    |\n572 |     let empty_item = ClassSetItem::Empty(Span::new(0, 1));\n    |                                          ^^^^^^^^^ -  - expected `Position`, found integer\n    |                                                    |\n    |                                                    expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |     assert_eq!(formatter.to_string(), \"Item(Empty)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Literal};",
                "",
                "    let literal_item = ClassSetItem::Literal(Literal::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                "    let class_induct = ClassInduct::Item(&literal_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let literal_item = ClassSetItem::Literal(Literal::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&literal_item);",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));"
                ],
                [
                  "    let literal_item = ClassSetItem::Literal(Literal::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&literal_item);",
                  "    assert_eq!(formatter.to_string(), \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Literal};",
                  "",
                  "    let literal_item = ClassSetItem::Literal(Literal::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&literal_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let literal_item = ClassSetItem::Literal(Literal::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&literal_item);",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Literal};",
                  "",
                  "    let literal_item = ClassSetItem::Literal(Literal::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&literal_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let literal_item = ClassSetItem::Literal(Literal::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&literal_item);",
                  "    assert_eq!(formatter.to_string(), \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:55\n    |\n567 |     let literal_item = ClassSetItem::Literal(Literal::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n    |                                                       ^^^^^^^^^^^ associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:55\n    |\n572 |     let literal_item = ClassSetItem::Literal(Literal::SomeVariant);\n    |                                                       ^^^^^^^^^^^ associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:574:16\n    |\n574 |     assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));\n    |                ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n574 |     assert_eq!((&class_induct).fmt(&mut formatter), Ok(()));\n    |                ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:55\n    |\n567 |     let literal_item = ClassSetItem::Literal(Literal::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n    |                                                       ^^^^^^^^^^^ associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:55\n    |\n572 |     let literal_item = ClassSetItem::Literal(Literal::SomeVariant);\n    |                                                       ^^^^^^^^^^^ associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     assert_eq!(formatter.to_string(), \"Item(Literal)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassSetRange};",
                "",
                "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                "    let class_induct = ClassInduct::Item(&range_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Range)\");"
                ],
                [
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert!(formatter.to_string().contains(\"Item(Range)\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange};",
                  "",
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange};",
                  "",
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange};",
                  "",
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&range_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert!(formatter.to_string().contains(\"Item(Range)\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetRange` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:567:57\n     |\n567  |     let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetRange`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetRange` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:572:57\n     |\n572  |     let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetRange`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetRange` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:567:57\n     |\n567  |     let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetRange`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetRange` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:572:57\n     |\n572  |     let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetRange`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |     assert_eq!(formatter.to_string(), \"Item(Range)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetRange` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:567:57\n     |\n567  |     let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetRange`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetRange` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:572:57\n     |\n572  |     let range_item = ClassSetItem::Range(ClassSetRange::SomeVariant);\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetRange`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1006:1\n     |\n1006 | pub struct ClassSetRange {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     assert!(formatter.to_string().contains(\"Item(Range)\"));\n    |                       ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassAscii};",
                "",
                "    let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                "    let class_induct = ClassInduct::Item(&ascii_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&ascii_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&ascii_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassAscii};",
                  "",
                  "    let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&ascii_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&ascii_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassAscii};",
                  "",
                  "    let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&ascii_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&ascii_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassAscii` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:54\n    |\n567 |     let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n    |                                                      ^^^^^^^^^^^ associated item not found in `ClassAscii`\n    |\n   ::: regex-syntax/src/ast/mod.rs:762:1\n    |\n762 | pub struct ClassAscii {\n    | --------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassAscii` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:54\n    |\n572 |     let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant);\n    |                                                      ^^^^^^^^^^^ associated item not found in `ClassAscii`\n    |\n   ::: regex-syntax/src/ast/mod.rs:762:1\n    |\n762 | pub struct ClassAscii {\n    | --------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassAscii` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:54\n    |\n567 |     let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n    |                                                      ^^^^^^^^^^^ associated item not found in `ClassAscii`\n    |\n   ::: regex-syntax/src/ast/mod.rs:762:1\n    |\n762 | pub struct ClassAscii {\n    | --------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassAscii` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:54\n    |\n572 |     let ascii_item = ClassSetItem::Ascii(ClassAscii::SomeVariant);\n    |                                                      ^^^^^^^^^^^ associated item not found in `ClassAscii`\n    |\n   ::: regex-syntax/src/ast/mod.rs:762:1\n    |\n762 | pub struct ClassAscii {\n    | --------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |     assert_eq!(formatter.to_string(), \"Item(Ascii)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassUnicode};",
                "",
                "    let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                "    let class_induct = ClassInduct::Item(&unicode_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));"
                ],
                [
                  "    let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassUnicode};",
                  "",
                  "    let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassUnicode};",
                  "",
                  "    let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::ClassUnicode` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:60\n    |\n567 |     let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n    |                                                            ^^^^^^^^^^^ associated item not found in `ClassUnicode`\n    |\n   ::: regex-syntax/src/ast/mod.rs:837:1\n    |\n837 | pub struct ClassUnicode {\n    | ----------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::ClassUnicode` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant);\n    |                                                            ^^^^^^^^^^^ associated item not found in `ClassUnicode`\n    |\n   ::: regex-syntax/src/ast/mod.rs:837:1\n    |\n837 | pub struct ClassUnicode {\n    | ----------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:574:16\n    |\n574 |     assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));\n    |                ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n574 |     assert_eq!((&class_induct).fmt(&mut formatter), Ok(()));\n    |                ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::ClassUnicode` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:60\n    |\n567 |     let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n    |                                                            ^^^^^^^^^^^ associated item not found in `ClassUnicode`\n    |\n   ::: regex-syntax/src/ast/mod.rs:837:1\n    |\n837 | pub struct ClassUnicode {\n    | ----------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ast::ClassUnicode` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:60\n    |\n572 |     let unicode_item = ClassSetItem::Unicode(ClassUnicode::SomeVariant);\n    |                                                            ^^^^^^^^^^^ associated item not found in `ClassUnicode`\n    |\n   ::: regex-syntax/src/ast/mod.rs:837:1\n    |\n837 | pub struct ClassUnicode {\n    | ----------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     assert_eq!(formatter.to_string(), \"Item(Unicode)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassBracketed};",
                "",
                "    let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant)); // Replace SomeVariant with an actual variant if needed.",
                "    let class_induct = ClassInduct::Item(&bracketed_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant));",
                  "    let class_induct = ClassInduct::Item(&bracketed_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant));",
                  "    let class_induct = ClassInduct::Item(&bracketed_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassBracketed};",
                  "",
                  "    let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant)); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&bracketed_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant));",
                  "    let class_induct = ClassInduct::Item(&bracketed_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassBracketed};",
                  "",
                  "    let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant)); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&bracketed_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant));",
                  "    let class_induct = ClassInduct::Item(&bracketed_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:75\n    |\n567 |     let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant)); // Replace SomeVariant with an actual variant if...\n    |                                                                           ^^^^^^^^^^^ associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:75\n    |\n572 |     let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant));\n    |                                                                           ^^^^^^^^^^^ associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:75\n    |\n567 |     let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant)); // Replace SomeVariant with an actual variant if...\n    |                                                                           ^^^^^^^^^^^ associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:75\n    |\n572 |     let bracketed_item = ClassSetItem::Bracketed(Box::new(ClassBracketed::SomeVariant));\n    |                                                                           ^^^^^^^^^^^ associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |     assert_eq!(formatter.to_string(), \"Item(Bracketed)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassSetUnion};",
                "",
                "    let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                "    let class_induct = ClassInduct::Item(&union_item);",
                "    let mut formatter = std::fmt::Formatter::new();",
                "    ",
                "    let _ = fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&union_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));"
                ],
                [
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&union_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetUnion};",
                  "",
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&union_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&union_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetUnion};",
                  "",
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant); // Replace SomeVariant with an actual variant if needed.",
                  "    let class_induct = ClassInduct::Item(&union_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    ",
                  "    let _ = fmt(&class_induct, &mut formatter);",
                  "    let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant);",
                  "    let class_induct = ClassInduct::Item(&union_item);",
                  "    let mut formatter = std::fmt::Formatter::new();",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:567:57\n     |\n567  |     let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:572:57\n     |\n572  |     let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant);\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:16\n    |\n575 |     assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));\n    |                ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     assert_eq!((&class_induct).fmt(&mut formatter), Ok(()));\n    |                ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:567:57\n     |\n567  |     let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant); // Replace SomeVariant with an actual variant if needed.\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:569:25\n    |\n569 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n569 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&class_induct, &mut formatter);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&class_induct).fmt(&mut formatter);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no associated item named `SomeVariant` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:572:57\n     |\n572  |     let union_item = ClassSetItem::Union(ClassSetUnion::SomeVariant);\n     |                                                         ^^^^^^^^^^^ associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ associated item `SomeVariant` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:574:25\n    |\n574 |     let mut formatter = std::fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n574 |     let mut formatter = std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |     assert_eq!(formatter.to_string(), \"Item(Union)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Unicode(_) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Unicode(_) is true\n"
      ],
      "input_infer": "Test input ranges: ClassInduct::Item(it) where it matches ast::ClassSetItem::Unicode(ClassUnicode::UnicodeType) with UnicodeType values ranging from valid character classes such as \"\\pL\", \"\\p{Greek}\" to potentially undefined or invalid Unicode values to test panic conditions.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));",
                "    let class_induct = ClassInduct::Item(&unicode_item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&class_induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode_item_invalid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct_invalid = ClassInduct::Item(&unicode_item_invalid);",
                  "    let mut buf_invalid = String::new();",
                  "    let result_invalid = fmt(&class_induct_invalid, &mut buf_invalid);",
                  "    assert!(result_invalid.is_err());"
                ],
                [
                  "    let unicode_item_invalid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct_invalid = ClassInduct::Item(&unicode_item_invalid);",
                  "    let mut buf_invalid = String::new();",
                  "    let result_invalid = fmt(&class_induct_invalid, &mut buf_invalid);",
                  "    let unicode_item_valid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));",
                  "    let class_induct_valid = ClassInduct::Item(&unicode_item_valid);",
                  "    let mut buf_valid = String::new();",
                  "    let _ = fmt(&class_induct_valid, &mut buf_valid);",
                  "    assert_eq!(buf_valid, \"Item(Unicode)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[should_panic]",
                  "fn test_class_induct_unicode_invalid() {",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "}",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "    let unicode_item_invalid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct_invalid = ClassInduct::Item(&unicode_item_invalid);",
                  "    let mut buf_invalid = String::new();",
                  "    let result_invalid = fmt(&class_induct_invalid, &mut buf_invalid);",
                  "    assert!(result_invalid.is_err());",
                  "}"
                ],
                [
                  "{",
                  "#[should_panic]",
                  "fn test_class_induct_unicode_invalid() {",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "}",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "    let unicode_item_invalid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct_invalid = ClassInduct::Item(&unicode_item_invalid);",
                  "    let mut buf_invalid = String::new();",
                  "    let result_invalid = fmt(&class_induct_invalid, &mut buf_invalid);",
                  "    let unicode_item_valid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));",
                  "    let class_induct_valid = ClassInduct::Item(&unicode_item_valid);",
                  "    let mut buf_valid = String::new();",
                  "    let _ = fmt(&class_induct_valid, &mut buf_valid);",
                  "    assert_eq!(buf_valid, \"Item(Unicode)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:85\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:564:51\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:567:13\n    |\n567 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n567 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:573:51\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:577:59\n    |\n577 |     let unicode_item_invalid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n577 |     let unicode_item_invalid = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     let result_invalid = fmt(&class_induct_invalid, &mut buf_invalid);\n    |                          ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let result_invalid = (&class_induct_invalid).fmt(&mut buf_invalid);\n    |                          ~                     ~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0223, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0223`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:85\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:91\n    |\n581 |     let unicode_item_valid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                                                           ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:564:51\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:567:13\n    |\n567 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n567 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:573:51\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:577:59\n    |\n577 |     let unicode_item_invalid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n577 |     let unicode_item_invalid = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:26\n    |\n580 |     let result_invalid = fmt(&class_induct_invalid, &mut buf_invalid);\n    |                          ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let result_invalid = (&class_induct_invalid).fmt(&mut buf_invalid);\n    |                          ~                     ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:581:57\n    |\n581 |     let unicode_item_valid = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n581 |     let unicode_item_valid = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::P(Literal::new(r\"\\pL\")));\n    |                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&class_induct_valid, &mut buf_valid);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&class_induct_valid).fmt(&mut buf_valid);\n    |             ~                   ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0223, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0223`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));",
                "    let class_induct = ClassInduct::Item(&unicode_item);",
                "    let mut buf = String::new();",
                "    let _ = fmt(&class_induct, &mut buf);",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    assert!(fmt(&class_induct, &mut buf).is_err());"
                ],
                [
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    assert_eq!(fmt(&class_induct, &mut buf).is_ok(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[should_panic]",
                  "fn test_class_induct_unicode_invalid() {",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "}",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    assert!(fmt(&class_induct, &mut buf).is_err());",
                  "}"
                ],
                [
                  "{",
                  "#[should_panic]",
                  "fn test_class_induct_unicode_invalid() {",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "}",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let _ = fmt(&class_induct, &mut buf);",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));",
                  "    let class_induct = ClassInduct::Item(&unicode_item);",
                  "    let mut buf = String::new();",
                  "    assert_eq!(fmt(&class_induct, &mut buf).is_ok(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:85\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:564:51\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:567:13\n    |\n567 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n567 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:573:51\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:577:51\n    |\n577 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n577 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     assert!(fmt(&class_induct, &mut buf).is_err());\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     assert!((&class_induct).fmt(&mut buf).is_err());\n    |             ~             ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0223, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0223`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:573:85\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:85\n    |\n580 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:564:51\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n564 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:567:13\n    |\n567 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n567 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:573:51\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n573 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:576:13\n    |\n576 |     let _ = fmt(&class_induct, &mut buf);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n576 |     let _ = (&class_induct).fmt(&mut buf);\n    |             ~             ~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:577:51\n    |\n577 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::Invalid);\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n577 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::Invalid);\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0223]: ambiguous associated type\n   --> regex-syntax/src/ast/visitor.rs:580:51\n    |\n580 |     let unicode_item = ast::ClassSetItem::Unicode(ast::ClassUnicode::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: if there were a trait named `Example` with associated type `UnicodeType` implemented for `ast::ClassUnicode`, you could use the fully-qualified path\n    |\n580 |     let unicode_item = ast::ClassSetItem::Unicode(<ast::ClassUnicode as Example>::UnicodeType::P(Literal::new(r\"\\p{Greek}\")));\n    |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:16\n    |\n583 |     assert_eq!(fmt(&class_induct, &mut buf).is_ok(), true);\n    |                ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     assert_eq!((&class_induct).fmt(&mut buf).is_ok(), true);\n    |                ~             ~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0223, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0223`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Ascii(_) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Ascii(_) is true\n"
      ],
      "input_infer": "0 to 1 for ClassInduct::Item(it), 0 to 1 for ast::ClassSetItem::Ascii(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let item = ast::ClassSetItem::Empty(Span::default());",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let item = ast::ClassSetItem::Empty(Span::default());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Empty)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let item = ast::ClassSetItem::Empty(Span::default());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let item = ast::ClassSetItem::Empty(Span::default());",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Empty)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:41\n    |\n565 |     let item = ast::ClassSetItem::Empty(Span::default());\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:41\n    |\n569 |     let item = ast::ClassSetItem::Empty(Span::default());\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n568 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n572 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal::new('a'); // Assume appropriate constructor",
                "    let item = ast::ClassSetItem::Literal(literal);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Literal)\");"
                ],
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    assert_eq!(output_ascii, \"Item(Ascii)\");"
                ],
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    assert_eq!(output_empty, \"Item(Empty)\");"
                ],
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    assert_eq!(output_range, \"Item(Range)\");"
                ],
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    assert_eq!(output_unicode, \"Item(Unicode)\");"
                ],
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());",
                  "    let induct_perl = ClassInduct::Item(&perl_item);",
                  "    let mut output_perl = String::new();",
                  "    induct_perl.fmt(&mut output_perl).unwrap();",
                  "    assert_eq!(output_perl, \"Item(Perl)\");"
                ],
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());",
                  "    let induct_perl = ClassInduct::Item(&perl_item);",
                  "    let mut output_perl = String::new();",
                  "    induct_perl.fmt(&mut output_perl).unwrap();",
                  "    let bracketed_item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&bracketed_item);",
                  "    let mut output_bracketed = String::new();",
                  "    induct_bracketed.fmt(&mut output_bracketed).unwrap();",
                  "    assert_eq!(output_bracketed, \"Item(Bracketed)\");"
                ],
                [
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());",
                  "    let induct_perl = ClassInduct::Item(&perl_item);",
                  "    let mut output_perl = String::new();",
                  "    induct_perl.fmt(&mut output_perl).unwrap();",
                  "    let bracketed_item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&bracketed_item);",
                  "    let mut output_bracketed = String::new();",
                  "    induct_bracketed.fmt(&mut output_bracketed).unwrap();",
                  "    let union_item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&union_item);",
                  "    let mut output_union = String::new();",
                  "    induct_union.fmt(&mut output_union).unwrap();",
                  "    assert_eq!(output_union, \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    assert_eq!(output_ascii, \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    assert_eq!(output_empty, \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    assert_eq!(output_range, \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    assert_eq!(output_unicode, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());",
                  "    let induct_perl = ClassInduct::Item(&perl_item);",
                  "    let mut output_perl = String::new();",
                  "    induct_perl.fmt(&mut output_perl).unwrap();",
                  "    assert_eq!(output_perl, \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());",
                  "    let induct_perl = ClassInduct::Item(&perl_item);",
                  "    let mut output_perl = String::new();",
                  "    induct_perl.fmt(&mut output_perl).unwrap();",
                  "    let bracketed_item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&bracketed_item);",
                  "    let mut output_bracketed = String::new();",
                  "    induct_bracketed.fmt(&mut output_bracketed).unwrap();",
                  "    assert_eq!(output_bracketed, \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::new('a'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let literal = Literal::new('a');",
                  "    let item = ast::ClassSetItem::Literal(literal);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());",
                  "    let induct_ascii = ClassInduct::Item(&ascii_item);",
                  "    let mut output_ascii = String::new();",
                  "    induct_ascii.fmt(&mut output_ascii).unwrap();",
                  "    let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));",
                  "    let induct_empty = ClassInduct::Item(&empty_item);",
                  "    let mut output_empty = String::new();",
                  "    induct_empty.fmt(&mut output_empty).unwrap();",
                  "    let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
                  "    let induct_range = ClassInduct::Item(&range_item);",
                  "    let mut output_range = String::new();",
                  "    induct_range.fmt(&mut output_range).unwrap();",
                  "    let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());",
                  "    let induct_unicode = ClassInduct::Item(&unicode_item);",
                  "    let mut output_unicode = String::new();",
                  "    induct_unicode.fmt(&mut output_unicode).unwrap();",
                  "    let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());",
                  "    let induct_perl = ClassInduct::Item(&perl_item);",
                  "    let mut output_perl = String::new();",
                  "    induct_perl.fmt(&mut output_perl).unwrap();",
                  "    let bracketed_item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
                  "    let induct_bracketed = ClassInduct::Item(&bracketed_item);",
                  "    let mut output_bracketed = String::new();",
                  "    induct_bracketed.fmt(&mut output_bracketed).unwrap();",
                  "    let union_item = ast::ClassSetItem::Union(ClassSetUnion::new());",
                  "    let induct_union = ClassInduct::Item(&union_item);",
                  "    let mut output_union = String::new();",
                  "    induct_union.fmt(&mut output_union).unwrap();",
                  "    assert_eq!(output_union, \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:575:47\n    |\n575 |     let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n578 |     induct_ascii.fmt(&mut output_ascii).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:575:47\n    |\n575 |     let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:47\n    |\n579 |     let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));\n    |                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n578 |     induct_ascii.fmt(&mut output_ascii).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_empty.fmt(&mut output_empty).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:575:47\n    |\n575 |     let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:47\n    |\n579 |     let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));\n    |                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n578 |     induct_ascii.fmt(&mut output_ascii).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_empty.fmt(&mut output_empty).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:586:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n586 |     induct_range.fmt(&mut output_range).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:575:47\n    |\n575 |     let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:47\n    |\n579 |     let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));\n    |                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:51\n    |\n587 |     let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n578 |     induct_ascii.fmt(&mut output_ascii).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_empty.fmt(&mut output_empty).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:586:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n586 |     induct_range.fmt(&mut output_range).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:590:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n590 |     induct_unicode.fmt(&mut output_unicode).unwrap();\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:575:47\n    |\n575 |     let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:47\n    |\n579 |     let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));\n    |                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:51\n    |\n587 |     let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:591:45\n    |\n591 |     let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n578 |     induct_ascii.fmt(&mut output_ascii).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_empty.fmt(&mut output_empty).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:586:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n586 |     induct_range.fmt(&mut output_range).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:590:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n590 |     induct_unicode.fmt(&mut output_unicode).unwrap();\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_perl.fmt(&mut output_perl).unwrap();\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:575:47\n    |\n575 |     let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:47\n    |\n579 |     let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));\n    |                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:51\n    |\n587 |     let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:591:45\n    |\n591 |     let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:595:64\n    |\n595 |     let bracketed_item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n578 |     induct_ascii.fmt(&mut output_ascii).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_empty.fmt(&mut output_empty).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:586:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n586 |     induct_range.fmt(&mut output_range).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:590:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n590 |     induct_unicode.fmt(&mut output_unicode).unwrap();\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_perl.fmt(&mut output_perl).unwrap();\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:598:22\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n598 |     induct_bracketed.fmt(&mut output_bracketed).unwrap();\n    |                      ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:19\n    |\n565 |     let literal = Literal::new('a'); // Assume appropriate constructor\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:19\n    |\n570 |     let literal = Literal::new('a');\n    |                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:575:47\n    |\n575 |     let ascii_item = ast::ClassSetItem::Ascii(ClassAscii::new());\n    |                                               ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:47\n    |\n579 |     let empty_item = ast::ClassSetItem::Empty(Span::new(0, 1));\n    |                                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:583:47\n    |\n583 |     let range_item = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:51\n    |\n587 |     let unicode_item = ast::ClassSetItem::Unicode(ClassUnicode::new());\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:591:45\n    |\n591 |     let perl_item = ast::ClassSetItem::Perl(ClassPerl::new());\n    |                                             ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:595:64\n    |\n595 |     let bracketed_item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));\n    |                                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:599:47\n    |\n599 |     let union_item = ast::ClassSetItem::Union(ClassSetUnion::new());\n    |                                               ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n578 |     induct_ascii.fmt(&mut output_ascii).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n582 |     induct_empty.fmt(&mut output_empty).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:586:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n586 |     induct_range.fmt(&mut output_range).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:590:20\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n590 |     induct_unicode.fmt(&mut output_unicode).unwrap();\n    |                    ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:594:17\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n594 |     induct_perl.fmt(&mut output_perl).unwrap();\n    |                 ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:598:22\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n598 |     induct_bracketed.fmt(&mut output_bracketed).unwrap();\n    |                      ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:602:18\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n602 |     induct_union.fmt(&mut output_union).unwrap();\n    |                  ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ClassSetRange::new('a', 'z'); // Assume appropriate constructor",
                "    let item = ast::ClassSetItem::Range(range);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Range(range);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Range)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let range = ClassSetRange::new('a', 'z'); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Range(range);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let range = ClassSetRange::new('a', 'z');",
                  "    let item = ast::ClassSetItem::Range(range);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Range)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:565:17\n    |\n565 |     let range = ClassSetRange::new('a', 'z'); // Assume appropriate constructor\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:570:17\n    |\n570 |     let range = ClassSetRange::new('a', 'z');\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ascii_class = ClassAscii::new(\"[:alpha:]\"); // Assume appropriate constructor",
                "    let item = ast::ClassSetItem::Ascii(ascii_class);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ascii_class = ClassAscii::new(\"[:alpha:]\");",
                  "    let item = ast::ClassSetItem::Ascii(ascii_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Ascii)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ascii_class = ClassAscii::new(\"[:alpha:]\"); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Ascii(ascii_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let ascii_class = ClassAscii::new(\"[:alpha:]\");",
                  "    let item = ast::ClassSetItem::Ascii(ascii_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Ascii)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let ascii_class = ClassAscii::new(\"[:alpha:]\"); // Assume appropriate constructor\n    |                       ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let ascii_class = ClassAscii::new(\"[:alpha:]\");\n    |                       ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unicode_class = ClassUnicode::new(\"\\\\p{L}\"); // Assume appropriate constructor",
                "    let item = ast::ClassSetItem::Unicode(unicode_class);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode_class = ClassUnicode::new(\"\\\\p{L}\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    output.clear();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Unicode)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let unicode_class = ClassUnicode::new(\"\\\\p{L}\"); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let unicode_class = ClassUnicode::new(\"\\\\p{L}\");",
                  "    let item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    output.clear();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Unicode)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:565:25\n    |\n565 |     let unicode_class = ClassUnicode::new(\"\\\\p{L}\"); // Assume appropriate constructor\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:570:25\n    |\n570 |     let unicode_class = ClassUnicode::new(\"\\\\p{L}\");\n    |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:575:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n575 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let perl_class = ClassPerl::new(\"\\\\d\"); // Assume appropriate constructor",
                "    let item = ast::ClassSetItem::Perl(perl_class);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let perl_class = ClassPerl::new(\"\\\\d\");",
                  "    let item = ast::ClassSetItem::Perl(perl_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Perl)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let perl_class = ClassPerl::new(\"\\\\d\"); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Perl(perl_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let perl_class = ClassPerl::new(\"\\\\d\");",
                  "    let item = ast::ClassSetItem::Perl(perl_class);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Perl)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:22\n    |\n565 |     let perl_class = ClassPerl::new(\"\\\\d\"); // Assume appropriate constructor\n    |                      ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:570:22\n    |\n570 |     let perl_class = ClassPerl::new(\"\\\\d\");\n    |                      ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bracketed = ClassBracketed::new(vec![]); // Assume appropriate constructor",
                "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let bracketed = ClassBracketed::new(vec![]);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let bracketed = ClassBracketed::new(vec![]); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let bracketed = ClassBracketed::new(vec![]);",
                  "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:565:21\n    |\n565 |     let bracketed = ClassBracketed::new(vec![]); // Assume appropriate constructor\n    |                     ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:570:21\n    |\n570 |     let bracketed = ClassBracketed::new(vec![]);\n    |                     ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let union = ClassSetUnion::new(vec![]); // Assume appropriate constructor",
                "    let item = ast::ClassSetItem::Union(union);",
                "    let induct = ClassInduct::Item(&item);",
                "    let mut output = String::new();",
                "    induct.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let union = ClassSetUnion::new(vec![]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let union = ClassSetUnion::new(vec![]); // Assume appropriate constructor",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    let union = ClassSetUnion::new(vec![]);",
                  "    let item = ast::ClassSetItem::Union(union);",
                  "    let induct = ClassInduct::Item(&item);",
                  "    let mut output = String::new();",
                  "    induct.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:565:17\n    |\n565 |     let union = ClassSetUnion::new(vec![]); // Assume appropriate constructor\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:570:17\n    |\n570 |     let union = ClassSetUnion::new(vec![]);\n    |                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut output).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Range(_) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Range(_) is true\n"
      ],
      "input_infer": "ClassInduct::Item(ast::ClassSetItem::Range(0..255))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let range = ast::ClassSetItem::Range(0..255);",
                "    let class_induct = ClassInduct::Item(&range);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let range = ast::ClassSetItem::Range(0..255);",
                  "    let class_induct = ClassInduct::Item(&range);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));"
                ],
                [
                  "    let range = ast::ClassSetItem::Range(0..255);",
                  "    let class_induct = ClassInduct::Item(&range);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(formatter.buffer(), \"Item(Range)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let range = ast::ClassSetItem::Range(0..255);",
                  "    let class_induct = ClassInduct::Item(&range);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let range = ast::ClassSetItem::Range(0..255);",
                  "    let class_induct = ClassInduct::Item(&range);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let range = ast::ClassSetItem::Range(0..255);",
                  "    let class_induct = ClassInduct::Item(&range);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let range = ast::ClassSetItem::Range(0..255);",
                  "    let class_induct = ClassInduct::Item(&range);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(formatter.buffer(), \"Item(Range)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let range = ast::ClassSetItem::Range(0..255);\n    |                 ------------------------ ^^^^^^ expected `ClassSetRange`, found `Range<{integer}>`\n    |                 |\n    |                 arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ClassSetRange`\n               found struct `std::ops::Range<{integer}>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:973:5\n    |\n973 |     Range(ClassSetRange),\n    |     ^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let range = ast::ClassSetItem::Range(0..255);\n    |                 ------------------------ ^^^^^^ expected `ClassSetRange`, found `Range<{integer}>`\n    |                 |\n    |                 arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ClassSetRange`\n               found struct `std::ops::Range<{integer}>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:973:5\n    |\n973 |     Range(ClassSetRange),\n    |     ^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:16\n    |\n572 |     assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));\n    |                ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     assert_eq!((&class_induct).fmt(&mut formatter), Ok(()));\n    |                ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0423, E0432, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let range = ast::ClassSetItem::Range(0..255);\n    |                 ------------------------ ^^^^^^ expected `ClassSetRange`, found `Range<{integer}>`\n    |                 |\n    |                 arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ClassSetRange`\n               found struct `std::ops::Range<{integer}>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:973:5\n    |\n973 |     Range(ClassSetRange),\n    |     ^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let range = ast::ClassSetItem::Range(0..255);\n    |                 ------------------------ ^^^^^^ expected `ClassSetRange`, found `Range<{integer}>`\n    |                 |\n    |                 arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ClassSetRange`\n               found struct `std::ops::Range<{integer}>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:973:5\n    |\n973 |     Range(ClassSetRange),\n    |     ^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `buffer` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:572:26\n    |\n572 |     assert_eq!(formatter.buffer(), \"Item(Range)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
                "    let class_induct = ClassInduct::Item(&empty);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
                  "    let class_induct = ClassInduct::Item(&empty);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
                  "    let class_induct = ClassInduct::Item(&empty);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.buffer(), \"Item(Empty)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
                  "    let class_induct = ClassInduct::Item(&empty);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
                  "    let class_induct = ClassInduct::Item(&empty);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
                  "    let class_induct = ClassInduct::Item(&empty);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });",
                  "    let class_induct = ClassInduct::Item(&empty);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.buffer(), \"Item(Empty)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:18\n    |\n572 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0423, E0432, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let empty = ast::ClassSetItem::Empty(Span { start: 0, end: 0 });\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:18\n    |\n572 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `buffer` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     assert_eq!(formatter.buffer(), \"Item(Empty)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0423, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
                "    let class_induct = ClassInduct::Item(&literal);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let class_induct = ClassInduct::Item(&literal);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.buffer(), \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let class_induct = ClassInduct::Item(&literal);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let literal = ast::ClassSetItem::Literal(Literal::new('a'));",
                  "    let class_induct = ClassInduct::Item(&literal);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.buffer(), \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:46\n    |\n565 |     let literal = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:46\n    |\n569 |     let literal = ast::ClassSetItem::Literal(Literal::new('a'));\n    |                                              ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:5\n    |\n572 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `buffer` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     assert_eq!(formatter.buffer(), \"Item(Literal)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
                "    let class_induct = ClassInduct::Item(&ascii);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&ascii);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));"
                ],
                [
                  "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&ascii);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&ascii);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&ascii);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&ascii);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&ascii);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));\n    |                                          ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));\n    |                                          ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:16\n    |\n572 |     assert_eq!(fmt(&class_induct, &mut formatter), Ok(()));\n    |                ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     assert_eq!((&class_induct).fmt(&mut formatter), Ok(()));\n    |                ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));\n    |                                          ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let ascii = ast::ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\".to_string()));\n    |                                          ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:572:26\n    |\n572 |     assert_eq!(formatter.to_string(), \"Item(Ascii)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
                "    let class_induct = ClassInduct::Item(&unicode);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&unicode);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Unicode)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&unicode);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&unicode);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Unicode)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:565:46\n    |\n565 |     let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:569:46\n    |\n569 |     let unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"\\\\pL\".to_string()));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:5\n    |\n572 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     assert_eq!(formatter.output(), \"Item(Unicode)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
                "    let class_induct = ClassInduct::Item(&perl);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&perl);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&perl);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert!(formatter.to_string().contains(\"Item(Perl)\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&perl);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&perl);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&perl);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));",
                  "    let class_induct = ClassInduct::Item(&perl);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    let result = fmt(&class_induct, &mut formatter);",
                  "    assert!(formatter.to_string().contains(\"Item(Perl)\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:18\n    |\n572 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let perl = ast::ClassSetItem::Perl(ClassPerl::new(\"\\\\d\".to_string()));\n    |                                        ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:18\n    |\n572 |     let result = fmt(&class_induct, &mut formatter);\n    |                  ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let result = (&class_induct).fmt(&mut formatter);\n    |                  ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     assert!(formatter.to_string().contains(\"Item(Perl)\"));\n    |                       ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                "    let class_induct = ClassInduct::Item(&bracketed);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let class_induct = ClassInduct::Item(&bracketed);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Bracketed)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let class_induct = ClassInduct::Item(&bracketed);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
                  "    let class_induct = ClassInduct::Item(&bracketed);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.output(), \"Item(Bracketed)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:565:59\n    |\n565 |     let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                           ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:569:59\n    |\n569 |     let bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));\n    |                                                           ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:5\n    |\n572 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `output` found for struct `std::fmt::Formatter` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     assert_eq!(formatter.output(), \"Item(Bracketed)\");\n    |                          ^^^^^^ method not found in `Formatter<'_>`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                "    let class_induct = ClassInduct::Item(&union);",
                "    let mut formatter = fmt::Formatter::new();",
                "    fmt(&class_induct, &mut formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let class_induct = ClassInduct::Item(&union);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let class_induct = ClassInduct::Item(&union);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
                  "    let class_induct = ClassInduct::Item(&union);",
                  "    let mut formatter = fmt::Formatter::new();",
                  "    fmt(&class_induct, &mut formatter);",
                  "    assert_eq!(formatter.to_string(), \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                          ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));\n    |                                          ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:567:25\n    |\n567 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n567 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:568:5\n    |\n568 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n568 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/visitor.rs:571:25\n    |\n571 |     let mut formatter = fmt::Formatter::new();\n    |                         ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n571 |     let mut formatter = fmt::Formatter::new(/* &mut dyn std::fmt::Write */);\n    |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:5\n    |\n572 |     fmt(&class_induct, &mut formatter);\n    |     ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     (&class_induct).fmt(&mut formatter);\n    |     ~             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: `std::fmt::Formatter<'_>` doesn't implement `std::fmt::Display`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     assert_eq!(formatter.to_string(), \"Item(Union)\");\n    |                          ^^^^^^^^^ `std::fmt::Formatter<'_>` cannot be formatted with the default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n            `std::fmt::Formatter<'_>: std::fmt::Display`\n            which is required by `std::fmt::Formatter<'_>: ToString`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0423, E0432, E0433, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Literal(_) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Literal(_) is true\n"
      ],
      "input_infer": "Test input ranges: ClassInduct::Item(it) where it matches ast::ClassSetItem::Literal(Literal) with Literal values ranging from char(0) to char(255) for boundary cases and edge scenarios.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));",
                "    let induct = ClassInduct::Item(&literal);",
                "    let mut buffer = String::new();",
                "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                "    induct.fmt(&mut formatter).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    assert_eq!(induct.fmt(&mut formatter).unwrap(), ());"
                ],
                [
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    assert_eq!(buffer, \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    assert_eq!(induct.fmt(&mut formatter).unwrap(), ());",
                  "}"
                ],
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    assert_eq!(buffer, \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:565:60\n    |\n565 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:573:25\n    |\n573 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     assert_eq!(induct.fmt(&mut formatter).unwrap(), ());\n    |                       ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:565:60\n    |\n565 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\0'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:573:25\n    |\n573 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{1}'));",
                "    let induct = ClassInduct::Item(&literal);",
                "    let mut buffer = String::new();",
                "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                "    induct.fmt(&mut formatter).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{1}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{1}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{1}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:565:60\n    |\n565 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{1}'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{1}'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:573:25\n    |\n573 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{7F}'));",
                "    let induct = ClassInduct::Item(&literal);",
                "    let mut buffer = String::new();",
                "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                "    induct.fmt(&mut formatter).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{7F}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{7F}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{7F}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:565:60\n    |\n565 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{7F}'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{7F}'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:573:25\n    |\n573 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{FF}'));",
                "    let induct = ClassInduct::Item(&literal);",
                "    let mut buffer = String::new();",
                "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                "    induct.fmt(&mut formatter).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{FF}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{FF}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{FF}'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:565:60\n    |\n565 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{FF}'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('\\u{FF}'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:573:25\n    |\n573 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char(' '));",
                "    let induct = ClassInduct::Item(&literal);",
                "    let mut buffer = String::new();",
                "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                "    induct.fmt(&mut formatter).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char(' '));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char(' '));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char(' '));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:565:60\n    |\n565 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char(' '));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char(' '));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:573:25\n    |\n573 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('a'));",
                "    let induct = ClassInduct::Item(&literal);",
                "    let mut buffer = String::new();",
                "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                "    induct.fmt(&mut formatter).unwrap();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('z'));",
                "    let induct = ClassInduct::Item(&literal);",
                "    let mut buffer = String::new();",
                "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                "    induct.fmt(&mut formatter).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('z'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('z'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('z'));",
                  "    let induct = ClassInduct::Item(&literal);",
                  "    let mut buffer = String::new();",
                  "    let mut formatter = fmt::Formatter::new(&mut buffer);",
                  "    induct.fmt(&mut formatter).unwrap();",
                  "    assert_eq!(buffer, \"Item(Literal)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:565:60\n    |\n565 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('z'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:569:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n569 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nerror[E0599]: no function or associated item named `from_char` found for struct `ast::Literal` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:60\n    |\n570 |     let literal = ast::ClassSetItem::Literal(ast::Literal::from_char('z'));\n    |                                                            ^^^^^^^^^ function or associated item not found in `Literal`\n    |\n   ::: regex-syntax/src/ast/mod.rs:614:1\n    |\n614 | pub struct Literal {\n    | ------------------ function or associated item `from_char` not found for this struct\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/ast/visitor.rs:573:25\n    |\n573 |     let mut formatter = fmt::Formatter::new(&mut buffer);\n    |                         ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for enum `ast::visitor::ClassInduct` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:12\n    |\n211 | enum ClassInduct<'a> {\n    | -------------------- method `fmt` not found for this enum\n...\n574 |     induct.fmt(&mut formatter).unwrap();\n    |            ^^^ method not found in `ClassInduct<'_>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:642:8\n    |\n    = note: the method is available for `ast::visitor::ClassInduct<'_>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Debug` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n560 +    use std::fmt::Debug;\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *self matches ClassInduct::Item(it) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Empty(_) is true\n",
        "// constraint: *it matches ast::ClassSetItem::Empty(_) is true\n"
      ],
      "input_infer": "* self: ClassInduct::Item(ast::ClassSetItem::Empty(span)), span: valid non-negative range (0..=max_span) where max_span is the maximum allowed Span value.\n",
      "answers": [
        {
          "uses": [
            "use ast::Literal;",
            "use ast::ClassSetRange;",
            "use ast::ClassUnicode;",
            "use ast::ClassAscii;",
            "use ast::ClassSetBinaryOp;",
            "use ast::Span;",
            "use ast::ClassSetUnion;",
            "use ast::ClassSetItem;",
            "use ast::ClassBracketed;",
            "use ast::ClassSetBinaryOpKind;",
            "use ast::ClassPerl;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span};",
                "    ",
                "    let span = Span { start: 0, end: 0 }; // assuming a valid non-negative range for span",
                "    let item = ClassInduct::Item(ClassSetItem::Empty(span));",
                "    ",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let item = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Empty)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span};",
                  "    ",
                  "    let span = Span { start: 0, end: 0 }; // assuming a valid non-negative range for span",
                  "    let item = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let item = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Empty)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 0 }; // assuming a valid non-negative range for span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 0 }; // assuming a valid non-negative range for span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:34\n    |\n568 |     let item = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n568 |     let item = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n571 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:572:30\n    |\n572 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:572:38\n    |\n572 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:34\n    |\n573 |     let item = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n573 |     let item = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:575:13\n    |\n575 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n575 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span, Literal};",
                "    ",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                "    ",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_empty), \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_literal), \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_range), \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_ascii), \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_unicode), \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_perl), \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_bracketed), \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_union), \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_empty), \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_literal), \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_range), \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_ascii), \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_unicode), \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_perl), \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_bracketed), \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, Literal};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let literal = Literal { value: 'a' }; // assuming a valid Literal",
                  "    let item = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { value: 'a' };",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));",
                  "    assert_eq!(format!(\"{:?}\", item_union), \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetRange` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:60\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:578:60\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:579:64\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:580:58\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:77\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                                                             ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetUnion` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:60\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                                            ^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let literal = Literal { value: 'a' }; // assuming a valid Literal\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Literal` has no field named `value`\n   --> regex-syntax/src/ast/visitor.rs:574:29\n    |\n574 |     let literal = Literal { value: 'a' };\n    |                             ^^^^^ `ast::Literal` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `c`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:40\n    |\n575 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(literal));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n576 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(literal));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:577:40\n    |\n577 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n577 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange { start: 'a', end: 'z' }));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::Alnum));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::L));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n579 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::L));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:580:39\n    |\n580 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::Digit));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n580 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::Digit));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:44\n    |\n581 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed { items: vec![] })));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion { items: vec![] }));\n    |                                        +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0423, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span, ClassSetRange};",
                "    ",
                "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                "    ",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    assert_eq!(output_empty, \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    assert_eq!(output_literal, \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    assert_eq!(output_ascii, \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    assert_eq!(output_unicode, \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    assert_eq!(output_perl, \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    assert_eq!(output_bracketed, \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    assert_eq!(output_union, \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);",
                  "    assert_eq!(output_binary_intersection, \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_binary_difference);",
                  "    assert_eq!(output_binary_difference, \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_binary_difference);",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_symmetric_difference = String::new();",
                  "    let _ = fmt(&binary_op_symmetric_difference, &mut output_binary_symmetric_difference);",
                  "    assert_eq!(output_binary_symmetric_difference, \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    assert_eq!(output_empty, \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    assert_eq!(output_literal, \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    assert_eq!(output_ascii, \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    assert_eq!(output_unicode, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    assert_eq!(output_perl, \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    assert_eq!(output_bracketed, \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    assert_eq!(output_union, \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);",
                  "    assert_eq!(output_binary_intersection, \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_binary_difference);",
                  "    assert_eq!(output_binary_difference, \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetRange};",
                  "    ",
                  "    let span = Span { start: 0, end: 2 }; // assuming a valid span",
                  "    let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let range = ClassSetRange { start: 'a', end: 'z' };",
                  "    let item = ClassInduct::Item(ClassSetItem::Range(range));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output_bracketed = String::new();",
                  "    let _ = fmt(&item_bracketed, &mut output_bracketed);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_binary_difference);",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });",
                  "    let mut output_binary_symmetric_difference = String::new();",
                  "    let _ = fmt(&binary_op_symmetric_difference, &mut output_binary_symmetric_difference);",
                  "    assert_eq!(output_binary_symmetric_difference, \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:64\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:42\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:64\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:590:58\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:42\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:39\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:64\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:590:58\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:593:77\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:42\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:39\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:44\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_bracketed, &mut output_bracketed);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_bracketed).fmt(&mut output_bracketed);\n    |             ~               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:64\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:590:58\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:593:77\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:42\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:39\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:44\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_bracketed, &mut output_bracketed);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_bracketed).fmt(&mut output_bracketed);\n    |             ~               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:64\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:590:58\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:593:77\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |     let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(C...\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:87\n    |\n599 | ...Op(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:137\n    |\n599 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:169\n    |\n599 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:42\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:39\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:44\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_bracketed, &mut output_bracketed);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_bracketed).fmt(&mut output_bracketed);\n    |             ~               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:601:13\n    |\n601 |     let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n601 |     let _ = (&binary_op_intersection).fmt(&mut output_binary_intersection);\n    |             ~                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 40 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:64\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:590:58\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:593:77\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |     let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(C...\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:87\n    |\n599 | ...Op(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:137\n    |\n599 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:169\n    |\n599 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:602:54\n    |\n602 |     let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(Class...\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:602:85\n    |\n602 | ...Op(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:133\n    |\n602 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:165\n    |\n602 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:42\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:39\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:44\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_bracketed, &mut output_bracketed);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_bracketed).fmt(&mut output_bracketed);\n    |             ~               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:601:13\n    |\n601 |     let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n601 |     let _ = (&binary_op_intersection).fmt(&mut output_binary_intersection);\n    |             ~                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:604:13\n    |\n604 |     let _ = fmt(&binary_op_difference, &mut output_binary_difference);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n604 |     let _ = (&binary_op_difference).fmt(&mut output_binary_difference);\n    |             ~                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 45 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:587:64\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:590:58\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:593:77\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |     let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(C...\n    |                                                        ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:599:87\n    |\n599 | ...Op(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:137\n    |\n599 | ...sSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:599:169\n    |\n599 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:602:54\n    |\n602 |     let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(Class...\n    |                                                      ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:602:85\n    |\n602 | ...Op(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:133\n    |\n602 | ...assSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:165\n    |\n602 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSetBinaryOp` in this scope\n   --> regex-syntax/src/ast/visitor.rs:605:64\n    |\n605 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, ...\n    |                                                                ^^^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetBinaryOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetBinaryOpKind`\n   --> regex-syntax/src/ast/visitor.rs:605:95\n    |\n605 | ...Op(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::n...\n    |                                      ^^^^^^^^^^^^^^^^^^^^ use of undeclared type `ClassSetBinaryOpKind`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetBinaryOpKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:152\n    |\n605 | ...aryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:605:184\n    |\n605 | ...lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 2 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:40\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:568:17\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 2 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:40\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                        ^^^ expected `Literal`, found `char`\n\nerror[E0063]: missing field `span` in initializer of `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:574:17\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                 ^^^^^^^^^^^^^ missing `span`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Range(range));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Range(range));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:42\n    |\n587 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:39\n    |\n590 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:44\n    |\n593 |     let item_bracketed = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_bracketed = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_bracketed, &mut output_bracketed);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_bracketed).fmt(&mut output_bracketed);\n    |             ~               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:601:13\n    |\n601 |     let _ = fmt(&binary_op_intersection, &mut output_binary_intersection);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n601 |     let _ = (&binary_op_intersection).fmt(&mut output_binary_intersection);\n    |             ~                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:604:13\n    |\n604 |     let _ = fmt(&binary_op_difference, &mut output_binary_difference);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n604 |     let _ = (&binary_op_difference).fmt(&mut output_binary_difference);\n    |             ~                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:607:13\n    |\n607 |     let _ = fmt(&binary_op_symmetric_difference, &mut output_binary_symmetric_difference);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n607 |     let _ = (&binary_op_symmetric_difference).fmt(&mut output_binary_symmetric_difference);\n    |             ~                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:568:50\n    |\n568 |     let range = ClassSetRange { start: 'a', end: 'z' }; // assuming a valid range\n    |                                                  ^^^ expected `Literal`, found `char`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:574:50\n    |\n574 |     let range = ClassSetRange { start: 'a', end: 'z' };\n    |                                                  ^^^ expected `Literal`, found `char`\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 50 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span, ClassAscii};",
                "    ",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let ascii = ClassAscii { name: \"alnum\" }; // assuming a valid ClassAscii",
                "    let item = ClassInduct::Item(ClassSetItem::Ascii(ascii));",
                "    ",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ascii = ClassAscii { name: \"alnum\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Ascii(ascii));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Ascii)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassAscii};",
                  "    ",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let ascii = ClassAscii { name: \"alnum\" }; // assuming a valid ClassAscii",
                  "    let item = ClassInduct::Item(ClassSetItem::Ascii(ascii));",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ascii = ClassAscii { name: \"alnum\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Ascii(ascii));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Ascii)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ClassAscii` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:568:30\n    |\n568 |     let ascii = ClassAscii { name: \"alnum\" }; // assuming a valid ClassAscii\n    |                              ^^^^ `ClassAscii` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `negated`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Ascii(ascii));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Ascii(ascii));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ClassAscii` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:574:30\n    |\n574 |     let ascii = ClassAscii { name: \"alnum\" };\n    |                              ^^^^ `ClassAscii` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `negated`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Ascii(ascii));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Ascii(ascii));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span, ClassUnicode};",
                "",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let unicode = ClassUnicode { name: \"L\" }; // assuming a valid ClassUnicode",
                "    let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));",
                "",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode = ClassUnicode { name: \"L\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode = ClassUnicode { name: \"L\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert!(output.contains(\"Item(Unicode)\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassUnicode};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let unicode = ClassUnicode { name: \"L\" }; // assuming a valid ClassUnicode",
                  "    let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode = ClassUnicode { name: \"L\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassUnicode};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let unicode = ClassUnicode { name: \"L\" }; // assuming a valid ClassUnicode",
                  "    let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode = ClassUnicode { name: \"L\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert!(output.contains(\"Item(Unicode)\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::ClassUnicode` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:568:34\n    |\n568 |     let unicode = ClassUnicode { name: \"L\" }; // assuming a valid ClassUnicode\n    |                                  ^^^^ `ast::ClassUnicode` does not have this field\n    |\n    = note: available fields are: `span`, `negated`, `kind`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Unicode(unicode));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::ClassUnicode` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:574:34\n    |\n574 |     let unicode = ClassUnicode { name: \"L\" };\n    |                                  ^^^^ `ast::ClassUnicode` does not have this field\n    |\n    = note: available fields are: `span`, `negated`, `kind`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Unicode(unicode));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::ClassUnicode` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:568:34\n    |\n568 |     let unicode = ClassUnicode { name: \"L\" }; // assuming a valid ClassUnicode\n    |                                  ^^^^ `ast::ClassUnicode` does not have this field\n    |\n    = note: available fields are: `span`, `negated`, `kind`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Unicode(unicode));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::ClassUnicode` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:574:34\n    |\n574 |     let unicode = ClassUnicode { name: \"L\" };\n    |                                  ^^^^ `ast::ClassUnicode` does not have this field\n    |\n    = note: available fields are: `span`, `negated`, `kind`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Unicode(unicode));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Unicode(unicode));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span, ClassPerl};",
                "",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let perl = ClassPerl { name: \"d\" }; // assuming a valid ClassPerl",
                "    let item = ClassInduct::Item(ClassSetItem::Perl(perl));",
                "",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl = ClassPerl { name: \"d\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Perl(perl));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Perl)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassPerl};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let perl = ClassPerl { name: \"d\" }; // assuming a valid ClassPerl",
                  "    let item = ClassInduct::Item(ClassSetItem::Perl(perl));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl = ClassPerl { name: \"d\" };",
                  "    let item = ClassInduct::Item(ClassSetItem::Perl(perl));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Perl)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ClassPerl` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:568:28\n    |\n568 |     let perl = ClassPerl { name: \"d\" }; // assuming a valid ClassPerl\n    |                            ^^^^ `ClassPerl` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `negated`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Perl(perl));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Perl(perl));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ClassPerl` has no field named `name`\n   --> regex-syntax/src/ast/visitor.rs:574:28\n    |\n574 |     let perl = ClassPerl { name: \"d\" };\n    |                            ^^^^ `ClassPerl` does not have this field\n    |\n    = note: available fields are: `span`, `kind`, `negated`\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Perl(perl));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Perl(perl));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span, ClassBracketed};",
                "",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                "",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    assert_eq!(output_empty, \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    assert_eq!(output_literal, \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    assert_eq!(output_range, \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    assert_eq!(output_ascii, \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    assert_eq!(output_unicode, \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    assert_eq!(output_perl, \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    assert_eq!(output_union, \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_intersection);",
                  "    assert_eq!(output_intersection, \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_difference);",
                  "    assert_eq!(output_difference, \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_difference);",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_symmetric_difference = String::new();",
                  "    let _ = fmt(&binary_op_symmetric_difference, &mut output_symmetric_difference);",
                  "    assert_eq!(output_symmetric_difference, \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    assert_eq!(output_empty, \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    assert_eq!(output_literal, \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    assert_eq!(output_range, \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    assert_eq!(output_ascii, \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    assert_eq!(output_unicode, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    assert_eq!(output_perl, \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    assert_eq!(output_union, \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_intersection);",
                  "    assert_eq!(output_intersection, \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_difference);",
                  "    assert_eq!(output_difference, \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassBracketed};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let bracketed = ClassBracketed::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let bracketed = ClassBracketed::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));",
                  "    let mut output_empty = String::new();",
                  "    let _ = fmt(&item_empty, &mut output_empty);",
                  "    let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output_literal = String::new();",
                  "    let _ = fmt(&item_literal, &mut output_literal);",
                  "    let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output_range = String::new();",
                  "    let _ = fmt(&item_range, &mut output_range);",
                  "    let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output_ascii = String::new();",
                  "    let _ = fmt(&item_ascii, &mut output_ascii);",
                  "    let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output_unicode = String::new();",
                  "    let _ = fmt(&item_unicode, &mut output_unicode);",
                  "    let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output_perl = String::new();",
                  "    let _ = fmt(&item_perl, &mut output_perl);",
                  "    let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output_union = String::new();",
                  "    let _ = fmt(&item_union, &mut output_union);",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_intersection = String::new();",
                  "    let _ = fmt(&binary_op_intersection, &mut output_intersection);",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_difference = String::new();",
                  "    let _ = fmt(&binary_op_difference, &mut output_difference);",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ClassSet::new()),",
                  "    rhs: Box::new(ClassSet::new()),",
                  "    });",
                  "    let mut output_symmetric_difference = String::new();",
                  "    let _ = fmt(&binary_op_symmetric_difference, &mut output_symmetric_difference);",
                  "    assert_eq!(output_symmetric_difference, \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:587:60\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:40\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:587:60\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:590:64\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:40\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:42\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:587:60\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:590:64\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:593:58\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:40\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:42\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:39\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:587:60\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:590:64\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:593:58\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:40\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:42\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:39\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:587:60\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:590:64\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:593:58\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:19\n    |\n602 |     lhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:603:19\n    |\n603 |     rhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:40\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:42\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:39\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |       let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n600 | |     span,\n601 | |     kind: ast::ClassSetBinaryOpKind::Intersection,\n602 | |     lhs: Box::new(ClassSet::new()),\n603 | |     rhs: Box::new(ClassSet::new()),\n604 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n599 |     let binary_op_intersection = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:606:13\n    |\n606 |     let _ = fmt(&binary_op_intersection, &mut output_intersection);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n606 |     let _ = (&binary_op_intersection).fmt(&mut output_intersection);\n    |             ~                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:587:60\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:590:64\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:593:58\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:19\n    |\n602 |     lhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:603:19\n    |\n603 |     rhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:610:19\n    |\n610 |     lhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:611:19\n    |\n611 |     rhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:40\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:42\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:39\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |       let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n600 | |     span,\n601 | |     kind: ast::ClassSetBinaryOpKind::Intersection,\n602 | |     lhs: Box::new(ClassSet::new()),\n603 | |     rhs: Box::new(ClassSet::new()),\n604 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n599 |     let binary_op_intersection = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:606:13\n    |\n606 |     let _ = fmt(&binary_op_intersection, &mut output_intersection);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n606 |     let _ = (&binary_op_intersection).fmt(&mut output_intersection);\n    |             ~                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:607:54\n    |\n607 |       let binary_op_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n608 | |     span,\n609 | |     kind: ast::ClassSetBinaryOpKind::Difference,\n610 | |     lhs: Box::new(ClassSet::new()),\n611 | |     rhs: Box::new(ClassSet::new()),\n612 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n607 |     let binary_op_difference = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:614:13\n    |\n614 |     let _ = fmt(&binary_op_difference, &mut output_difference);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n614 |     let _ = (&binary_op_difference).fmt(&mut output_difference);\n    |             ~                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 39 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:581:64\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                                                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:60\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:587:60\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                            ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:590:64\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:593:58\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                                                          ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:596:60\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:602:19\n    |\n602 |     lhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:603:19\n    |\n603 |     rhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:610:19\n    |\n610 |     lhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:611:19\n    |\n611 |     rhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:618:19\n    |\n618 |     lhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:619:19\n    |\n619 |     rhs: Box::new(ClassSet::new()),\n    |                   ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:37\n    |\n568 |     let bracketed = ClassBracketed::new(); // assuming a valid initialization method\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassBracketed` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:574:37\n    |\n574 |     let bracketed = ClassBracketed::new();\n    |                                     ^^^ function or associated item not found in `ClassBracketed`\n    |\n   ::: regex-syntax/src/ast/mod.rs:912:1\n    |\n912 | pub struct ClassBracketed {\n    | ------------------------- function or associated item `new` not found for this struct\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Bracketed(Box::new(bracketed)));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:578:40\n    |\n578 |     let item_empty = ClassInduct::Item(ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n578 |     let item_empty = ClassInduct::Item(&ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:580:13\n    |\n580 |     let _ = fmt(&item_empty, &mut output_empty);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n580 |     let _ = (&item_empty).fmt(&mut output_empty);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:581:42\n    |\n581 |     let item_literal = ClassInduct::Item(ClassSetItem::Literal(Literal::new('a')));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n581 |     let item_literal = ClassInduct::Item(&ClassSetItem::Literal(Literal::new('a')));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:583:13\n    |\n583 |     let _ = fmt(&item_literal, &mut output_literal);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n583 |     let _ = (&item_literal).fmt(&mut output_literal);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:586:13\n    |\n586 |     let _ = fmt(&item_range, &mut output_range);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n586 |     let _ = (&item_range).fmt(&mut output_range);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:40\n    |\n587 |     let item_ascii = ClassInduct::Item(ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_ascii = ClassInduct::Item(&ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:589:13\n    |\n589 |     let _ = fmt(&item_ascii, &mut output_ascii);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n589 |     let _ = (&item_ascii).fmt(&mut output_ascii);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:42\n    |\n590 |     let item_unicode = ClassInduct::Item(ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n590 |     let item_unicode = ClassInduct::Item(&ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:592:13\n    |\n592 |     let _ = fmt(&item_unicode, &mut output_unicode);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n592 |     let _ = (&item_unicode).fmt(&mut output_unicode);\n    |             ~             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:593:39\n    |\n593 |     let item_perl = ClassInduct::Item(ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n593 |     let item_perl = ClassInduct::Item(&ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:595:13\n    |\n595 |     let _ = fmt(&item_perl, &mut output_perl);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n595 |     let _ = (&item_perl).fmt(&mut output_perl);\n    |             ~          ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:40\n    |\n596 |     let item_union = ClassInduct::Item(ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n596 |     let item_union = ClassInduct::Item(&ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:598:13\n    |\n598 |     let _ = fmt(&item_union, &mut output_union);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n598 |     let _ = (&item_union).fmt(&mut output_union);\n    |             ~           ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:599:56\n    |\n599 |       let binary_op_intersection = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n600 | |     span,\n601 | |     kind: ast::ClassSetBinaryOpKind::Intersection,\n602 | |     lhs: Box::new(ClassSet::new()),\n603 | |     rhs: Box::new(ClassSet::new()),\n604 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n599 |     let binary_op_intersection = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:606:13\n    |\n606 |     let _ = fmt(&binary_op_intersection, &mut output_intersection);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n606 |     let _ = (&binary_op_intersection).fmt(&mut output_intersection);\n    |             ~                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:607:54\n    |\n607 |       let binary_op_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n608 | |     span,\n609 | |     kind: ast::ClassSetBinaryOpKind::Difference,\n610 | |     lhs: Box::new(ClassSet::new()),\n611 | |     rhs: Box::new(ClassSet::new()),\n612 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n607 |     let binary_op_difference = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:614:13\n    |\n614 |     let _ = fmt(&binary_op_difference, &mut output_difference);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n614 |     let _ = (&binary_op_difference).fmt(&mut output_difference);\n    |             ~                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:615:64\n    |\n615 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ast::ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n616 | |     span,\n617 | |     kind: ast::ClassSetBinaryOpKind::SymmetricDifference,\n618 | |     lhs: Box::new(ClassSet::new()),\n619 | |     rhs: Box::new(ClassSet::new()),\n620 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n615 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp {\n    |                                                                +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:622:13\n    |\n622 |     let _ = fmt(&binary_op_symmetric_difference, &mut output_symmetric_difference);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n622 |     let _ = (&binary_op_symmetric_difference).fmt(&mut output_symmetric_difference);\n    |             ~                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 43 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, Span, ClassSetUnion};",
                "",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let union = ClassSetUnion::new(); // assuming a valid initialization method",
                "    let item = ClassInduct::Item(ClassSetItem::Union(union));",
                "",
                "    let mut output = String::new();",
                "    let _ = fmt(&item, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let union = ClassSetUnion::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Union(union));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Union)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, Span, ClassSetUnion};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let union = ClassSetUnion::new(); // assuming a valid initialization method",
                  "    let item = ClassInduct::Item(ClassSetItem::Union(union));",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let union = ClassSetUnion::new();",
                  "    let item = ClassInduct::Item(ClassSetItem::Union(union));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&item, &mut output);",
                  "    assert_eq!(output, \"Item(Union)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:568:32\n     |\n568  |     let union = ClassSetUnion::new(); // assuming a valid initialization method\n     |                                ^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:569:34\n    |\n569 |     let item = ClassInduct::Item(ClassSetItem::Union(union));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n569 |     let item = ClassInduct::Item(&ClassSetItem::Union(union));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n572 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:30\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:573:38\n    |\n573 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `new` found for struct `ClassSetUnion` in the current scope\n    --> regex-syntax/src/ast/visitor.rs:574:32\n     |\n574  |     let union = ClassSetUnion::new();\n     |                                ^^^ function or associated item not found in `ClassSetUnion`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1027:1\n     |\n1027 | pub struct ClassSetUnion {\n     | ------------------------ function or associated item `new` not found for this struct\n     |\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let item = ClassInduct::Item(ClassSetItem::Union(union));\n    |                ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                |\n    |                arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n575 |     let item = ClassInduct::Item(&ClassSetItem::Union(union));\n    |                                  +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:577:13\n    |\n577 |     let _ = fmt(&item, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n577 |     let _ = (&item).fmt(&mut output);\n    |             ~     ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                "",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(lhs),",
                "        rhs: Box::new(rhs),",
                "    });",
                "",
                "    let mut output = String::new();",
                "    let _ = fmt(&binary_op, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    assert_eq!(output, \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:594:66\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                  ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:39\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n594 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:596:13\n    |\n596 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n596 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:594:66\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                  ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:597:63\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:39\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n594 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:596:13\n    |\n596 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n596 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:597:39\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n597 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:594:66\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                  ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:597:63\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:600:77\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:39\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n594 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:596:13\n    |\n596 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n596 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:597:39\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n597 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:600:39\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n600 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:602:13\n    |\n602 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n602 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:594:66\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                  ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:597:63\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:600:77\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:603:64\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:39\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n594 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:596:13\n    |\n596 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n596 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:597:39\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n597 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:600:39\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n600 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:602:13\n    |\n602 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n602 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:603:39\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n603 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:605:13\n    |\n605 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n605 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:594:66\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                  ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:597:63\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:600:77\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:603:64\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:39\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n594 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:596:13\n    |\n596 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n596 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:597:39\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n597 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:600:39\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n600 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:602:13\n    |\n602 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n602 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:603:39\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n603 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:605:13\n    |\n605 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n605 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:606:43\n    |\n606 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n606 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:608:13\n    |\n608 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n608 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 36 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:594:66\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                  ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:597:63\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:600:77\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:603:64\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:39\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n594 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:596:13\n    |\n596 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n596 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:597:39\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n597 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:600:39\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n600 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:602:13\n    |\n602 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n602 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:603:39\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n603 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:605:13\n    |\n605 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n605 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:606:43\n    |\n606 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n606 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:608:13\n    |\n608 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n608 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:609:43\n    |\n609 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n609 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:611:13\n    |\n611 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n611 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 38 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:585:66\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:588:64\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:591:64\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:594:66\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                  ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:597:63\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:600:77\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                             ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:603:64\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Intersection,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:39\n    |\n582 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:584:13\n    |\n584 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n584 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:39\n    |\n585 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new('a')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new('a')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:587:13\n    |\n587 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n587 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:39\n    |\n588 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new('a', 'z')));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:590:13\n    |\n590 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n590 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:39\n    |\n591 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:593:13\n    |\n593 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n593 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:594:39\n    |\n594 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n594 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:596:13\n    |\n596 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n596 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:597:39\n    |\n597 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n597 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:599:13\n    |\n599 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n599 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:600:39\n    |\n600 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n600 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:602:13\n    |\n602 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n602 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:603:39\n    |\n603 |     let binary_op = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n603 |     let binary_op = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                       +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:605:13\n    |\n605 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n605 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:606:43\n    |\n606 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n606 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:608:13\n    |\n608 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n608 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:609:43\n    |\n609 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n609 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:611:13\n    |\n611 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n611 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:612:43\n    |\n612 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n612 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:614:13\n    |\n614 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n614 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 40 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                "",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::Difference,",
                "        lhs: Box::new(lhs),",
                "        rhs: Box::new(rhs),",
                "    });",
                "",
                "    let mut output = String::new();",
                "    let _ = fmt(&binary_op, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_empty), \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_literal), \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_range), \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_ascii), \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_unicode), \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_perl), \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_bracketed), \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_union), \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_intersection), \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_difference), \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_symmetric_difference), \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_empty), \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_literal), \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_range), \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_ascii), \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_unicode), \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_perl), \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_bracketed), \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", item_union), \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_intersection), \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_difference), \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "    span,",
                  "    kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(lhs),",
                  "    rhs: Box::new(rhs),",
                  "    });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_symmetric_difference), \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::Difference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 1 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 |       let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________---------------------_^\n    | |                                  |\n    | |                                  arguments to this enum variant are incorrect\n591 | |     span,\n592 | |     kind: ClassSetBinaryOpKind::Intersection,\n593 | |     lhs: Box::new(lhs),\n594 | |     rhs: Box::new(rhs),\n595 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:596:54\n    |\n596 |       let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  ________________________________---------------------_^\n    | |                                |\n    | |                                arguments to this enum variant are incorrect\n597 | |     span,\n598 | |     kind: ClassSetBinaryOpKind::Difference,\n599 | |     lhs: Box::new(lhs),\n600 | |     rhs: Box::new(rhs),\n601 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n596 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:602:64\n    |\n602 |       let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  __________________________________________---------------------_^\n    | |                                          |\n    | |                                          arguments to this enum variant are incorrect\n603 | |     span,\n604 | |     kind: ClassSetBinaryOpKind::SymmetricDifference,\n605 | |     lhs: Box::new(lhs),\n606 | |     rhs: Box::new(rhs),\n607 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n602 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                "",
                "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                "        span,",
                "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                "        lhs: Box::new(lhs),",
                "        rhs: Box::new(rhs),",
                "    });",
                "",
                "    let mut output = String::new();",
                "    let _ = fmt(&binary_op, &mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_empty), \"Item(Empty)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_literal), \"Item(Literal)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_range), \"Item(Range)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_ascii), \"Item(Ascii)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_unicode), \"Item(Unicode)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_perl), \"Item(Perl)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_bracketed), \"Item(Bracketed)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_union), \"Item(Union)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_intersection), \"BinaryOp(Intersection)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_difference), \"BinaryOp(Difference)\");"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_symmetric_difference), \"BinaryOp(SymmetricDifference)\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_empty), \"Item(Empty)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_literal), \"Item(Literal)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_range), \"Item(Range)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_ascii), \"Item(Ascii)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_unicode), \"Item(Unicode)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_perl), \"Item(Perl)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_bracketed), \"Item(Bracketed)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", item_union), \"Item(Union)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_intersection), \"BinaryOp(Intersection)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_difference), \"BinaryOp(Difference)\");",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetBinaryOpKind, ClassSetBinaryOp, Span};",
                  "",
                  "    let span = Span { start: 0, end: 1 }; // assuming a valid span",
                  "    let lhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let rhs = ClassSet::new(); // assuming a valid initialization method",
                  "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
                  "        span,",
                  "        kind: ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(lhs),",
                  "        rhs: Box::new(rhs),",
                  "    });",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = fmt(&binary_op, &mut output);",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let lhs = ClassSet::new();",
                  "    let rhs = ClassSet::new();",
                  "    let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));",
                  "    let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));",
                  "    let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));",
                  "    let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));",
                  "    let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));",
                  "    let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));",
                  "    let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));",
                  "    let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));",
                  "    let binary_op_intersection = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    let binary_op_symmetric_difference = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });",
                  "    assert_eq!(format!(\"{:?}\", binary_op_symmetric_difference), \"BinaryOp(SymmetricDifference)\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |     let lhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |     let rhs = ClassSet::new(); // assuming a valid initialization method\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:15\n    |\n580 |     let lhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:15\n    |\n581 |     let rhs = ClassSet::new();\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:583:69\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                                                                     ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetRange`\n   --> regex-syntax/src/ast/visitor.rs:584:65\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetRange`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetRange;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassAscii`\n   --> regex-syntax/src/ast/visitor.rs:585:65\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                                                 ^^^^^^^^^^ use of undeclared type `ClassAscii`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassAscii;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/visitor.rs:586:69\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n560 +    use ast::ClassUnicode;\n    |\n560 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/visitor.rs:587:63\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                                               ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:588:82\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                                                                  ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetUnion`\n   --> regex-syntax/src/ast/visitor.rs:589:65\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                                                 ^^^^^^^^^^^^^ use of undeclared type `ClassSetUnion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassSetUnion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:30\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:567:38\n    |\n567 |     let span = Span { start: 0, end: 1 }; // assuming a valid span\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:570:43\n    |\n570 |       let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {\n    |  _____________________---------------------_^\n    | |                     |\n    | |                     arguments to this enum variant are incorrect\n571 | |         span,\n572 | |         kind: ClassSetBinaryOpKind::SymmetricDifference,\n573 | |         lhs: Box::new(lhs),\n574 | |         rhs: Box::new(rhs),\n575 | |     });\n    | |_____^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n570 |     let binary_op = ClassInduct::BinaryOp(&ClassSetBinaryOp {\n    |                                           +\n\nerror[E0423]: expected function, found module `fmt`\n   --> regex-syntax/src/ast/visitor.rs:578:13\n    |\n578 |     let _ = fmt(&binary_op, &mut output);\n    |             ^^^ not a function\n    |\nhelp: use the `.` operator to call the method `Debug::fmt` on `&ast::visitor::ClassInduct<'_>`\n    |\n578 |     let _ = (&binary_op).fmt(&mut output);\n    |             ~          ~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:30\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:579:38\n    |\n579 |     let span = Span { start: 0, end: 0 };\n    |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:582:40\n    |\n582 |     let item_empty = ClassInduct::Item(ast::ClassSetItem::Empty(span));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n582 |     let item_empty = ClassInduct::Item(&ast::ClassSetItem::Empty(span));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let item_literal = ClassInduct::Item(ast::ClassSetItem::Literal(Literal::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n583 |     let item_literal = ClassInduct::Item(&ast::ClassSetItem::Literal(Literal::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:584:40\n    |\n584 |     let item_range = ClassInduct::Item(ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n584 |     let item_range = ClassInduct::Item(&ast::ClassSetItem::Range(ClassSetRange::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:585:40\n    |\n585 |     let item_ascii = ClassInduct::Item(ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n585 |     let item_ascii = ClassInduct::Item(&ast::ClassSetItem::Ascii(ClassAscii::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:586:42\n    |\n586 |     let item_unicode = ClassInduct::Item(ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                        ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                        |\n    |                        arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n586 |     let item_unicode = ClassInduct::Item(&ast::ClassSetItem::Unicode(ClassUnicode::new()));\n    |                                          +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:587:39\n    |\n587 |     let item_perl = ClassInduct::Item(ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                     ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                     |\n    |                     arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n587 |     let item_perl = ClassInduct::Item(&ast::ClassSetItem::Perl(ClassPerl::new()));\n    |                                       +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:588:44\n    |\n588 |     let item_bracketed = ClassInduct::Item(ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                          ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                          |\n    |                          arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n588 |     let item_bracketed = ClassInduct::Item(&ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new())));\n    |                                            +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:589:40\n    |\n589 |     let item_union = ClassInduct::Item(ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                      ----------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetItem`, found `ClassSetItem`\n    |                      |\n    |                      arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:212:5\n    |\n212 |     Item(&'a ast::ClassSetItem),\n    |     ^^^^\nhelp: consider borrowing here\n    |\n589 |     let item_union = ClassInduct::Item(&ast::ClassSetItem::Union(ClassSetUnion::new()));\n    |                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:590:56\n    |\n590 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n590 |     let binary_op_intersection = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Intersection, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                        +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:591:54\n    |\n591 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n591 |     let binary_op_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::Difference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                      +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/visitor.rs:592:64\n    |\n592 | ... = ClassInduct::BinaryOp(ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) ...\n    |       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassSetBinaryOp`, found `ClassSetBinaryOp`\n    |       |\n    |       arguments to this enum variant are incorrect\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/visitor.rs:213:5\n    |\n213 |     BinaryOp(&'a ast::ClassSetBinaryOp),\n    |     ^^^^^^^^\nhelp: consider borrowing here\n    |\n592 |     let binary_op_symmetric_difference = ClassInduct::BinaryOp(&ClassSetBinaryOp { span, kind: ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(lhs), rhs: Box::new(rhs) });\n    |                                                                +\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0423, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}