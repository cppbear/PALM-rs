{
  "name": "regex_syntax::hir::hir::HirKind::has_subexprs",
  "name_with_impl": "regex_syntax::hir::{impl#6}::has_subexprs",
  "mod_info": {
    "name": "hir",
    "loc": "regex-syntax/src/lib.rs:116:1:116:13"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/mod.rs:595:5:607:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Alternation(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "HirKind::Alternation(vec![HirKind::Literal(Literal { c: 'a' }), HirKind::Literal(Literal { c: 'b' })])\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                "    let alternation = HirKind::Alternation(vec![literal_a, literal_b]);",
                "    alternation.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                  "    let alternation = HirKind::Alternation(vec![literal_a, literal_b]);",
                  "    assert!(alternation.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                  "    let alternation = HirKind::Alternation(vec![literal_a, literal_b]);",
                  "    alternation.has_subexprs();",
                  "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                  "    let alternation = HirKind::Alternation(vec![literal_a, literal_b]);",
                  "    assert!(alternation.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:38\n     |\n2068 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:77\n     |\n2068 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:38\n     |\n2069 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:77\n     |\n2069 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2072:38\n     |\n2072 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2072:77\n     |\n2072 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2073:38\n     |\n2073 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2073:77\n     |\n2073 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:60\n     |\n2068 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:60\n     |\n2069 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:49\n     |\n2070 |     let alternation = HirKind::Alternation(vec![literal_a, literal_b]);\n     |                                                 ^^^^^^^^^ expected `Hir`, found `HirKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:60\n     |\n2072 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:60\n     |\n2073 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2074:49\n     |\n2074 |     let alternation = HirKind::Alternation(vec![literal_a, literal_b]);\n     |                                                 ^^^^^^^^^ expected `Hir`, found `HirKind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alternation = HirKind::Alternation(vec![]);",
                "    alternation.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let alternation = HirKind::Alternation(vec![]);",
                  "    assert_eq!(alternation.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alternation = HirKind::Alternation(vec![]);",
                  "    alternation.has_subexprs();",
                  "    let alternation = HirKind::Alternation(vec![]);",
                  "    assert_eq!(alternation.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                "    let literal_c = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' });",
                "    let alternation = HirKind::Alternation(vec![literal_a, literal_b, literal_c]);",
                "    alternation.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                  "    let literal_c = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' });",
                  "    let alternation = HirKind::Alternation(vec![literal_a, literal_b, literal_c]);",
                  "    assert!(alternation.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                  "    let literal_c = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' });",
                  "    let alternation = HirKind::Alternation(vec![literal_a, literal_b, literal_c]);",
                  "    alternation.has_subexprs();",
                  "    let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });",
                  "    let literal_c = HirKind::Literal(Literal::Unicode('c'));",
                  "    let alternation = HirKind::Alternation(vec![literal_a, literal_b, literal_c]);",
                  "    assert!(alternation.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:38\n     |\n2068 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:77\n     |\n2068 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:38\n     |\n2069 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:77\n     |\n2069 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2070:38\n     |\n2070 |     let literal_c = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:77\n     |\n2070 |     let literal_c = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2073:38\n     |\n2073 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2073:77\n     |\n2073 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2074:38\n     |\n2074 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2074:77\n     |\n2074 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:60\n     |\n2068 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:60\n     |\n2069 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:60\n     |\n2070 |     let literal_c = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2071:49\n     |\n2071 |     let alternation = HirKind::Alternation(vec![literal_a, literal_b, literal_c]);\n     |                                                 ^^^^^^^^^ expected `Hir`, found `HirKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:60\n     |\n2073 |     let literal_a = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:60\n     |\n2074 |     let literal_b = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' });\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2076:49\n     |\n2076 |     let alternation = HirKind::Alternation(vec![literal_a, literal_b, literal_c]);\n     |                                                 ^^^^^^^^^ expected `Hir`, found `HirKind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let nested_alternation = HirKind::Alternation(vec![HirKind::Alternation(vec![",
                "        HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }),",
                "        HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })",
                "    ])]);",
                "    nested_alternation.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let nested_alternation = HirKind::Alternation(vec![HirKind::Alternation(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })])]);",
                  "    assert!(nested_alternation.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let nested_alternation = HirKind::Alternation(vec![HirKind::Alternation(vec![",
                  "        HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }),",
                  "        HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })",
                  "    ])]);",
                  "    nested_alternation.has_subexprs();",
                  "    let nested_alternation = HirKind::Alternation(vec![HirKind::Alternation(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })])]);",
                  "    assert!(nested_alternation.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:26\n     |\n2069 |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }),\n     |                          ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:65\n     |\n2069 |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }),\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2070:26\n     |\n2070 |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })\n     |                          ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:65\n     |\n2070 |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2073:99\n     |\n2073 | ...![HirKind::Alternation(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), HirKind::Lit...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2073:138\n     |\n2073 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), HirKind::Literal(Literal { span: Span::default(), kin...\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2073:193\n     |\n2073 | ...d::Unicode('d'), c: 'd' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })])]);\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2073:232\n     |\n2073 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })])]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:48\n     |\n2069 |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }),\n     |                                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2069:9\n     |\n2069 |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }),\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Hir`, found `HirKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:48\n     |\n2070 |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })\n     |                                                ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:56\n     |\n2068 |       let nested_alternation = HirKind::Alternation(vec![HirKind::Alternation(vec![\n     |  ________________________________________________________^\n2069 | |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }),\n2070 | |         HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })\n2071 | |     ])]);\n     | |______^ expected `Hir`, found `HirKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:121\n     |\n2073 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), HirKind::Literal(Literal { span: Span::def...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2073:82\n     |\n2073 | ...vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), HirKind::Literal(Literal { span: Sp...\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Hir`, found `HirKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:215\n     |\n2073 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })])]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2073:56\n     |\n2073 | ...c![HirKind::Alternation(vec![HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' })])...\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Hir`, found `HirKind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Concat(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "HirKind::Concat(Vec<Hir>) with length >= 2 and valid Hir instances\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default() };",
                "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default() };",
                "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2]);",
                "    concat_expr.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default() };",
                  "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2]);",
                  "    assert_eq!(concat_expr.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default() };",
                  "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2]);",
                  "    concat_expr.has_subexprs();",
                  "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default() };",
                  "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2]);",
                  "    assert_eq!(concat_expr.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:49\n     |\n2068 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:88\n     |\n2068 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:49\n     |\n2069 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:88\n     |\n2069 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2072:49\n     |\n2072 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2072:88\n     |\n2072 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2073:49\n     |\n2073 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2073:88\n     |\n2073 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:71\n     |\n2068 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2068 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:71\n     |\n2069 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2069 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:71\n     |\n2072 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:71\n     |\n2073 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2073 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('b'), c: 'b' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default() };",
                "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default() };",
                "    let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default() };",
                "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2, subexpr3]);",
                "    concat_expr.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default() };",
                  "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default() };",
                  "    let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2, subexpr3]);",
                  "    assert!(concat_expr.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default() };",
                  "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default() };",
                  "    let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2, subexpr3]);",
                  "    concat_expr.has_subexprs();",
                  "    let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default() };",
                  "    let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default() };",
                  "    let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![subexpr1, subexpr2, subexpr3]);",
                  "    assert!(concat_expr.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:49\n     |\n2068 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:88\n     |\n2068 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:49\n     |\n2069 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:88\n     |\n2069 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2070:49\n     |\n2070 |     let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:88\n     |\n2070 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2073:49\n     |\n2073 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2073:88\n     |\n2073 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2074:49\n     |\n2074 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2074:88\n     |\n2074 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2075:49\n     |\n2075 |     let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2075:88\n     |\n2075 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default() };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:71\n     |\n2068 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2068 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:71\n     |\n2069 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2069 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:71\n     |\n2070 |     let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2070 |     let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:71\n     |\n2073 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2073 |     let subexpr1 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('x'), c: 'x' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:71\n     |\n2074 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2074 |     let subexpr2 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('y'), c: 'y' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:71\n     |\n2075 |     let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInf...\n     |                                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:141\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2075 |     let subexpr3 = Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('z'), c: 'z' }), info: HirInfo::default()...\n     |                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                "    let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group) }), info: HirInfo::default() };",
                "    let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);",
                "    concat_expr.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                  "    let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group) }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);",
                  "    assert!(concat_expr.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                  "    let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group) }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);",
                  "    concat_expr.has_subexprs();",
                  "    let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                  "    let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group) }), info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);",
                  "    assert!(concat_expr.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:155\n     |\n2068 | ..., hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:194\n     |\n2068 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::defau...\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2070:86\n     |\n2070 |     let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::...\n     |                                                                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:125\n     |\n2070 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2072:155\n     |\n2072 | ..., hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2072:194\n     |\n2072 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::defau...\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2074:86\n     |\n2074 |     let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::...\n     |                                                                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2074:125\n     |\n2074 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: ...\n     |                                                          ^^^^ `hir::Group` does not have this field\n     |\n     = note: all struct fields are already assigned\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:70\n     |\n2068 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: ...\n     |                                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:98\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2068 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: ...\n     |                                                                                                  ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2068 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default() };\n     |                                                                                                  ~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:177\n     |\n2068 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: Hir...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:247\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2068 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                                                                                       ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:280\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2068 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default()...\n     |                                                                                                                                                                                                                                                                                        ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2069:58\n     |\n2069 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group)...\n     |                                                          ^^^^ `hir::Group` does not have this field\n     |\n     = note: all struct fields are already assigned\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:70\n     |\n2069 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group)...\n     |                                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:98\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2069 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group)...\n     |                                                                                                  ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2069 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, hir: Box::new(inner_group) }), info: HirInfo::default() };\n     |                                                                                                  ~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:158\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2069 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group) }), info: HirInfo::default()...\n     |                                                                                                                                                              ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:108\n     |\n2070 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:178\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2070 |     let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                  ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2072:58\n     |\n2072 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: ...\n     |                                                          ^^^^ `hir::Group` does not have this field\n     |\n     = note: all struct fields are already assigned\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:70\n     |\n2072 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: ...\n     |                                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:98\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2072 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: ...\n     |                                                                                                  ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2072 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default() };\n     |                                                                                                  ~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:177\n     |\n2072 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: Hir...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:247\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                                                                                       ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:280\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let inner_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('c'), c: 'c' }), info: HirInfo::default() }) }) , info: HirInfo::default()...\n     |                                                                                                                                                                                                                                                                                        ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2073:58\n     |\n2073 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group)...\n     |                                                          ^^^^ `hir::Group` does not have this field\n     |\n     = note: all struct fields are already assigned\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:70\n     |\n2073 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group)...\n     |                                                                      ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:98\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2073 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group)...\n     |                                                                                                  ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2073 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, hir: Box::new(inner_group) }), info: HirInfo::default() };\n     |                                                                                                  ~~~~~~~~~~~~\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:158\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2073 |     let outer_group = Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(1), hir: Box::new(inner_group) }), info: HirInfo::default()...\n     |                                                                                                                                                              ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:108\n     |\n2074 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() }]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:178\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2074 |     let concat_expr = HirKind::Concat(vec![outer_group, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('d'), c: 'd' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                  ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                "    let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);",
                "    concat_expr.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);",
                  "    assert!(concat_expr.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);",
                  "    concat_expr.has_subexprs();",
                  "    let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default() };",
                  "    let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);",
                  "    assert!(concat_expr.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2068:95\n     |\n2068 | ...n(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal {...\n     |                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2068 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default() };\n     |                                                                                               ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:178\n     |\n2068 | ..., hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:217\n     |\n2068 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::defau...\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:86\n     |\n2069 |     let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::...\n     |                                                                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:125\n     |\n2069 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2071:95\n     |\n2071 | ...n(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal {...\n     |                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2071 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default() };\n     |                                                                                               ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:178\n     |\n2071 | ..., hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:217\n     |\n2071 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::defau...\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2072:86\n     |\n2072 |     let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::...\n     |                                                                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2072:125\n     |\n2072 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2068:68\n     |\n2068 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir...\n     |                                                                    ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:80\n     |\n2068 | ...:Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2068:91\n     |\n2068 | ...etition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Lit...\n     |                                                ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:200\n     |\n2068 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: Hir...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:270\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2068 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                                                                                                              ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:303\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2068 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default()...\n     |                                                                                                                                                                                                                                                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:108\n     |\n2069 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:178\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2069 |     let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                  ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2071:68\n     |\n2071 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir...\n     |                                                                    ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:80\n     |\n2071 | ...:Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2071:91\n     |\n2071 | ...etition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Lit...\n     |                                                ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:200\n     |\n2071 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: Hir...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:270\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2071 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                                                                                                              ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:303\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2071 |     let repeat_expr = Hir { kind: HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('e'), c: 'e' }), info: HirInfo::default() }) }) , info: HirInfo::default()...\n     |                                                                                                                                                                                                                                                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:108\n     |\n2072 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() }]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:178\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let concat_expr = HirKind::Concat(vec![repeat_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('f'), c: 'f' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                  ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alt_expr = HirKind::Alternation(vec![",
                "        Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() },",
                "        Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }",
                "    ]);",
                "    let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);",
                "    concat_expr.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let alt_expr = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() }, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }]);",
                  "    let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);",
                  "    assert!(concat_expr.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alt_expr = HirKind::Alternation(vec![",
                  "        Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }",
                  "    ]);",
                  "    let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);",
                  "    concat_expr.has_subexprs();",
                  "    let alt_expr = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() }, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }]);",
                  "    let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);",
                  "    assert!(concat_expr.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:38\n     |\n2069 | ...   Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() },\n     |                                    ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:77\n     |\n2069 | ...   Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() },\n     |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2070:38\n     |\n2070 |         Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }\n     |                                      ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:77\n     |\n2070 |         Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }\n     |                                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2072:83\n     |\n2072 |     let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Uni...\n     |                                                                                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2072:122\n     |\n2072 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2074:75\n     |\n2074 |     let alt_expr = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'...\n     |                                                                           ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2074:114\n     |\n2074 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() }, Hir { kind: HirKind::Lite...\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2074:209\n     |\n2074 | ...o::default() }, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInf...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2074:248\n     |\n2074 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2075:83\n     |\n2075 |     let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Uni...\n     |                                                                                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2075:122\n     |\n2075 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:60\n     |\n2069 | ...   Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() },\n     |                                                          ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:130\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2069 |         Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default()...\n     |                                                                                                                                  ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:60\n     |\n2070 |         Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }\n     |                                                            ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:130\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2070 |         Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }\n     |                                                                                                                                  ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2072:44\n     |\n2072 |     let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Uni...\n     |                                            ^^^^^^^^ expected `Hir`, found `HirKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:105\n     |\n2072 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:175\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() ...\n     |                                                                                                                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:97\n     |\n2074 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() }, Hir { kind: Hi...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:167\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2074 |     let alt_expr = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() ...\n     |                                                                                                                                                                       ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:231\n     |\n2074 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() }]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:301\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2074 |     let alt_expr = HirKind::Alternation(vec![Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('g'), c: 'g' }), info: HirInfo::default() }, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('h'), c: 'h' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                                                                                                                                             ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2075:44\n     |\n2075 |     let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Uni...\n     |                                            ^^^^^^^^ expected `Hir`, found `HirKind`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:105\n     |\n2075 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() }]);\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:175\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2075 |     let concat_expr = HirKind::Concat(vec![alt_expr, Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('i'), c: 'i' }), info: HirInfo::default() ...\n     |                                                                                                                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Group(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "test input ranges: HirKind::Group(Group { span: Span { start: 0, end: 1 }, kind: GroupKind::Capturing(0), ast: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'a' }), info: HirInfo::default() }) })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };",
                "    let hir = Hir { kind: HirKind::Literal(literal), info: HirInfo::default() };",
                "    let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };",
                "    let hir_kind = HirKind::Group(group);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };",
                  "    let hir = Hir { kind: HirKind::Literal(literal), info: HirInfo::default() };",
                  "    let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    assert!(hir_kind.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };",
                  "    let hir = Hir { kind: HirKind::Literal(literal), info: HirInfo::default() };",
                  "    let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    hir_kind.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };",
                  "    let hir = Hir { kind: HirKind::Literal(literal), info: HirInfo::default() };",
                  "    let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    assert!(hir_kind.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:19\n     |\n2069 |     let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:41\n     |\n2069 |     let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };\n     |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2075:19\n     |\n2075 |     let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2075:41\n     |\n2075 |     let literal = Literal { span, kind: LiteralKind::Unicode, c: 'a' };\n     |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:30\n     |\n2068 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:38\n     |\n2068 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:69\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2070 |     let hir = Hir { kind: HirKind::Literal(literal), info: HirInfo::default() };\n     |                                                                     ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2071:25\n     |\n2071 |     let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2071 |     let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2071 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(hir) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2071:62\n     |\n2071 |     let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2074:30\n     |\n2074 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2074:38\n     |\n2074 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2076:69\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2076 |     let hir = Hir { kind: HirKind::Literal(literal), info: HirInfo::default() };\n     |                                                                     ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2077:25\n     |\n2077 |     let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2077 |     let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2077 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(hir) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2077:62\n     |\n2077 |     let group = Group { span, kind: GroupKind::Capturing(0), ast: Box::new(hir) };\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };",
                "    let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() }) };",
                "    let hir_kind = HirKind::Group(group);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };",
                  "    let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert!(result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };",
                  "    let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    hir_kind.has_subexprs();",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };",
                  "    let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert!(result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2069:45\n     |\n2069 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2069 |     let repetition = Repetition { span, op: Repetition::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };\n     |                                             ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:122\n     |\n2069 | ..., ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:144\n     |\n2069 | ...nd: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2074:45\n     |\n2074 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2074 |     let repetition = Repetition { span, op: Repetition::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };\n     |                                             ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2074:122\n     |\n2074 | ..., ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2074:144\n     |\n2074 | ...nd: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() }) };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:30\n     |\n2068 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:38\n     |\n2068 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2069:35\n     |\n2069 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                   ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2069:41\n     |\n2069 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                         ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2069:79\n     |\n2069 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                                                               ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:192\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2069 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                                ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2070:25\n     |\n2070 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::de...\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2070 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::de...\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2070 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() }) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2070:62\n     |\n2070 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::de...\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:136\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2070 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() ...\n     |                                                                                                                                        ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2073:30\n     |\n2073 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2073:38\n     |\n2073 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2074:35\n     |\n2074 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                   ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2074:41\n     |\n2074 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                         ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2074:79\n     |\n2074 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, ...\n     |                                                                               ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:192\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2074 |     let repetition = Repetition { span, op: RepetitionOp::Star, greedy: true, ast: Box::new(Hir { kind: HirKind::Literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' }), info: HirInfo::default() ...\n     |                                                                                                                                                                                                ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2075:25\n     |\n2075 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::de...\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2075 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::de...\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2075 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() }) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2075:62\n     |\n2075 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::de...\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:136\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2075 |     let group = Group { span, kind: GroupKind::Capturing(1), ast: Box::new(Hir { kind: HirKind::Repetition(repetition), info: HirInfo::default() ...\n     |                                                                                                                                        ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 3 };",
                "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };",
                "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };",
                "    let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                "    let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() }) };",
                "    let hir_kind = HirKind::Group(group);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };",
                  "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };",
                  "    let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                  "    let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    assert!(hir_kind.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };",
                  "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };",
                  "    let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                  "    let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    hir_kind.has_subexprs();",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };",
                  "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };",
                  "    let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                  "    let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    assert!(hir_kind.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:16\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:65\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2070:16\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:65\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2076:16\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2076:65\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2077:16\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2077:65\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:30\n     |\n2068 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:38\n     |\n2068 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2069:46\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2069:54\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:46\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:54\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:74\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2071 |     let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::...\n     |                                                                          ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:138\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2071 |     let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() ...\n     |                                                                                                                                          ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2072:25\n     |\n2072 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2072 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2072 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() }) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2072:62\n     |\n2072 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:128\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                                                                                                                                ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2075:30\n     |\n2075 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2075:38\n     |\n2075 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2076:46\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2076:54\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'c' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2077:46\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2077:54\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'd' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:74\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2078 |     let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::...\n     |                                                                          ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:138\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2078 |     let concat = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() ...\n     |                                                                                                                                          ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2079:25\n     |\n2079 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2079 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2079 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() }) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2079:62\n     |\n2079 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:128\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2079 |     let group = Group { span, kind: GroupKind::Capturing(2), ast: Box::new(Hir { kind: HirKind::Concat(concat), info: HirInfo::default() ...\n     |                                                                                                                                ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 4 };",
                "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };",
                "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };",
                "    let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                "    let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() }) };",
                "    let hir_kind = HirKind::Group(group);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 4 };",
                  "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };",
                  "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };",
                  "    let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                  "    let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    assert!(hir_kind.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };",
                  "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };",
                  "    let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                  "    let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    hir_kind.has_subexprs();",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };",
                  "    let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };",
                  "    let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() }];",
                  "    let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() }) };",
                  "    let hir_kind = HirKind::Group(group);",
                  "    assert!(hir_kind.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:16\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:65\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2070:16\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:65\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2076:16\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2076:65\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2077:16\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2077:65\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                                                                 ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:30\n     |\n2068 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2068:38\n     |\n2068 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2069:46\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2069:54\n     |\n2069 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:46\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:54\n     |\n2070 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:79\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2071 |     let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirI...\n     |                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:143\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2071 |     let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() ...\n     |                                                                                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2072:25\n     |\n2072 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::...\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2072 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::...\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2072 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() }) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2072:62\n     |\n2072 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::...\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:138\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() ...\n     |                                                                                                                                          ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2075:30\n     |\n2075 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2075:38\n     |\n2075 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2076:46\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2076:54\n     |\n2076 |     let lit1 = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Unicode, c: 'e' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2077:46\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2077:54\n     |\n2077 |     let lit2 = Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Unicode, c: 'f' };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:79\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2078 |     let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirI...\n     |                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:143\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2078 |     let alternation = vec![Hir { kind: HirKind::Literal(lit1), info: HirInfo::default() }, Hir { kind: HirKind::Literal(lit2), info: HirInfo::default() ...\n     |                                                                                                                                               ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2079:25\n     |\n2079 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::...\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:48\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2079 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::...\n     |                                                ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2079 |     let group = Group { span, kind: GroupKind::NonCapturing, ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() }) };\n     |                                                ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2079:62\n     |\n2079 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::...\n     |                                                              ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:138\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2079 |     let group = Group { span, kind: GroupKind::Capturing(3), ast: Box::new(Hir { kind: HirKind::Alternation(alternation), info: HirInfo::default() ...\n     |                                                                                                                                          ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Repetition(_) is true\n",
        "// expected return value/type: true\n"
      ],
      "input_infer": "Repetition kind: any valid repetition kind, greedy: true or false, associated expression: any valid Hir type.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::ZeroOrMore, // Assuming a valid RepetitionKind",
                "        greedy: true,",
                "        hir: Box::new(Hir {",
                "            kind: HirKind::Literal(Literal {",
                "                span: Span::default(), // Assuming a default span",
                "                kind: LiteralKind::Unicode('a'), // Using a simple Unicode literal",
                "                c: 'a',",
                "            }),",
                "            info: HirInfo::default(), // Assuming a default HirInfo",
                "        }),",
                "    };",
                "    let hir_kind = HirKind::Repetition(repetition);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a', }), info: HirInfo::default(), }), };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    assert!(hir_kind.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore, // Assuming a valid RepetitionKind",
                  "        greedy: true,",
                  "        hir: Box::new(Hir {",
                  "            kind: HirKind::Literal(Literal {",
                  "                span: Span::default(), // Assuming a default span",
                  "                kind: LiteralKind::Unicode('a'), // Using a simple Unicode literal",
                  "                c: 'a',",
                  "            }),",
                  "            info: HirInfo::default(), // Assuming a default HirInfo",
                  "        }),",
                  "    };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    hir_kind.has_subexprs();",
                  "    let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a', }), info: HirInfo::default(), }), };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    assert!(hir_kind.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2072:36\n     |\n2072 |             kind: HirKind::Literal(Literal {\n     |                                    ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2074:23\n     |\n2074 |                 kind: LiteralKind::Unicode('a'), // Using a simple Unicode literal\n     |                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2082:126\n     |\n2082 | ..., hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a', }), info: HirIn...\n     |                                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2082:165\n     |\n2082 | ...ral(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a', }), info: HirInfo::default(), }), };\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:29\n     |\n2073 |                 span: Span::default(), // Assuming a default span\n     |                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:28\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2077 |             info: HirInfo::default(), // Assuming a default HirInfo\n     |                            ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:148\n     |\n2082 | ...rKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a', }), info: HirInfo::default(), }), };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:219\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2082 |     let repetition = Repetition { kind: RepetitionKind::ZeroOrMore, greedy: true, hir: Box::new(Hir { kind: HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a', }), info: HirInfo::default(),...\n     |                                                                                                                                                                                                                           ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::OneOrMore, // Assuming a valid RepetitionKind",
                "        greedy: false,",
                "        hir: Box::new(Hir {",
                "            kind: HirKind::Group(Group {",
                "                span: Span::default(), // Assuming a default span",
                "                kind: GroupKind::Capturing(0), // Assuming a capturing group kind",
                "                hir: Box::new(Hir {",
                "                    kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), // A simple class",
                "                    info: HirInfo::default(), // Assuming a default HirInfo",
                "                }),",
                "            }),",
                "            info: HirInfo::default(), // Assuming a default HirInfo",
                "        }),",
                "    };",
                "    let hir_kind = HirKind::Repetition(repetition);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), info: HirInfo::default(), }), }), info: HirInfo::default(), }), };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    assert_eq!(hir_kind.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::OneOrMore, // Assuming a valid RepetitionKind",
                  "        greedy: false,",
                  "        hir: Box::new(Hir {",
                  "            kind: HirKind::Group(Group {",
                  "                span: Span::default(), // Assuming a default span",
                  "                kind: GroupKind::Capturing(0), // Assuming a capturing group kind",
                  "                hir: Box::new(Hir {",
                  "                    kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), // A simple class",
                  "                    info: HirInfo::default(), // Assuming a default HirInfo",
                  "                }),",
                  "            }),",
                  "            info: HirInfo::default(), // Assuming a default HirInfo",
                  "        }),",
                  "    };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    hir_kind.has_subexprs();",
                  "    let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), info: HirInfo::default(), }), }), info: HirInfo::default(), }), };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    assert_eq!(hir_kind.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2073:17\n     |\n2073 |                 span: Span::default(), // Assuming a default span\n     |                 ^^^^ `hir::Group` does not have this field\n     |\n     = note: all struct fields are already assigned\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:29\n     |\n2073 |                 span: Span::default(), // Assuming a default span\n     |                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2074:34\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2074 |                 kind: GroupKind::Capturing(0), // Assuming a capturing group kind\n     |                                  ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2074 |                 kind: GroupKind::NonCapturing, // Assuming a capturing group kind\n     |                                  ~~~~~~~~~~~~\n\nerror[E0271]: type mismatch resolving `<Vec<char> as IntoIterator>::Item == ClassUnicodeRange`\n    --> regex-syntax/src/hir/mod.rs:2076:75\n     |\n2076 |                     kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), // A simple class\n     |                                                         ----------------- ^^^^^^^^^ expected `ClassUnicodeRange`, found `char`\n     |                                                         |\n     |                                                         required by a bound introduced by this call\n     |\nnote: required by a bound in `hir::ClassUnicode::new`\n    --> regex-syntax/src/hir/mod.rs:730:27\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            --- required by a bound in this associated function\n730  |     where I: IntoIterator<Item=ClassUnicodeRange>\n     |                           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `ClassUnicode::new`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:36\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2077 |                     info: HirInfo::default(), // Assuming a default HirInfo\n     |                                    ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2080:28\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2080 |             info: HirInfo::default(), // Assuming a default HirInfo\n     |                            ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2085:132\n     |\n2085 | ...: Box::new(Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind:...\n     |                                                  ^^^^ `hir::Group` does not have this field\n     |\n     = note: all struct fields are already assigned\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2085:144\n     |\n2085 | ...: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Class(Class::Unicode...\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2085:172\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2085 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0)...\n     |                                                                                                                                                                            ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2085 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, hir: Box::new(Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), info: HirInfo::default(), }), }), info: HirInfo::default(), }), };\n     |                                                                                                                                                                            ~~~~~~~~~~~~\n\nerror[E0271]: type mismatch resolving `<Vec<char> as IntoIterator>::Item == ClassUnicodeRange`\n    --> regex-syntax/src/hir/mod.rs:2085:260\n     |\n2085 | ...: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), info: HirInfo::default(), }), }), info: HirInfo::default(), }), };\n     |                                    ----------------- ^^^^^^^^^ expected `ClassUnicodeRange`, found `char`\n     |                                    |\n     |                                    required by a bound introduced by this call\n     |\nnote: required by a bound in `hir::ClassUnicode::new`\n    --> regex-syntax/src/hir/mod.rs:730:27\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            --- required by a bound in this associated function\n730  |     where I: IntoIterator<Item=ClassUnicodeRange>\n     |                           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `ClassUnicode::new`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2085:289\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2085 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), info: HirInfo::default(),...\n     |                                                                                                                                                                                                                                                                                                 ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2085:323\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2085 |     let repetition = Repetition { kind: RepetitionKind::OneOrMore, greedy: false, hir: Box::new(Hir { kind: HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), hir: Box::new(Hir { kind: HirKind::Class(Class::Unicode(ClassUnicode::new(vec!['b']))), info: HirInfo::default(), }), }), info: HirInfo::default(),...\n     |                                                                                                                                                                                                                                                                                                                                   ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0271, E0560, E0599.\nFor more information about an error, try `rustc --explain E0271`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let repetition = Repetition {",
                "        kind: RepetitionKind::ZeroOrMore, // Assuming a valid RepetitionKind",
                "        greedy: true,",
                "        hir: Box::new(Hir {",
                "            kind: HirKind::Concat(vec![",
                "                Hir {",
                "                    kind: HirKind::Literal(Literal {",
                "                        span: Span::default(), // Assuming a default span",
                "                        kind: LiteralKind::Unicode('c'), // Using a simple Unicode literal",
                "                        c: 'c',",
                "                    }),",
                "                    info: HirInfo::default(), // Assuming a default HirInfo",
                "                },",
                "                Hir {",
                "                    kind: HirKind::Class(Class::Perl(ClassPerl::Digit)), // Using Perl class",
                "                    info: HirInfo::default(), // Assuming a default HirInfo",
                "                },",
                "            ]),",
                "            info: HirInfo::default(), // Assuming a default HirInfo",
                "        }),",
                "    };",
                "    let hir_kind = HirKind::Repetition(repetition);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Literal(Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Unicode('c'),",
                  "    c: 'c',",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Class(Class::Perl(ClassPerl::Digit)),",
                  "    info: HirInfo::default(),",
                  "    },",
                  "    ]),",
                  "    info: HirInfo::default(),",
                  "    }),",
                  "    };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    assert!(hir_kind.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let repetition = Repetition {",
                  "        kind: RepetitionKind::ZeroOrMore, // Assuming a valid RepetitionKind",
                  "        greedy: true,",
                  "        hir: Box::new(Hir {",
                  "            kind: HirKind::Concat(vec![",
                  "                Hir {",
                  "                    kind: HirKind::Literal(Literal {",
                  "                        span: Span::default(), // Assuming a default span",
                  "                        kind: LiteralKind::Unicode('c'), // Using a simple Unicode literal",
                  "                        c: 'c',",
                  "                    }),",
                  "                    info: HirInfo::default(), // Assuming a default HirInfo",
                  "                },",
                  "                Hir {",
                  "                    kind: HirKind::Class(Class::Perl(ClassPerl::Digit)), // Using Perl class",
                  "                    info: HirInfo::default(), // Assuming a default HirInfo",
                  "                },",
                  "            ]),",
                  "            info: HirInfo::new(), // Using the constructor instead of default()",
                  "        }),",
                  "    };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    hir_kind.has_subexprs();",
                  "    let repetition = Repetition {",
                  "    kind: RepetitionKind::ZeroOrMore,",
                  "    greedy: true,",
                  "    hir: Box::new(Hir {",
                  "    kind: HirKind::Concat(vec![",
                  "    Hir {",
                  "    kind: HirKind::Literal(Literal {",
                  "    span: Span::default(),",
                  "    kind: LiteralKind::Unicode('c'),",
                  "    c: 'c',",
                  "    }),",
                  "    info: HirInfo::default(),",
                  "    },",
                  "    Hir {",
                  "    kind: HirKind::Class(Class::Perl(ClassPerl::Digit)),",
                  "    info: HirInfo::new(),",
                  "    },",
                  "    ]),",
                  "    info: HirInfo::default(),",
                  "    }),",
                  "    };",
                  "    let hir_kind = HirKind::Repetition(repetition);",
                  "    assert!(hir_kind.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2074:44\n     |\n2074 |                     kind: HirKind::Literal(Literal {\n     |                                            ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2076:31\n     |\n2076 |                         kind: LiteralKind::Unicode('c'), // Using a simple Unicode literal\n     |                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n    --> regex-syntax/src/hir/mod.rs:2082:54\n     |\n2082 |                     kind: HirKind::Class(Class::Perl(ClassPerl::Digit)), // Using Perl class\n     |                                                      ^^^^^^^^^ use of undeclared type `ClassPerl`\n     |\nhelp: consider importing this struct\n     |\n2060 +    use ast::ClassPerl;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2097:28\n     |\n2097 |     kind: HirKind::Literal(Literal {\n     |                            ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2099:11\n     |\n2099 |     kind: LiteralKind::Unicode('c'),\n     |           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n    --> regex-syntax/src/hir/mod.rs:2105:38\n     |\n2105 |     kind: HirKind::Class(Class::Perl(ClassPerl::Digit)),\n     |                                      ^^^^^^^^^ use of undeclared type `ClassPerl`\n     |\nhelp: consider importing this struct\n     |\n2060 +    use ast::ClassPerl;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:37\n     |\n2075 |                         span: Span::default(), // Assuming a default span\n     |                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:36\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2079 |                     info: HirInfo::default(), // Assuming a default HirInfo\n     |                                    ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Perl` found for enum `hir::Class` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:49\n     |\n666  | pub enum Class {\n     | -------------- variant or associated item `Perl` not found for this enum\n...\n2082 |                     kind: HirKind::Class(Class::Perl(ClassPerl::Digit)), // Using Perl class\n     |                                                 ^^^^ variant or associated item not found in `hir::Class`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2083:36\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2083 |                     info: HirInfo::default(), // Assuming a default HirInfo\n     |                                    ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2098:17\n     |\n2098 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2102:20\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2102 |     info: HirInfo::default(),\n     |                    ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Perl` found for enum `hir::Class` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2105:33\n     |\n666  | pub enum Class {\n     | -------------- variant or associated item `Perl` not found for this enum\n...\n2105 |     kind: HirKind::Class(Class::Perl(ClassPerl::Digit)),\n     |                                 ^^^^ variant or associated item not found in `hir::Class`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::HirInfo` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2109:20\n     |\n1296 | struct HirInfo {\n     | -------------- function or associated item `default` not found for this struct\n...\n2109 |     info: HirInfo::default(),\n     |                    ^^^^^^^ function or associated item not found in `HirInfo`\n     |\nnote: if you're trying to build a new `hir::HirInfo`, consider using `hir::HirInfo::new` which returns `hir::HirInfo`\n    --> regex-syntax/src/hir/mod.rs:1323:5\n     |\n1323 |     fn new() -> HirInfo {\n     |     ^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *self matches HirKind::WordBoundary(_) is true\n",
        "// constraint: *self matches HirKind::WordBoundary(_) or HirKind::Class(_) or HirKind::Anchor(_) or HirKind::Empty or HirKind::Literal(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "HirKind::WordBoundary(_), HirKind::Class(_), HirKind::Anchor(_), HirKind::Empty, HirKind::Literal(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir_kind = HirKind::Empty;",
                "    let result = hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let hir_kind = HirKind::Empty;",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir_kind = HirKind::Empty;",
                  "    let result = hir_kind.has_subexprs();",
                  "    let hir_kind = HirKind::Empty;",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal {",
                "        span: Span::default(),",
                "        kind: LiteralKind::Unicode('a'),",
                "        c: 'a',",
                "    };",
                "    let hir_kind = HirKind::Literal(literal);",
                "    let result = hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    assert_eq!(result, false);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Unicode('a'),",
                  "        c: 'a',",
                  "    };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    assert_eq!(result, false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal {",
                  "        span: Span::default(),",
                  "        kind: LiteralKind::Unicode('a'),",
                  "        c: 'a',",
                  "    };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal {\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:15\n     |\n2070 |         kind: LiteralKind::Unicode('a'),\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2075:19\n     |\n2075 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2075:58\n     |\n2075 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:21\n     |\n2069 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:41\n     |\n2075 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal {\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2070:15\n     |\n2070 |         kind: LiteralKind::Unicode('a'),\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2075:19\n     |\n2075 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2075:58\n     |\n2075 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:21\n     |\n2069 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:41\n     |\n2075 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class = Class::Unicode(ClassUnicode::default());",
                "    let hir_kind = HirKind::Class(class);",
                "    let result = hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    assert!(!hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    assert!(!hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    assert!(!hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert!(!hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert!(!hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });",
                  "    assert!(hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });",
                  "    assert!(hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    assert!(hir_kind.has_subexprs());"
                ],
                [
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    let hir_kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);",
                  "    assert!(hir_kind.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    assert!(!hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    assert!(!hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    assert!(!hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert!(!hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert!(!hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "",
                  "    assert!(hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(Ast::default()) });  ",
                  "    let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });",
                  "    assert!(hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    assert!(hir_kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(class);",
                  "    let hir_kind = HirKind::Empty;",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    let hir_kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);",
                  "    assert!(hir_kind.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2077:111\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(Ast::default()) });  \n     |                                                                                                               ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2078:80\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                                ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                                ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2078:128\n     |\n2078 | ...p: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2077:43\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(Ast::default()) });  \n     |                                           ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:55\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(Ast::default()) });  \n     |                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2077:97\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(Ast::default()) });  \n     |                                                                                                 ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2078:53\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                     ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:65\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2078:76\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                            ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2078:114\n     |\n2078 | ...lt(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2077:111\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                                                                               ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2078:80\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                                ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                                ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2078:128\n     |\n2078 | ...p: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2077:43\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                           ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:55\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:83\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                                                   ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(Ast::default()) });\n     |                                                                                   ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2077:97\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                                                                 ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2078:53\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                     ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:65\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2078:76\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                            ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2078:114\n     |\n2078 | ...lt(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:46\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2079 |     let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                              ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:62\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2079 |     let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                                              ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2077:111\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                                                                               ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2078:80\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                                ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                                ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2078:128\n     |\n2078 | ...p: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2077:43\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                           ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:55\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:83\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                                                   ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(Ast::default()) });\n     |                                                                                   ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2077:97\n     |\n2077 |     let hir_kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(Ast::default()) });\n     |                                                                                                 ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2078:53\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                     ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:65\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2078:76\n     |\n2078 |     let hir_kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::defau...\n     |                                                                            ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2078:114\n     |\n2078 | ...lt(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:46\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2079 |     let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                              ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2079:62\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2079 |     let hir_kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                                              ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2080:51\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2080 |     let hir_kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);\n     |                                                   ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2080:67\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2080 |     let hir_kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);\n     |                                                                   ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let anchor = Anchor::StartLine;",
                "    let hir_kind = HirKind::Anchor(anchor);",
                "    let result = hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let anchor = Anchor::StartLine;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let anchor = Anchor::StartLine;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let anchor = Anchor::StartLine;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let word_boundary = WordBoundary::Unicode;",
                "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                "    let result = hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert_eq!(result, false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    let result = hir_kind.has_subexprs();",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    let result = hir_kind.has_subexprs();",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Anchor(_) is true\n",
        "// constraint: *self matches HirKind::WordBoundary(_) or HirKind::Class(_) or HirKind::Anchor(_) or HirKind::Empty or HirKind::Literal(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "HirKind::Anchor(_) or HirKind::WordBoundary(_) or HirKind::Class(_) or HirKind::Empty or HirKind::Literal(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Empty;",
                "    let _ = kind.is_empty();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    assert!(!kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert!(!kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    assert!(!kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    assert!(!kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    assert!(!kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs());"
                ],
                [
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    assert!(!kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert!(!kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    assert!(!kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(vec![])));  ",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    assert!(!kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    assert!(!kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(vec![])));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs());",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    let _ = kind.is_empty();",
                  "    let kind = HirKind::Anchor('a');",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Literal(Literal::Unicode('b'));",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2072:46\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2072:46\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2075:105\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2075:39\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:51\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2075:91\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2075:105\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2076:76\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                            ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2076:124\n     |\n2076 | ...p: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2072:46\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2075:39\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:51\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2075:91\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2076:49\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                 ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2076:61\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2076:72\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                        ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2076:110\n     |\n2076 | ...lt(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2075:105\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2076:76\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                            ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2076:124\n     |\n2076 | ...p: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2072:46\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2075:39\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:51\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2075:91\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2076:49\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                 ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2076:61\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2076:72\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                        ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2076:110\n     |\n2076 | ...lt(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:42\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2077 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:58\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2077 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2075:105\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2076:76\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                            ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2076:124\n     |\n2076 | ...p: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2070:32\n     |\n2070 |     let kind = HirKind::Anchor('a');\n     |                --------------- ^^^ expected `Anchor`, found `char`\n     |                |\n     |                arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:181:5\n     |\n181  |     Anchor(Anchor),\n     |     ^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2072:46\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2072 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2075:39\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:51\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2075:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2075:91\n     |\n2075 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2076:49\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                 ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2076:61\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2076:72\n     |\n2076 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                        ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2076:110\n     |\n2076 | ...lt(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:42\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2077 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2077:58\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2077 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:47\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2078 |     let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);\n     |                                               ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2078:63\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2078 |     let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);\n     |                                                               ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                "    let kind = HirKind::Literal(literal);",
                "    let _ = kind.is_empty();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    assert_eq!(empty.has_subexprs(), false);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    assert_eq!(kind.has_subexprs(), true);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };",
                  "    let kind = HirKind::Group(group);",
                  "    assert_eq!(kind.has_subexprs(), true);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };",
                  "    let kind = HirKind::Group(group);",
                  "    let concat = HirKind::Concat(vec![kind.clone(), kind.clone()]);",
                  "    assert_eq!(concat.has_subexprs(), true);"
                ],
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };",
                  "    let kind = HirKind::Group(group);",
                  "    let concat = HirKind::Concat(vec![kind.clone(), kind.clone()]);",
                  "    let alternation = HirKind::Alternation(vec![kind.clone(), kind.clone()]);",
                  "    assert_eq!(alternation.has_subexprs(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::Unicode('a');  ",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal::Unicode('a');",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = LiteralKind::Unicode('a');  ",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    assert_eq!(empty.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    assert_eq!(kind.has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };",
                  "    let kind = HirKind::Group(group);",
                  "    assert_eq!(kind.has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };",
                  "    let kind = HirKind::Group(group);",
                  "    let concat = HirKind::Concat(vec![kind.clone(), kind.clone()]);",
                  "    assert_eq!(concat.has_subexprs(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let _ = kind.is_empty();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let kind = HirKind::Literal(literal);",
                  "    let class = Class::Unicode(ClassUnicode::default());",
                  "    let kind = HirKind::Class(class);",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let empty = HirKind::Empty;",
                  "    let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };",
                  "    let kind = HirKind::Repetition(repetition);",
                  "    let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };",
                  "    let kind = HirKind::Group(group);",
                  "    let concat = HirKind::Concat(vec![kind.clone(), kind.clone()]);",
                  "    let alternation = HirKind::Alternation(vec![kind.clone(), kind.clone()]);",
                  "    assert_eq!(alternation.has_subexprs(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = LiteralKind::Unicode('a');  \n     |                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2080:62\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2080:35\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                   ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2080:47\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                               ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2080:58\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                          ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2080:96\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2080:62\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2080:35\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                   ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2080:47\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                               ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2080:58\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                          ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2080:96\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2082:25\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:37\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:65\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                                                 ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(literal) };\n     |                                                                 ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2082:79\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                                                               ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2080:62\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2080:35\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                   ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2080:47\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                               ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2080:58\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                          ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2080:96\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2082:25\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:37\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:65\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                                                 ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(literal) };\n     |                                                                 ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2082:79\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                                                               ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2084:39\n     |\n2084 |     let concat = HirKind::Concat(vec![kind.clone(), kind.clone()]);\n     |                                       ^^^^^^^^^^^^ expected `Hir`, found `HirKind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2080:62\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(literal) };\n     |                                                              ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2060 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:46\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2073 |     let class = Class::Unicode(ClassUnicode::default());\n     |                                              ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2080:35\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                   ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2080:47\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                               ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2080:58\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                          ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2080:96\n     |\n2080 |     let repetition = Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(literal) };\n     |                                                                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2082:25\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                         ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:37\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2082:65\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n...\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                                                 ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\nhelp: there is a variant with a similar name\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::NonCapturing, ast: Box::new(literal) };\n     |                                                                 ~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2082:79\n     |\n2082 |     let group = Group { span: Span::default(), kind: GroupKind::Capturing(0), ast: Box::new(literal) };\n     |                                                                               ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2084:39\n     |\n2084 |     let concat = HirKind::Concat(vec![kind.clone(), kind.clone()]);\n     |                                       ^^^^^^^^^^^^ expected `Hir`, found `HirKind`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/mod.rs:2085:49\n     |\n2085 |     let alternation = HirKind::Alternation(vec![kind.clone(), kind.clone()]);\n     |                                                 ^^^^^^^^^^^^ expected `Hir`, found `HirKind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560, E0574, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));",
                "    let kind = HirKind::Class(class);",
                "    let _ = kind.is_empty();",
                "}"
              ],
              "oracles": [
                [
                  "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));",
                  "    let kind = HirKind::Class(class);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));",
                  "    let kind = HirKind::Class(class);",
                  "    let _ = kind.is_empty();",
                  "    let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));",
                  "    let kind = HirKind::Class(class);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0271]: type mismatch resolving `<Vec<char> as IntoIterator>::Item == ClassUnicodeRange`\n    --> regex-syntax/src/hir/mod.rs:2068:50\n     |\n2068 |     let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));\n     |                                ----------------- ^^^^^^^^^^^^^^^^^^^ expected `ClassUnicodeRange`, found `char`\n     |                                |\n     |                                required by a bound introduced by this call\n     |\nnote: required by a bound in `hir::ClassUnicode::new`\n    --> regex-syntax/src/hir/mod.rs:730:27\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            --- required by a bound in this associated function\n730  |     where I: IntoIterator<Item=ClassUnicodeRange>\n     |                           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `ClassUnicode::new`\n\nerror[E0271]: type mismatch resolving `<Vec<char> as IntoIterator>::Item == ClassUnicodeRange`\n    --> regex-syntax/src/hir/mod.rs:2071:50\n     |\n2071 |     let class = Class::Unicode(ClassUnicode::new(vec!['a', 'b', 'c']));\n     |                                ----------------- ^^^^^^^^^^^^^^^^^^^ expected `ClassUnicodeRange`, found `char`\n     |                                |\n     |                                required by a bound introduced by this call\n     |\nnote: required by a bound in `hir::ClassUnicode::new`\n    --> regex-syntax/src/hir/mod.rs:730:27\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            --- required by a bound in this associated function\n730  |     where I: IntoIterator<Item=ClassUnicodeRange>\n     |                           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `ClassUnicode::new`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0271`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let anchor = Anchor::StartLine;",
                "    let kind = HirKind::Anchor(anchor);",
                "    let _ = kind.is_empty();",
                "}"
              ],
              "oracles": [
                [
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    let _ = kind.is_empty();",
                  "    let anchor = Anchor::StartLine;",
                  "    let kind = HirKind::Anchor(anchor);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let word_boundary = WordBoundary::Unicode;",
                "    let kind = HirKind::WordBoundary(word_boundary);",
                "    let _ = kind.is_empty();",
                "}"
              ],
              "oracles": [
                [
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ],
                [
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(kind.is_empty(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let _ = kind.is_empty();",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    let _ = kind.is_empty();",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(kind.is_empty(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Class(_) is true\n",
        "// constraint: *self matches HirKind::WordBoundary(_) or HirKind::Class(_) or HirKind::Anchor(_) or HirKind::Empty or HirKind::Literal(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "Class::Unicode, Class::Bytes, WordBoundary::Unicode, WordBoundary::Ascii, Anchor::StartLine, Anchor::EndText, HirKind::Empty, HirKind::Literal('a')\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir_kind = HirKind::Empty;",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ],
                [
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ],
                [
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ],
                [
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ],
                [
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Empty;",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir_kind = HirKind::Empty;",
                  "    hir_kind.has_subexprs();",
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_kind = HirKind::Empty;",
                  "    hir_kind.has_subexprs();",
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_kind = HirKind::Empty;",
                  "    hir_kind.has_subexprs();",
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_kind = HirKind::Empty;",
                  "    hir_kind.has_subexprs();",
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_kind = HirKind::Empty;",
                  "    hir_kind.has_subexprs();",
                  "    let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let hir_kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let hir_kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let hir_kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let hir_kind = HirKind::Empty;",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2070:50\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                  ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                                   ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2070:50\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                  ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                                   ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2070:50\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                  ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                                   ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2070:50\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                  ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                                   ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2070:50\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                                  ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2070 |     let hir_kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                                   ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                "    let hir_kind = HirKind::Literal(literal);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    hir_kind.has_subexprs();",
                  "    let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };",
                  "    let hir_kind = HirKind::Literal(literal);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2068:19\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2068:58\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2071:19\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                   ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2060 +    use ast::Ast::Literal;\n     |\n2060 +    use ast::ClassSetItem::Literal;\n     |\n2060 +    use ast::Literal;\n     |\n2060 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2071:58\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2060 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:41\n     |\n2068 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:41\n     |\n2071 |     let literal = Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' };\n     |                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let unicode_class = Class::Unicode(ClassUnicode::default());",
                "    let hir_kind = HirKind::Class(unicode_class);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let unicode_class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(unicode_class);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let unicode_class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(unicode_class);",
                  "    hir_kind.has_subexprs();",
                  "    let unicode_class = Class::Unicode(ClassUnicode::default());",
                  "    let hir_kind = HirKind::Class(unicode_class);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:54\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2068 |     let unicode_class = Class::Unicode(ClassUnicode::default());\n     |                                                      ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:54\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2071 |     let unicode_class = Class::Unicode(ClassUnicode::default());\n     |                                                      ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let bytes_class = Class::Bytes(ClassBytes::default());",
                "    let hir_kind = HirKind::Class(bytes_class);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let bytes_class = Class::Bytes(ClassBytes::default());",
                  "    let hir_kind = HirKind::Class(bytes_class);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let bytes_class = Class::Bytes(ClassBytes::default());",
                  "    let hir_kind = HirKind::Class(bytes_class);",
                  "    hir_kind.has_subexprs();",
                  "    let bytes_class = Class::Bytes(ClassBytes::default());",
                  "    let hir_kind = HirKind::Class(bytes_class);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2068:48\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2068 |     let bytes_class = Class::Bytes(ClassBytes::default());\n     |                                                ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:48\n     |\n913  | pub struct ClassBytes {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2071 |     let bytes_class = Class::Bytes(ClassBytes::default());\n     |                                                ^^^^^^^ function or associated item not found in `ClassBytes`\n     |\nnote: if you're trying to build a new `hir::ClassBytes` consider using one of the following associated functions:\n      hir::ClassBytes::new\n      hir::ClassBytes::empty\n    --> regex-syntax/src/hir/mod.rs:922:5\n     |\n922  | /     pub fn new<I>(ranges: I) -> ClassBytes\n923  | |     where I: IntoIterator<Item=ClassBytesRange>\n     | |_______________________________________________^\n...\n929  |       pub fn empty() -> ClassBytes {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let word_boundary = WordBoundary::Unicode;",
                "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    hir_kind.has_subexprs();",
                  "    let word_boundary = WordBoundary::Unicode;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let word_boundary = WordBoundary::Ascii;",
                "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    hir_kind.has_subexprs();",
                  "    let word_boundary = WordBoundary::Ascii;",
                  "    let hir_kind = HirKind::WordBoundary(word_boundary);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let anchor = Anchor::StartLine;",
                "    let hir_kind = HirKind::Anchor(anchor);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let anchor = Anchor::StartLine;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let anchor = Anchor::StartLine;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    hir_kind.has_subexprs();",
                  "    let anchor = Anchor::StartLine;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    assert_eq!(hir_kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let anchor = Anchor::EndText;",
                "    let hir_kind = HirKind::Anchor(anchor);",
                "    hir_kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let anchor = Anchor::EndText;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    assert!(!hir_kind.has_subexprs());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let anchor = Anchor::EndText;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    hir_kind.has_subexprs();",
                  "    let anchor = Anchor::EndText;",
                  "    let hir_kind = HirKind::Anchor(anchor);",
                  "    assert!(!hir_kind.has_subexprs());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Literal(_) is true\n",
        "// constraint: *self matches HirKind::WordBoundary(_) or HirKind::Class(_) or HirKind::Anchor(_) or HirKind::Empty or HirKind::Literal(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "HirKind::Empty, HirKind::Literal(_), HirKind::Class(_), HirKind::WordBoundary(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Empty;",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Empty;",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Literal(Literal { ",
                "        span: Span::default(), ",
                "        kind: LiteralKind::Unicode('a'), ",
                "        c: 'a' ",
                "    });",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Literal(Literal { ",
                  "        span: Span::default(), ",
                  "        kind: LiteralKind::Unicode('a'), ",
                  "        c: 'a' ",
                  "    });",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2063:33\n     |\n2063 |     let kind = HirKind::Literal(Literal { \n     |                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2058 +    use ast::Ast::Literal;\n     |\n2058 +    use ast::ClassSetItem::Literal;\n     |\n2058 +    use ast::Literal;\n     |\n2058 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2065:15\n     |\n2065 |         kind: LiteralKind::Unicode('a'), \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2069:33\n     |\n2069 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2058 +    use ast::Ast::Literal;\n     |\n2058 +    use ast::ClassSetItem::Literal;\n     |\n2058 +    use ast::Literal;\n     |\n2058 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2069:72\n     |\n2069 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2064:21\n     |\n2064 |         span: Span::default(), \n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2069:55\n     |\n2069 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::default()));",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::default()));",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::default()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::default()));",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2063:60\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::default()));\n     |                                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2065:60\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- function or associated item `default` not found for this struct\n...\n2065 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::default()));\n     |                                                            ^^^^^^^ function or associated item not found in `ClassUnicode`\n     |\nnote: if you're trying to build a new `hir::ClassUnicode` consider using one of the following associated functions:\n      hir::ClassUnicode::new\n      hir::ClassUnicode::empty\n    --> regex-syntax/src/hir/mod.rs:729:5\n     |\n729  | /     pub fn new<I>(ranges: I) -> ClassUnicode\n730  | |     where I: IntoIterator<Item=ClassUnicodeRange>\n     | |_________________________________________________^\n...\n736  |       pub fn empty() -> ClassUnicode {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartText);",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Anchor(Anchor::StartText);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Anchor(Anchor::StartText);",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Anchor(Anchor::StartText);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *self matches HirKind::Empty is true\n",
        "// constraint: *self matches HirKind::WordBoundary(_) or HirKind::Class(_) or HirKind::Anchor(_) or HirKind::Empty or HirKind::Literal(_) is true\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "HirKind::Empty, HirKind::Literal('a'), HirKind::Class(Class::Unicode(ClassUnicode::new())), HirKind::Anchor(Anchor::StartLine), HirKind::WordBoundary(WordBoundary::Ascii)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Empty;",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Empty;",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Empty;",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2063:33\n     |\n2063 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2058 +    use ast::Ast::Literal;\n     |\n2058 +    use ast::ClassSetItem::Literal;\n     |\n2058 +    use ast::Literal;\n     |\n2058 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2063:72\n     |\n2063 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::LiteralKind;\n     |\n\nerror[E0574]: expected struct, variant or union type, found enum `Literal`\n    --> regex-syntax/src/hir/mod.rs:2065:33\n     |\n2065 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                 ^^^^^^^ not a struct, variant or union type\n     |\nhelp: consider importing one of these items instead\n     |\n2058 +    use ast::Ast::Literal;\n     |\n2058 +    use ast::ClassSetItem::Literal;\n     |\n2058 +    use ast::Literal;\n     |\n2058 +    use hir::HirKind::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/mod.rs:2065:72\n     |\n2065 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2063:55\n     |\n2063 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2065:55\n     |\n2065 |     let kind = HirKind::Literal(Literal { span: Span::default(), kind: LiteralKind::Unicode('a'), c: 'a' });\n     |                                                       ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0574, E0599.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Empty;",
                  "    assert!(kind.has_subexprs() == false);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    assert!(kind.has_subexprs() == false);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    assert!(kind.has_subexprs() == false);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert!(kind.has_subexprs() == false);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert!(kind.has_subexprs() == false);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs() == true);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs() == true);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs() == true);"
                ],
                [
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs() == true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    assert!(kind.has_subexprs() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    assert!(kind.has_subexprs() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    assert!(kind.has_subexprs() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert!(kind.has_subexprs() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    assert!(kind.has_subexprs() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    assert!(kind.has_subexprs() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Empty;",
                  "    let kind = HirKind::Literal(Literal::Unicode('a'));",
                  "    let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Unicode);",
                  "    let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });",
                  "    let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);",
                  "    let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);",
                  "    assert!(kind.has_subexprs() == true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2067:46\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2067:46\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2067:46\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2070:105\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2067:46\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2070:39\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:51\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2070:91\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2070:105\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2071:76\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                            ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2058 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2071:124\n     |\n2071 | ...p: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2067:46\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2070:39\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:51\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2070:91\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2071:49\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                 ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:61\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2071:72\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                        ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2071:110\n     |\n2071 | ...lt(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2070:105\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2071:76\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                            ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2058 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2071:124\n     |\n2071 | ...p: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2067:46\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2070:39\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:51\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2070:91\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2071:49\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                 ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:61\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2071:72\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                        ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2071:110\n     |\n2071 | ...lt(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:42\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:58\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2070:105\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                                         ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::Ast;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/mod.rs:2071:76\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: a struct with a similar name exists\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: Repetition::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                                            ~~~~~~~~~~\nhelp: consider importing this struct\n     |\n2058 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ast`\n    --> regex-syntax/src/hir/mod.rs:2071:124\n     |\n2071 | ...p: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                       ^^^ use of undeclared type `Ast`\n     |\nhelp: consider importing this enum\n     |\n2058 +    use ast::Ast;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2063:46\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2063 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/mod.rs:2067:46\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new()));\n     |                                              ^^^^^^^^^^^^^^^^^-- argument #1 is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:729:12\n     |\n729  |     pub fn new<I>(ranges: I) -> ClassUnicode\n     |            ^^^    ---------\nhelp: provide the argument\n     |\n2067 |     let kind = HirKind::Class(Class::Unicode(ClassUnicode::new(/* ranges */)));\n     |                                                               ~~~~~~~~~~~~~~\n\nerror[E0560]: struct `hir::Group` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2070:39\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                       ^^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:51\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                   ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `Capture` found for enum `hir::GroupKind` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2070:79\n     |\n1166 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capture` not found for this enum\n...\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                               ^^^^^^^ variant or associated item not found in `GroupKind`\n\nerror[E0560]: struct `hir::Group` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2070:91\n     |\n2070 |     let kind = HirKind::Group(Group { span: Span::default(), kind: GroupKind::Capture(0), ast: Box::new(Ast::default()) });\n     |                                                                                           ^^^ `hir::Group` does not have this field\n     |\n     = note: available fields are: `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `span`\n    --> regex-syntax/src/hir/mod.rs:2071:49\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                 ^^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2071:61\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                             ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0560]: struct `hir::Repetition` has no field named `op`\n    --> regex-syntax/src/hir/mod.rs:2071:72\n     |\n2071 |     let kind = HirKind::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()...\n     |                                                                        ^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0560]: struct `hir::Repetition` has no field named `ast`\n    --> regex-syntax/src/hir/mod.rs:2071:110\n     |\n2071 | ...lt(), op: RepetitionOp::Star, greedy: true, ast: Box::new(Ast::default()) });\n     |                                                ^^^ `hir::Repetition` does not have this field\n     |\n     = note: available fields are: `kind`, `hir`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:42\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2072:58\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2072 |     let kind = HirKind::Concat(vec![Hir::default(), Hir::default()]);\n     |                                                          ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:47\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2073 |     let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);\n     |                                               ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `hir::Hir` in the current scope\n    --> regex-syntax/src/hir/mod.rs:2073:63\n     |\n161  | pub struct Hir {\n     | -------------- function or associated item `default` not found for this struct\n...\n2073 |     let kind = HirKind::Alternation(vec![Hir::default(), Hir::default()]);\n     |                                                               ^^^^^^^ function or associated item not found in `hir::Hir`\n     |\nnote: if you're trying to build a new `hir::Hir` consider using one of the following associated functions:\n      hir::Hir::empty\n      hir::Hir::literal\n      hir::Hir::class\n      hir::Hir::anchor\n      and 7 others\n    --> regex-syntax/src/hir/mod.rs:219:5\n     |\n219  |     pub fn empty() -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^\n...\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n259  |     pub fn class(class: Class) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n275  |     pub fn anchor(anchor: Anchor) -> Hir {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0560, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::Anchor(Anchor::StartLine);",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::Anchor(Anchor::StartLine);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let kind = HirKind::WordBoundary(WordBoundary::Ascii);",
                "    kind.has_subexprs();",
                "}"
              ],
              "oracles": [
                [
                  "    let kind = HirKind::WordBoundary(WordBoundary::Ascii);",
                  "    assert_eq!(kind.has_subexprs(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Ascii);",
                  "    kind.has_subexprs();",
                  "    let kind = HirKind::WordBoundary(WordBoundary::Ascii);",
                  "    assert_eq!(kind.has_subexprs(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/mod.rs:2059:8\n     |\n2059 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}