{
  "name": "regex_syntax::hir::interval::hir::interval::IntervalSet<I>::intervals",
  "name_with_impl": "regex_syntax::hir::interval::{impl#0}::intervals",
  "mod_info": {
    "name": "hir::interval",
    "loc": "regex-syntax/src/hir/mod.rs:26:1:26:14"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/interval.rs:67:5:69:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: &self.ranges\n"
      ],
      "input_infer": "0 to 1000 elements, where each element is an instance of type I that satisfies Interval trait with properly defined bounds within the range of 0 to 255, inclusive.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                "    let _ = interval_set.intervals();",
                "}"
              ],
              "oracles": [
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert_eq!(interval_set.intervals(), &[]);"
                ],
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    let interval_set_with_intervals: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 5), TestInterval::new(6, 10)]);",
                  "    assert_eq!(interval_set_with_intervals.intervals(), &[TestInterval::new(1, 5), TestInterval::new(6, 10)]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert_eq!(interval_set.intervals(), &[]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    let interval_set_with_intervals: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 5), TestInterval::new(6, 10)]);",
                  "    assert_eq!(interval_set_with_intervals.intervals(), &[TestInterval::new(1, 5), TestInterval::new(6, 10)]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                "    let _ = interval_set.intervals();",
                "}"
              ],
              "oracles": [
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let intervals = interval_set.intervals();",
                  "    assert_eq!(intervals.len(), 1);"
                ],
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let intervals = interval_set.intervals();",
                  "    assert_eq!(intervals[0].lower(), 1);"
                ],
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let intervals = interval_set.intervals();",
                  "    assert_eq!(intervals[0].upper(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let intervals = interval_set.intervals();",
                  "    assert_eq!(intervals.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let intervals = interval_set.intervals();",
                  "    assert_eq!(intervals[0].lower(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(1, 2)]);",
                  "    let intervals = interval_set.intervals();",
                  "    assert_eq!(intervals[0].upper(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                "        TestInterval::new(0, 2),",
                "        TestInterval::new(3, 5),",
                "        TestInterval::new(6, 10),",
                "    ]);",
                "    let _ = interval_set.intervals();",
                "}"
              ],
              "oracles": [
                [
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result.len(), 3);"
                ],
                [
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result[0], TestInterval::new(0, 2));"
                ],
                [
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result[1], TestInterval::new(3, 5));"
                ],
                [
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result[2], TestInterval::new(6, 10));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 2),",
                  "        TestInterval::new(3, 5),",
                  "        TestInterval::new(6, 10),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 2),",
                  "        TestInterval::new(3, 5),",
                  "        TestInterval::new(6, 10),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result[0], TestInterval::new(0, 2));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 2),",
                  "        TestInterval::new(3, 5),",
                  "        TestInterval::new(6, 10),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result[1], TestInterval::new(3, 5));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 2),",
                  "        TestInterval::new(3, 5),",
                  "        TestInterval::new(6, 10),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(0, 2), TestInterval::new(3, 5), TestInterval::new(6, 10)]);",
                  "    let result = interval_set.intervals();",
                  "    assert_eq!(result[2], TestInterval::new(6, 10));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                "        TestInterval::new(0, 255),",
                "    ]);",
                "    let _ = interval_set.intervals();",
                "}"
              ],
              "oracles": [
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert_eq!(ranges.len(), 1);"
                ],
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert_eq!(ranges[0].lower(), 0);"
                ],
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert_eq!(ranges[0].upper(), 255);"
                ],
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert!(ranges[0].is_contiguous(&TestInterval::new(0, 255)));"
                ],
                [
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert!(!ranges[0].is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 255),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert_eq!(ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 255),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert_eq!(ranges[0].lower(), 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}  ",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 255),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert_eq!(ranges[0].upper(), 255);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 255),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert!(ranges[0].is_contiguous(&TestInterval::new(0, 255)));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(0, 255),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![TestInterval::new(0, 255)]);",
                  "    let ranges = interval_set.intervals();",
                  "    assert!(!ranges[0].is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty` found for struct `TestInterval` in the current scope\n   --> regex-syntax/src/hir/interval.rs:531:24\n    |\n502 | struct TestInterval {\n    | ------------------- method `is_empty` not found for this struct\n...\n531 |     assert!(!ranges[0].is_empty());\n    |                        ^^^^^^^^ method not found in `TestInterval`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `is_empty`, perhaps you need to implement it:\n            candidate #1: `ExactSizeIterator`\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:520:32\n    |\n520 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                "        TestInterval::new(10, 20),",
                "        TestInterval::new(20, 30),",
                "    ]);",
                "    let _ = interval_set.intervals();",
                "}"
              ],
              "oracles": [
                [
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
                  "    assert_eq!(interval_set.intervals().len(), 2);"
                ],
                [
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
                  "    assert_eq!(interval_set.intervals()[0], TestInterval::new(10, 20));"
                ],
                [
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
                  "    assert_eq!(interval_set.intervals()[1], TestInterval::new(20, 30));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(10, 20),",
                  "        TestInterval::new(20, 30),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
                  "    assert_eq!(interval_set.intervals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(10, 20),",
                  "        TestInterval::new(20, 30),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
                  "    assert_eq!(interval_set.intervals()[0], TestInterval::new(10, 20));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval::new(10, 20),",
                  "        TestInterval::new(20, 30),",
                  "    ]);",
                  "    let _ = interval_set.intervals();",
                  "    let interval_set = IntervalSet::new(vec![TestInterval::new(10, 20), TestInterval::new(20, 30)]);",
                  "    assert_eq!(interval_set.intervals()[1], TestInterval::new(20, 30));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
                "    let _ = interval_set.intervals();",
                "}"
              ],
              "oracles": [
                [
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert_eq!(interval_set.intervals().len(), intervals.len());"
                ],
                [
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert!(interval_set.intervals().iter().all(|interval| interval.lower() < interval.upper()));"
                ],
                [
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert_eq!(interval_set.intervals(), &intervals);"
                ],
                [
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.lower().cmp(&b.lower())));"
                ],
                [
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.upper().cmp(&b.upper())));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let intervals = (0..256).map(|i| TestInterval::new(i, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
                  "    let _ = interval_set.intervals();",
                  "    let intervals = (0..1000).map(|i| TestInterval::new((i % 256) as u8, ((i + 1) % 256) as u8)).collect::<Vec<_>>();",
                  "    assert_eq!(interval_set.intervals().len(), intervals.len());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
                  "    let _ = interval_set.intervals();",
                  "    let intervals = (0..1000).map(|i| TestInterval::new((i % 256) as u8, ((i + 1) % 256) as u8)).collect::<Vec<_>>();  ",
                  "    assert!(interval_set.intervals().iter().all(|interval| interval.lower() < interval.upper()));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
                  "    let _ = interval_set.intervals();",
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert_eq!(interval_set.intervals(), &intervals);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
                  "    let _ = interval_set.intervals();",
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.lower().cmp(&b.lower())));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "struct TestInterval {",
                  "    lower: u8,",
                  "    upper: u8,",
                  "}",
                  "",
                  "impl TestInterval {",
                  "    fn new(lower: u8, upper: u8) -> Self {",
                  "        Self { lower, upper }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u8;",
                  "",
                  "    fn lower(&self) -> Self::Bound { self.lower }",
                  "    fn upper(&self) -> Self::Bound { self.upper }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}  ",
                  "    fn is_contiguous(&self, other: &Self) -> bool { self.upper >= other.lower && self.lower <= other.upper }",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "    fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "}",
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(intervals);",
                  "    let _ = interval_set.intervals();",
                  "    let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();",
                  "    assert!(interval_set.intervals().is_sorted_by(|a, b| a.upper().cmp(&b.upper())));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:520:32\n    |\n520 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror: this operation will panic at runtime\n   --> regex-syntax/src/hir/interval.rs:525:59\n    |\n525 |     let intervals = (0..256).map(|i| TestInterval::new(i, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                           ^^^^^^^^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n    |\n    = note: `#[deny(unconditional_panic)]` on by default\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: range endpoint is out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:21\n    |\n525 |     let intervals = (0..256).map(|i| TestInterval::new(i, (i + 1) % 256)).collect::<Vec<_>>();\n    |                     -------^\n    |                     |\n    |                     help: use an inclusive range instead: `0..=255`\n    |\n    = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:69\n    |\n525 |     let intervals = (0..256).map(|i| TestInterval::new(i, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                                     ^^^\n    |\n    = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 94 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 94 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:528:9\n    |\n528 |     let intervals = (0..1000).map(|i| TestInterval::new((i % 256) as u8, ((i + 1) % 256) as u8)).collect::<Vec<_>>();  \n    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:520:32\n    |\n520 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror: this operation will panic at runtime\n   --> regex-syntax/src/hir/interval.rs:525:57\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                         ^^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n    |\n    = note: `#[deny(unconditional_panic)]` on by default\n\nerror: this operation will panic at runtime\n   --> regex-syntax/src/hir/interval.rs:525:66\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                                  ^^^^^^^^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:25\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                         ^^^^\n    |\n    = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`\n    = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:61\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                             ^^^\n    |\n    = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:76\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                                            ^^^\n    |\n    = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 95 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 95 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:520:32\n    |\n520 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror: this operation will panic at runtime\n   --> regex-syntax/src/hir/interval.rs:525:57\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                         ^^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n    |\n    = note: `#[deny(unconditional_panic)]` on by default\n\nerror: this operation will panic at runtime\n   --> regex-syntax/src/hir/interval.rs:525:66\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                                  ^^^^^^^^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n\nerror: this operation will panic at runtime\n   --> regex-syntax/src/hir/interval.rs:528:57\n    |\n528 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                         ^^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n\nerror: this operation will panic at runtime\n   --> regex-syntax/src/hir/interval.rs:528:66\n    |\n528 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                                  ^^^^^^^^^^^^^ attempt to calculate the remainder of `_` with a divisor of zero\n\nwarning: function `s` is never used\n    --> regex-syntax/src/ast/parse.rs:2300:8\n     |\n2300 |     fn s(str: &str) -> String {\n     |        ^\n     |\n     = note: `#[warn(dead_code)]` on by default\n\nwarning: function `parser` is never used\n    --> regex-syntax/src/ast/parse.rs:2304:8\n     |\n2304 |     fn parser(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^\n\nwarning: function `parser_octal` is never used\n    --> regex-syntax/src/ast/parse.rs:2308:8\n     |\n2308 |     fn parser_octal(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^\n\nwarning: function `parser_nest_limit` is never used\n    --> regex-syntax/src/ast/parse.rs:2313:8\n     |\n2313 |     fn parser_nest_limit(pattern: &str, nest_limit: u32) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^\n\nwarning: function `parser_ignore_whitespace` is never used\n    --> regex-syntax/src/ast/parse.rs:2318:8\n     |\n2318 |     fn parser_ignore_whitespace(pattern: &str) -> ParserI<Parser> {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `nspan` is never used\n    --> regex-syntax/src/ast/parse.rs:2324:8\n     |\n2324 |     fn nspan(start: Position, end: Position) -> Span {\n     |        ^^^^^\n\nwarning: function `npos` is never used\n    --> regex-syntax/src/ast/parse.rs:2329:8\n     |\n2329 |     fn npos(offset: usize, line: usize, column: usize) -> Position {\n     |        ^^^^\n\nwarning: function `span` is never used\n    --> regex-syntax/src/ast/parse.rs:2336:8\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |        ^^^^\n\nwarning: function `span_range` is never used\n    --> regex-syntax/src/ast/parse.rs:2343:8\n     |\n2343 |     fn span_range(subject: &str, range: Range<usize>) -> Span {\n     |        ^^^^^^^^^^\n\nwarning: function `lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2366:8\n     |\n2366 |     fn lit(c: char, start: usize) -> Ast {\n     |        ^^^\n\nwarning: function `punct_lit` is never used\n    --> regex-syntax/src/ast/parse.rs:2371:8\n     |\n2371 |     fn punct_lit(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^^\n\nwarning: function `lit_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2380:8\n     |\n2380 |     fn lit_with(c: char, span: Span) -> Ast {\n     |        ^^^^^^^^\n\nwarning: function `concat` is never used\n    --> regex-syntax/src/ast/parse.rs:2389:8\n     |\n2389 |     fn concat(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^\n\nwarning: function `concat_with` is never used\n    --> regex-syntax/src/ast/parse.rs:2394:8\n     |\n2394 |     fn concat_with(span: Span, asts: Vec<Ast>) -> Ast {\n     |        ^^^^^^^^^^^\n\nwarning: function `alt` is never used\n    --> regex-syntax/src/ast/parse.rs:2399:8\n     |\n2399 |     fn alt(range: Range<usize>, asts: Vec<Ast>) -> Ast {\n     |        ^^^\n\nwarning: function `group` is never used\n    --> regex-syntax/src/ast/parse.rs:2404:8\n     |\n2404 |     fn group(range: Range<usize>, index: u32, ast: Ast) -> Ast {\n     |        ^^^^^\n\nwarning: function `flag_set` is never used\n    --> regex-syntax/src/ast/parse.rs:2419:8\n     |\n2419 |     fn flag_set(\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/ast/print.rs:420:8\n    |\n420 |     fn roundtrip(given: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/ast/print.rs:424:8\n    |\n424 |     fn roundtrip_with<F>(mut f: F, given: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: struct `Bytes` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1010:12\n     |\n1010 |     struct Bytes(Vec<ULiteral>);\n     |            ^^^^^\n\nwarning: struct `Unicode` is never constructed\n    --> regex-syntax/src/hir/literal/mod.rs:1012:12\n     |\n1012 |     struct Unicode(Vec<ULiteral>);\n     |            ^^^^^^^\n\nwarning: function `escape_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1014:8\n     |\n1014 |     fn escape_lits(blits: &[Literal]) -> Vec<ULiteral> {\n     |        ^^^^^^^^^^^\n\nwarning: function `create_lits` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1025:8\n     |\n1025 |     fn create_lits<I: IntoIterator<Item=Literal>>(it: I) -> Literals {\n     |        ^^^^^^^^^^^\n\nwarning: function `C` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1067:8\n     |\n1067 |     fn C(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `M` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1071:8\n     |\n1071 |     fn M(s: &'static str) -> ULiteral {\n     |        ^\n\nwarning: function `prefixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1075:8\n     |\n1075 |     fn prefixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: function `suffixes` is never used\n    --> regex-syntax/src/hir/literal/mod.rs:1079:8\n     |\n1079 |     fn suffixes(lits: &mut Literals, expr: &Hir) {\n     |        ^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: function `roundtrip` is never used\n   --> regex-syntax/src/hir/print.rs:252:8\n    |\n252 |     fn roundtrip(given: &str, expected: &str) {\n    |        ^^^^^^^^^\n\nwarning: function `roundtrip_bytes` is never used\n   --> regex-syntax/src/hir/print.rs:256:8\n    |\n256 |     fn roundtrip_bytes(given: &str, expected: &str) {\n    |        ^^^^^^^^^^^^^^^\n\nwarning: function `roundtrip_with` is never used\n   --> regex-syntax/src/hir/print.rs:260:8\n    |\n260 |     fn roundtrip_with<F>(mut f: F, given: &str, expected: &str)\n    |        ^^^^^^^^^^^^^^\n\nwarning: function `parse` is never used\n    --> regex-syntax/src/hir/translate.rs:1122:8\n     |\n1122 |     fn parse(pattern: &str) -> Ast {\n     |        ^^^^^\n\nwarning: function `t` is never used\n    --> regex-syntax/src/hir/translate.rs:1126:8\n     |\n1126 |     fn t(pattern: &str) -> Hir {\n     |        ^\n\nwarning: function `t_err` is never used\n    --> regex-syntax/src/hir/translate.rs:1134:8\n     |\n1134 |     fn t_err(pattern: &str) -> hir::Error {\n     |        ^^^^^\n\nwarning: function `t_bytes` is never used\n    --> regex-syntax/src/hir/translate.rs:1142:8\n     |\n1142 |     fn t_bytes(pattern: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_lit` is never used\n    --> regex-syntax/src/hir/translate.rs:1150:8\n     |\n1150 |     fn hir_lit(s: &str) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_blit` is never used\n    --> regex-syntax/src/hir/translate.rs:1164:8\n     |\n1164 |     fn hir_blit(s: &[u8]) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_group` is never used\n    --> regex-syntax/src/hir/translate.rs:1180:8\n     |\n1180 |     fn hir_group(i: u32, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_group_name` is never used\n    --> regex-syntax/src/hir/translate.rs:1187:8\n     |\n1187 |     fn hir_group_name(i: u32, name: &str, expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_group_nocap` is never used\n    --> regex-syntax/src/hir/translate.rs:1197:8\n     |\n1197 |     fn hir_group_nocap(expr: Hir)  -> Hir {\n     |        ^^^^^^^^^^^^^^^\n\nwarning: function `hir_quest` is never used\n    --> regex-syntax/src/hir/translate.rs:1204:8\n     |\n1204 |     fn hir_quest(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_star` is never used\n    --> regex-syntax/src/hir/translate.rs:1212:8\n     |\n1212 |     fn hir_star(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_plus` is never used\n    --> regex-syntax/src/hir/translate.rs:1220:8\n     |\n1220 |     fn hir_plus(greedy: bool, expr: Hir) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `hir_range` is never used\n    --> regex-syntax/src/hir/translate.rs:1228:8\n     |\n1228 |     fn hir_range(greedy: bool, range: hir::RepetitionRange, expr: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_alt` is never used\n    --> regex-syntax/src/hir/translate.rs:1236:8\n     |\n1236 |     fn hir_alt(alts: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_cat` is never used\n    --> regex-syntax/src/hir/translate.rs:1240:8\n     |\n1240 |     fn hir_cat(exprs: Vec<Hir>) -> Hir {\n     |        ^^^^^^^\n\nwarning: function `hir_uclass_query` is never used\n    --> regex-syntax/src/hir/translate.rs:1244:8\n     |\n1244 |     fn hir_uclass_query(query: ClassQuery) -> Hir {\n     |        ^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass_perl_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1248:8\n     |\n1248 |     fn hir_uclass_perl_word() -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_uclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1253:8\n     |\n1253 |     fn hir_uclass(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass` is never used\n    --> regex-syntax/src/hir/translate.rs:1261:8\n     |\n1261 |     fn hir_bclass(ranges: &[(u8, u8)]) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_bclass_from_char` is never used\n    --> regex-syntax/src/hir/translate.rs:1269:8\n     |\n1269 |     fn hir_bclass_from_char(ranges: &[(char, char)]) -> Hir {\n     |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: function `hir_case_fold` is never used\n    --> regex-syntax/src/hir/translate.rs:1281:8\n     |\n1281 |     fn hir_case_fold(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^\n\nwarning: function `hir_negate` is never used\n    --> regex-syntax/src/hir/translate.rs:1291:8\n     |\n1291 |     fn hir_negate(expr: Hir) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_union` is never used\n    --> regex-syntax/src/hir/translate.rs:1301:8\n     |\n1301 |     fn hir_union(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^\n\nwarning: function `hir_difference` is never used\n    --> regex-syntax/src/hir/translate.rs:1323:8\n     |\n1323 |     fn hir_difference(expr1: Hir, expr2: Hir) -> Hir {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `hir_anchor` is never used\n    --> regex-syntax/src/hir/translate.rs:1345:8\n     |\n1345 |     fn hir_anchor(anchor: hir::Anchor) -> Hir {\n     |        ^^^^^^^^^^\n\nwarning: function `hir_word` is never used\n    --> regex-syntax/src/hir/translate.rs:1349:8\n     |\n1349 |     fn hir_word(wb: hir::WordBoundary) -> Hir {\n     |        ^^^^^^^^\n\nwarning: function `uclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1342:8\n     |\n1342 |     fn uclass(ranges: &[(char, char)]) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `bclass` is never used\n    --> regex-syntax/src/hir/mod.rs:1350:8\n     |\n1350 |     fn bclass(ranges: &[(u8, u8)]) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `uranges` is never used\n    --> regex-syntax/src/hir/mod.rs:1358:8\n     |\n1358 |     fn uranges(cls: &ClassUnicode) -> Vec<(char, char)> {\n     |        ^^^^^^^\n\nwarning: function `ucasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1362:8\n     |\n1362 |     fn ucasefold(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^\n\nwarning: function `uunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1368:8\n     |\n1368 |     fn uunion(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^\n\nwarning: function `uintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1374:8\n     |\n1374 |     fn uintersect(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^\n\nwarning: function `udifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1380:8\n     |\n1380 |     fn udifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^\n\nwarning: function `usymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1386:8\n     |\n1386 |     fn usymdifference(cls1: &ClassUnicode, cls2: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `unegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1392:8\n     |\n1392 |     fn unegate(cls: &ClassUnicode) -> ClassUnicode {\n     |        ^^^^^^^\n\nwarning: function `branges` is never used\n    --> regex-syntax/src/hir/mod.rs:1398:8\n     |\n1398 |     fn branges(cls: &ClassBytes) -> Vec<(u8, u8)> {\n     |        ^^^^^^^\n\nwarning: function `bcasefold` is never used\n    --> regex-syntax/src/hir/mod.rs:1402:8\n     |\n1402 |     fn bcasefold(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^\n\nwarning: function `bunion` is never used\n    --> regex-syntax/src/hir/mod.rs:1408:8\n     |\n1408 |     fn bunion(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^\n\nwarning: function `bintersect` is never used\n    --> regex-syntax/src/hir/mod.rs:1414:8\n     |\n1414 |     fn bintersect(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^\n\nwarning: function `bdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1420:8\n     |\n1420 |     fn bdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^\n\nwarning: function `bsymdifference` is never used\n    --> regex-syntax/src/hir/mod.rs:1426:8\n     |\n1426 |     fn bsymdifference(cls1: &ClassBytes, cls2: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^^^^^^^^\n\nwarning: function `bnegate` is never used\n    --> regex-syntax/src/hir/mod.rs:1432:8\n     |\n1432 |     fn bnegate(cls: &ClassBytes) -> ClassBytes {\n     |        ^^^^^^^\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:25\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                         ^^^^\n    |\n    = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`\n    = note: `#[deny(overflowing_literals)]` on by default\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:61\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                             ^^^\n    |\n    = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:525:76\n    |\n525 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                                            ^^^\n    |\n    = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:528:25\n    |\n528 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                         ^^^^\n    |\n    = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:528:61\n    |\n528 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                             ^^^\n    |\n    = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nerror: literal out of range for `u8`\n   --> regex-syntax/src/hir/interval.rs:528:76\n    |\n528 |     let intervals = (0..1000).map(|i| TestInterval::new(i % 256, (i + 1) % 256)).collect::<Vec<_>>();\n    |                                                                            ^^^\n    |\n    = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`\n\nwarning: `regex-syntax` (lib test) generated 94 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 94 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'is_sorted': new API\n   --> regex-syntax/src/hir/interval.rs:529:38\n    |\n529 |     assert!(interval_set.intervals().is_sorted_by(|a, b| a.lower().cmp(&b.lower())));\n    |                                      ^^^^^^^^^^^^\n    |\n    = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485> for more information\n    = help: add `#![feature(is_sorted)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/interval.rs:529:58\n    |\n529 |     assert!(interval_set.intervals().is_sorted_by(|a, b| a.lower().cmp(&b.lower())));\n    |                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `Ordering`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0658.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'is_sorted': new API\n   --> regex-syntax/src/hir/interval.rs:529:38\n    |\n529 |     assert!(interval_set.intervals().is_sorted_by(|a, b| a.upper().cmp(&b.upper())));\n    |                                      ^^^^^^^^^^^^\n    |\n    = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485> for more information\n    = help: add `#![feature(is_sorted)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/hir/interval.rs:529:58\n    |\n529 |     assert!(interval_set.intervals().is_sorted_by(|a, b| a.upper().cmp(&b.upper())));\n    |                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `Ordering`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0658.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}