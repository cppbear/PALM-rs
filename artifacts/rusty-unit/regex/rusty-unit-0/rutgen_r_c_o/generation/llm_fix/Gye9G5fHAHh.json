{
  "name": "regex_syntax::hir::translate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_binary_op_post",
  "name_with_impl": "regex_syntax::hir::translate::{impl#4}::visit_class_set_binary_op_post",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:29:1:29:19"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/translate.rs:512:5:550:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.flags().case_insensitive() is true\n",
        "// constraint: op.kind matches Difference is true\n",
        "// constraint: op.kind matches Difference is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "flags.unicode: true, pop() not equal to None for three consecutive calls, flags.case_insensitive: true, op.kind: Difference\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(true),",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"test_pattern\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "",
                "    let cls = ClassUnicode::new(vec![]);",
                "    let lhs = ClassUnicode::new(vec![]);",
                "    let rhs = ClassUnicode::new(vec![]);",
                "",
                "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                "",
                "    let op = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::Difference,",
                "        lhs: Box::new(ast::ClassSet::new()),",
                "        rhs: Box::new(ast::ClassSet::new()),",
                "    };",
                "",
                "    let _ = translator.visit_class_set_binary_op_post(&op);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), lhs);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), rhs);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), cls);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(lhs.is_all_ascii());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(rhs.is_all_ascii());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(cls.is_all_ascii());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(true),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(true),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), lhs);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(true),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), rhs);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(true),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), cls);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(true),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(lhs.is_all_ascii());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(true),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(rhs.is_all_ascii());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(true),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec[]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::new()),",
                  "    rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(cls.is_all_ascii());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `]`\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^ expected expression\n\nerror: unexpected end of input, expected expression\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_00` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_00()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2600 | |     assert!(result.is_ok());\n2601 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `]`\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^ expected expression\n\nerror: unexpected end of input, expected expression\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_01` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_01()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2600 | |     assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), lhs);\n2601 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `]`\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^ expected expression\n\nerror: unexpected end of input, expected expression\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_02` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_02()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2600 | |     assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), rhs);\n2601 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `]`\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^ expected expression\n\nerror: unexpected end of input, expected expression\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_03` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_03()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2600 | |     assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), cls);\n2601 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `]`\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^ expected expression\n\nerror: unexpected end of input, expected expression\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_04` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_04()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2600 | |     assert!(lhs.is_all_ascii());\n2601 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `]`\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^ expected expression\n\nerror: unexpected end of input, expected expression\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_05` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_05()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2600 | |     assert!(rhs.is_all_ascii());\n2601 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `]`\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^ expected expression\n\nerror: unexpected end of input, expected expression\n    --> regex-syntax/src/hir/translate.rs:2589:37\n     |\n2589 |     let rhs = ClassUnicode::new(vec[]);\n     |                                     ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_06` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_06()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2600 | |     assert!(cls.is_all_ascii());\n2601 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"test_pattern\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "",
                "    let cls = ClassUnicode::new(vec![]);",
                "    let lhs = ClassUnicode::new(vec![]);",
                "    let rhs = ClassUnicode::new(vec![]);",
                "",
                "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                "",
                "    let op = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::Difference,",
                "        lhs: Box::new(ast::ClassSet::new()),",
                "        rhs: Box::new(ast::ClassSet::new()),",
                "    };",
                "",
                "    let _ = translator.visit_class_set_binary_op_post(&op);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), rhs);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), lhs);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), cls);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert!(translator.flags().case_insensitive().is_false());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(op.kind, ast::ClassSetBinaryOpKind::Difference);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert!(translator.visit_class_set_binary_op_post(&op).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), rhs);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), lhs);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_unicode(), cls);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert!(translator.flags().case_insensitive().is_false());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert_eq!(op.kind, ast::ClassSetBinaryOpKind::Difference);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::new()),",
                  "        rhs: Box::new(ast::ClassSet::new()),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let cls = ClassUnicode::new(vec![]);",
                  "    let lhs = ClassUnicode::new(vec![]);",
                  "    let rhs = ClassUnicode::new(vec![]);",
                  "    translator.push(HirFrame::ClassUnicode(cls.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs.clone()));",
                  "    let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };",
                  "    assert!(translator.visit_class_set_binary_op_post(&op).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2577:15\n     |\n2577 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2578:15\n     |\n2578 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:15\n     |\n2579 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:50\n     |\n2583 |     let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new...\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:135\n     |\n2583 | ...ifference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:172\n     |\n2583 | ...t::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2577:15\n     |\n2577 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2578:15\n     |\n2578 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:15\n     |\n2579 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:50\n     |\n2583 |     let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new...\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:135\n     |\n2583 | ...ifference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:172\n     |\n2583 | ...t::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2577:15\n     |\n2577 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2578:15\n     |\n2578 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:15\n     |\n2579 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:50\n     |\n2583 |     let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new...\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:135\n     |\n2583 | ...ifference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:172\n     |\n2583 | ...t::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2577:15\n     |\n2577 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2578:15\n     |\n2578 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:15\n     |\n2579 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:50\n     |\n2583 |     let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new...\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:135\n     |\n2583 | ...ifference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:172\n     |\n2583 | ...t::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_false` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2584:51\n     |\n2584 |     assert!(translator.flags().case_insensitive().is_false());\n     |                                                   ^^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2577:15\n     |\n2577 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2578:15\n     |\n2578 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:15\n     |\n2579 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:50\n     |\n2583 |     let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new...\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:135\n     |\n2583 | ...ifference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:172\n     |\n2583 | ...t::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2559:15\n     |\n2559 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2577:15\n     |\n2577 |     let cls = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2578:15\n     |\n2578 |     let lhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:15\n     |\n2579 |     let rhs = ClassUnicode::new(vec![]);\n     |               ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::new()),\n     |                                      ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:50\n     |\n2583 |     let op = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ast::ClassSet::new...\n     |                                                  ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:135\n     |\n2583 | ...ifference, lhs: Box::new(ast::ClassSet::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:172\n     |\n2583 | ...t::new()), rhs: Box::new(ast::ClassSet::new()), };\n     |                                            ^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `new` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.flags().case_insensitive() is false\n",
        "// constraint: op.kind matches SymmetricDifference is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 < rhs < 1000, 0 < lhs < 1000, 0 < cls < 1000, op.kind == SymmetricDifference\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            case_insensitive: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);",
                "    let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);",
                "    let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);",
                "",
                "    translator.push(HirFrame::ClassUnicode(cls_class.clone()));",
                "    translator.push(HirFrame::ClassUnicode(lhs_class.clone()));",
                "    translator.push(HirFrame::ClassUnicode(rhs_class.clone()));",
                "    ",
                "    let op = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                "        lhs: Box::new(ast::ClassSet::from(lhs_class)),",
                "        rhs: Box::new(ast::ClassSet::from(rhs_class)),",
                "    };",
                "",
                "    let _ = translator.visit_class_set_binary_op_post(&op);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    case_insensitive: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);",
                  "    let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);",
                  "    let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);",
                  "    translator.push(HirFrame::ClassUnicode(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs_class.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ast::ClassSet::from(lhs_class)),",
                  "    rhs: Box::new(ast::ClassSet::from(rhs_class)),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);",
                  "    let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);",
                  "    let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);",
                  "",
                  "    translator.push(HirFrame::ClassUnicode(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs_class.clone()));",
                  "    ",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::from(lhs_class)),",
                  "        rhs: Box::new(ast::ClassSet::from(rhs_class)),",
                  "    };",
                  "",
                  "    let _ = translator.visit_class_set_binary_op_post(&op);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    case_insensitive: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);",
                  "    let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);",
                  "    let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);",
                  "    translator.push(HirFrame::ClassUnicode(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassUnicode(rhs_class.clone()));",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ast::ClassSet::from(lhs_class)),",
                  "    rhs: Box::new(ast::ClassSet::from(rhs_class)),",
                  "    };",
                  "    let result = translator.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2553:21\n     |\n2553 |     let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);\n     |                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);\n     |                                            ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2554:21\n     |\n2554 |     let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);\n     |                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2554:44\n     |\n2554 |     let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);\n     |                                            ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2555:21\n     |\n2555 |     let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);\n     |                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2555:44\n     |\n2555 |     let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);\n     |                                            ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2578:21\n     |\n2578 |     let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);\n     |                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2578:44\n     |\n2578 |     let lhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(0, 5)]);\n     |                                            ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:21\n     |\n2579 |     let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);\n     |                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2579:44\n     |\n2579 |     let rhs_class = ClassUnicode::new(vec![ClassUnicodeRange::new(3, 8)]);\n     |                                            ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2580:21\n     |\n2580 |     let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);\n     |                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2580:44\n     |\n2580 |     let cls_class = ClassUnicode::new(vec![ClassUnicodeRange::new(1, 4)]);\n     |                                            ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2557 |     translator.push(HirFrame::ClassUnicode(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::ClassUnicode(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2559 |     translator.push(HirFrame::ClassUnicode(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:21\n     |\n2562 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2568 |     let _ = translator.visit_class_set_binary_op_post(&op);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2581:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2581 |     translator.push(HirFrame::ClassUnicode(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2582:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2582 |     translator.push(HirFrame::ClassUnicode(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2583 |     translator.push(HirFrame::ClassUnicode(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2585:17\n     |\n2585 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2590:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2590 |     let result = translator.visit_class_set_binary_op_post(&op);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.flags().case_insensitive() is false\n",
        "// constraint: op.kind matches Intersection is true\n",
        "// constraint: op.kind matches Intersection is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "self.flags().unicode(): true; self.pop().unwrap(): ClassUnicode; self.pop().unwrap(): ClassUnicode; self.pop().unwrap(): ClassUnicode; self.flags().case_insensitive(): false; op.kind: Intersection\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "",
                "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                "",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                "",
                "    let operation = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(ast::ClassSet::default()),",
                "        rhs: Box::new(ast::ClassSet::default()),",
                "    };",
                "",
                "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let result = translator_i.visit_class_set_binary_op_post(&operation);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    case_insensitive: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let result = translator_i.visit_class_set_binary_op_post(&operation);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2555:27\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2556:50\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2557:50\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2581:27\n     |\n2581 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2581:50\n     |\n2581 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2582:27\n     |\n2582 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2582:50\n     |\n2582 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2583:27\n     |\n2583 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2583:50\n     |\n2583 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:21\n     |\n2564 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:38\n     |\n2566 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2588:17\n     |\n2588 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2590:34\n     |\n2590 |     lhs: Box::new(ast::ClassSet::default()),\n     |                                  ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2591:34\n     |\n2591 |     rhs: Box::new(ast::ClassSet::default()),\n     |                                  ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "",
                "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                "",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                "",
                "    let operation = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::Difference,",
                "        lhs: Box::new(ast::ClassSet::default()),",
                "        rhs: Box::new(ast::ClassSet::default()),",
                "    };",
                "",
                "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let top_frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(top_frame, HirFrame::ClassUnicode(_)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let top_frame = translator_i.pop().unwrap();",
                  "    let cls = top_frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), expected_length);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let top_frame = translator_i.pop().unwrap();",
                  "    let cls = top_frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert!(cls.is_all_ascii());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let top_frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(top_frame, HirFrame::ClassUnicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let top_frame = translator_i.pop().unwrap();",
                  "    let cls = top_frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), expected_length);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), case_insensitive: Some(false), ..Default::default() }), allow_invalid_utf8: false, };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "    let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let top_frame = translator_i.pop().unwrap();",
                  "    let cls = top_frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert!(cls.is_all_ascii());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2555:27\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2556:50\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2557:50\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2573:27\n     |\n2573 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2573:50\n     |\n2573 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2574:27\n     |\n2574 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2574:50\n     |\n2574 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2575:27\n     |\n2575 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2575:50\n     |\n2575 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:21\n     |\n2564 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:38\n     |\n2566 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:57\n     |\n2579 |     let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::Clas...\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:144\n     |\n2579 | ...section, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:185\n     |\n2579 | ...ault()), rhs: Box::new(ast::ClassSet::default()), };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2555:27\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2556:50\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2557:50\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2573:27\n     |\n2573 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2573:50\n     |\n2573 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2574:27\n     |\n2574 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2574:50\n     |\n2574 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2575:27\n     |\n2575 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2575:50\n     |\n2575 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0425]: cannot find value `expected_length` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:30\n     |\n2584 |     assert_eq!(ranges.len(), expected_length);\n     |                              ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:21\n     |\n2564 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:38\n     |\n2566 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:57\n     |\n2579 |     let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::Clas...\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:144\n     |\n2579 | ...section, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:185\n     |\n2579 | ...ault()), rhs: Box::new(ast::ClassSet::default()), };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2555:27\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2555:50\n     |\n2555 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2556:50\n     |\n2556 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2557:50\n     |\n2557 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2573:27\n     |\n2573 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2573:50\n     |\n2573 |     let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2574:27\n     |\n2574 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2574:50\n     |\n2574 |     let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2575:27\n     |\n2575 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2575:50\n     |\n2575 |     let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);\n     |                                                  ^^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:21\n     |\n2564 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:38\n     |\n2566 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:57\n     |\n2579 |     let operation = ast::ClassSetBinaryOp { span: Span::default(), kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ast::Clas...\n     |                                                         ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:144\n     |\n2579 | ...section, lhs: Box::new(ast::ClassSet::default()), rhs: Box::new(ast::ClassSet::default()), };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:185\n     |\n2579 | ...ault()), rhs: Box::new(ast::ClassSet::default()), };\n     |                                          ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `is_all_ascii` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2584:17\n     |\n2584 |     assert!(cls.is_all_ascii());\n     |                 ^^^^^^^^^^^^ method not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- method `is_all_ascii` not found for this struct\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            case_insensitive: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "",
                "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                "",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                "",
                "    let operation = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                "        lhs: Box::new(ast::ClassSet::default()),",
                "        rhs: Box::new(ast::ClassSet::default()),",
                "    };",
                "",
                "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(result_frame, expected_union_class);"
                ],
                [
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_difference_class = /* expected result after difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(result_frame, expected_difference_class);"
                ],
                [
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_difference_class = /* expected result after difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_symmetric_difference_class = /* expected result after symmetric difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(result_frame, expected_symmetric_difference_class);"
                ],
                [
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_difference_class = /* expected result after difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_symmetric_difference_class = /* expected result after symmetric difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert!(translator_i.pop().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(result_frame, expected_union_class);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_difference_class = /* expected result after difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(result_frame, expected_difference_class);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_difference_class = /* expected result after difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_symmetric_difference_class = /* expected result after symmetric difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(result_frame, expected_symmetric_difference_class);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            case_insensitive: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let class_unicode_1 = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
                  "    let class_unicode_2 = ClassUnicode::new(vec![ClassUnicodeRange::new('c', 'f')]);",
                  "    let class_unicode_3 = ClassUnicode::new(vec![ClassUnicodeRange::new('g', 'm')]);",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_1));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_2));",
                  "    translator_i.push(HirFrame::ClassUnicode(class_unicode_3));",
                  "",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_union_class = /* expected result after intersection */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_difference_class = /* expected result after difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let operation = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "    lhs: Box::new(ast::ClassSet::default()),",
                  "    rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "    let lhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let rhs_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let expected_symmetric_difference_class = /* expected result after symmetric difference */;",
                  "    translator_i.visit_class_set_binary_op_post(&operation).unwrap();",
                  "    let result_frame = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert!(translator_i.pop().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `;`\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^ expected expression\n\nerror: expected expression\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_18` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_18()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2582 | |     assert_eq!(result_frame, expected_union_class);\n2583 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `;`\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^ expected expression\n\nerror: expected expression\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_19` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_19()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2593 | |     assert_eq!(result_frame, expected_difference_class);\n2594 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `;`\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^ expected expression\n\nerror: expected expression\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_20` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_20()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2604 | |     assert_eq!(result_frame, expected_symmetric_difference_class);\n2605 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected expression, found `;`\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^ expected expression\n\nerror: expected expression\n    --> regex-syntax/src/hir/translate.rs:2579:72\n     |\n2579 |     let expected_union_class = /* expected result after intersection */;\n     |                                                                        ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/hir/translate.rs:2535:8\n     |\n2535 |    use super::*;\n     |        ^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_visit_class_set_binary_op_post_00` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:1\n     |\n2541 | / fn test_visit_class_set_binary_op_post_00()\n2542 | | {\n2543 | |     let trans = Translator {\n2544 | |         stack: RefCell::new(Vec::new()),\n...    |\n2604 | |     assert!(translator_i.pop().is_none());\n2605 | | }\n     | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.flags().case_insensitive() is true\n",
        "// constraint: op.kind matches Difference is true\n",
        "// constraint: op.kind matches Difference is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "self.flags().unicode() is false, self.pop().unwrap() is ClassBytes, self.pop().unwrap() is ClassBytes, self.pop().unwrap() is ClassBytes, self.flags().case_insensitive() is true, op.kind matches Difference is true\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            case_insensitive: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let op = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::Difference,",
                "        lhs: Box::new(ClassSet::new(vec![])),",
                "        rhs: Box::new(ClassSet::new(vec![])),",
                "    };",
                "",
                "    let mut lhs_class = ClassBytes::new(vec![]);",
                "    let mut rhs_class = ClassBytes::new(vec![]);",
                "    let mut cls_class = ClassBytes::new(vec![]);",
                "",
                "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                "",
                "    translator.visit_class_set_binary_op_post(&op).ok();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    assert!(translator.visit_class_set_binary_op_post(&op).is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    assert_eq!(translator.stack.borrow().len(), 1);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    let result_frame = translator.stack.borrow().last().unwrap();",
                  "    assert!(matches!(result_frame, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    let result_frame = translator.stack.borrow().last().unwrap();",
                  "    assert!(lhs_class.is_empty());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    let result_frame = translator.stack.borrow().last().unwrap();",
                  "    assert!(rhs_class.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ClassSet::new(vec![])),",
                  "        rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "",
                  "    translator.visit_class_set_binary_op_post(&op).ok();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    assert!(translator.visit_class_set_binary_op_post(&op).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ClassSet::new(vec![])),",
                  "        rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "",
                  "    translator.visit_class_set_binary_op_post(&op).ok();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    assert_eq!(translator.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ClassSet::new(vec![])),",
                  "        rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "",
                  "    translator.visit_class_set_binary_op_post(&op).ok();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    let result_frame = translator.stack.borrow().last().unwrap();",
                  "    assert!(matches!(result_frame, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ClassSet::new(vec![])),",
                  "        rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "",
                  "    translator.visit_class_set_binary_op_post(&op).ok();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    let result_frame = translator.stack.borrow().last().unwrap();",
                  "    assert!(lhs_class.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Difference,",
                  "        lhs: Box::new(ClassSet::new(vec![])),",
                  "        rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "",
                  "    translator.visit_class_set_binary_op_post(&op).ok();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    case_insensitive: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Difference,",
                  "    lhs: Box::new(ClassSet::new(vec![])),",
                  "    rhs: Box::new(ClassSet::new(vec![])),",
                  "    };",
                  "    let mut lhs_class = ClassBytes::new(vec![]);",
                  "    let mut rhs_class = ClassBytes::new(vec![]);",
                  "    let mut cls_class = ClassBytes::new(vec![]);",
                  "    translator.push(HirFrame::ClassBytes(cls_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(lhs_class.clone()));",
                  "    translator.push(HirFrame::ClassBytes(rhs_class.clone()));",
                  "    let result_frame = translator.stack.borrow().last().unwrap();",
                  "    assert!(rhs_class.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |         lhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:23\n     |\n2557 |         rhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2581:19\n     |\n2581 |     lhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2582:19\n     |\n2582 |     rhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2584:25\n     |\n2584 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:21\n     |\n2554 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2565 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2568 |     translator.visit_class_set_binary_op_post(&op).ok();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:17\n     |\n2579 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2587:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2587 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2588:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2588 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2589:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2589 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2590:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2590 |     assert!(translator.visit_class_set_binary_op_post(&op).is_ok());\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |         lhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:23\n     |\n2557 |         rhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2581:19\n     |\n2581 |     lhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2582:19\n     |\n2582 |     rhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2584:25\n     |\n2584 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:21\n     |\n2554 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2565 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2568 |     translator.visit_class_set_binary_op_post(&op).ok();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:17\n     |\n2579 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2587:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2587 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2588:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2588 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2589:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2589 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |         lhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:23\n     |\n2557 |         rhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2581:19\n     |\n2581 |     lhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2582:19\n     |\n2582 |     rhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2584:25\n     |\n2584 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:21\n     |\n2554 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2565 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2568 |     translator.visit_class_set_binary_op_post(&op).ok();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:17\n     |\n2579 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2587:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2587 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2588:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2588 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2589:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2589 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |         lhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:23\n     |\n2557 |         rhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2581:19\n     |\n2581 |     lhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2582:19\n     |\n2582 |     rhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2584:25\n     |\n2584 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:21\n     |\n2554 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2565 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2568 |     translator.visit_class_set_binary_op_post(&op).ok();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:17\n     |\n2579 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2587:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2587 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2588:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2588 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2589:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2589 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |         lhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:23\n     |\n2557 |         rhs: Box::new(ClassSet::new(vec![])),\n     |                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2581:19\n     |\n2581 |     lhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2582:19\n     |\n2582 |     rhs: Box::new(ClassSet::new(vec![])),\n     |                   ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2584:25\n     |\n2584 |     let mut lhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     let mut rhs_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     let mut cls_class = ClassBytes::new(vec![]);\n     |                         ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:21\n     |\n2554 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2565 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_binary_op_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_binary_op_post` not found for this struct\n...\n2568 |     translator.visit_class_set_binary_op_post(&op).ok();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_binary_op_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:17\n     |\n2579 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2587:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2587 |     translator.push(HirFrame::ClassBytes(cls_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2588:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2588 |     translator.push(HirFrame::ClassBytes(lhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2589:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2589 |     translator.push(HirFrame::ClassBytes(rhs_class.clone()));\n     |                ^^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.flags().case_insensitive() is false\n",
        "// constraint: op.kind matches SymmetricDifference is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "self.flags().unicode() = false, self.pop() = Some(ClassBytes), self.pop() = Some(ClassBytes), self.pop() = Some(ClassBytes), self.flags().case_insensitive() = false, op.kind = SymmetricDifference\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            case_insensitive: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                "",
                "    // Create three ClassBytes instances",
                "    let cls1 = ClassBytes::new(vec![]);",
                "    let cls2 = ClassBytes::new(vec![]);",
                "    let cls3 = ClassBytes::new(vec![]);",
                "",
                "    // Push ClassBytes onto stack",
                "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                "",
                "    // Create the ClassSetBinaryOp with SymmetricDifference",
                "    let op = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                "        lhs: Box::new(ast::ClassSet::default()),",
                "        rhs: Box::new(ast::ClassSet::default()),",
                "    };",
                "",
                "    // Call the function under test",
                "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(flags.unicode(), false);"
                ],
                [
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(flags.case_insensitive(), false);"
                ],
                [
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes(), cls1);"
                ],
                [
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes(), cls2);"
                ],
                [
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes(), cls3);"
                ],
                [
                  "    let flags = translator_i.flags();",
                  "    assert!(matches!(op.kind, ast::ClassSetBinaryOpKind::SymmetricDifference));"
                ],
                [
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(_result, Ok(()));"
                ],
                [
                  "    let flags = translator_i.flags();",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    let cls1 = ClassBytes::new(vec![]);",
                  "    let cls2 = ClassBytes::new(vec![]);",
                  "    let cls3 = ClassBytes::new(vec![]);",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(flags.unicode(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    let cls1 = ClassBytes::new(vec![]);",
                  "    let cls2 = ClassBytes::new(vec![]);",
                  "    let cls3 = ClassBytes::new(vec![]);",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(flags.case_insensitive(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    use hir::ClassBytes;  ",
                  "    let cls2 = ClassBytes::new(vec![]);  ",
                  "    let cls3 = ClassBytes::new(vec![]);  ",
                  "    let cls1 = ClassBytes::new(vec![]);  ",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes(), cls1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    let cls1 = ClassBytes::new(vec![]);",
                  "    let cls2 = ClassBytes::new(vec![]);",
                  "    let cls3 = ClassBytes::new(vec![]);",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes(), cls2);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    let cls1 = ClassBytes::new(vec![]);",
                  "    let cls2 = ClassBytes::new(vec![]);",
                  "    let cls3 = ClassBytes::new(vec![]);",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes(), cls3);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    let cls1 = ClassBytes::new(vec![]);",
                  "    let cls2 = ClassBytes::new(vec![]);",
                  "    let cls3 = ClassBytes::new(vec![]);",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    assert!(matches!(op.kind, ast::ClassSetBinaryOpKind::SymmetricDifference));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    let cls1 = ClassBytes::new(vec![]);",
                  "    let cls2 = ClassBytes::new(vec![]);",
                  "    let cls3 = ClassBytes::new(vec![]);",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    assert_eq!(_result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            case_insensitive: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    // Create three ClassBytes instances",
                  "    let cls1 = ClassBytes::new(vec![]);",
                  "    let cls2 = ClassBytes::new(vec![]);",
                  "    let cls3 = ClassBytes::new(vec![]);",
                  "",
                  "    // Push ClassBytes onto stack",
                  "    translator_i.push(HirFrame::ClassBytes(cls3.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls2.clone()));",
                  "    translator_i.push(HirFrame::ClassBytes(cls1.clone()));",
                  "",
                  "    // Create the ClassSetBinaryOp with SymmetricDifference",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::SymmetricDifference,",
                  "        lhs: Box::new(ast::ClassSet::default()),",
                  "        rhs: Box::new(ast::ClassSet::default()),",
                  "    };",
                  "",
                  "    // Call the function under test",
                  "    let _result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let flags = translator_i.flags();",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |     let cls1 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n2557 |     let cls2 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n2558 |     let cls3 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |     let cls1 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n2557 |     let cls2 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n2558 |     let cls3 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:21\n     |\n2568 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:38\n     |\n2571 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |     let cls1 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n2557 |     let cls2 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n2558 |     let cls3 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |     let cls1 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n2557 |     let cls2 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n2558 |     let cls3 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |     let cls1 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n2557 |     let cls2 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n2558 |     let cls3 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |     let cls1 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n2557 |     let cls2 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n2558 |     let cls3 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |     let cls1 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2557:16\n     |\n2557 |     let cls2 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n2558 |     let cls3 = ClassBytes::new(vec![]);\n     |                ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |         lhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no variant or associated item named `default` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:38\n     |\n2570 |         rhs: Box::new(ast::ClassSet::default()),\n     |                                      ^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `default` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.flags().case_insensitive() is false\n",
        "// constraint: op.kind matches Intersection is true\n",
        "// constraint: op.kind matches Intersection is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= self.pop().unwrap() <= 255, 0 <= self.pop().unwrap() <= 255, 0 <= self.pop().unwrap() <= 255, self.flags().unicode() == false, self.flags().case_insensitive() == false, op.kind == Intersection\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);",
                "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);",
                "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);",
                "    ",
                "    let op = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(class_bytes1),",
                "        rhs: Box::new(class_bytes2),",
                "    };",
                "    ",
                "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                "    ",
                "    let _ = translator_i.visit_class_set_binary_op_post(&op);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(class_bytes1),",
                  "    rhs: Box::new(class_bytes2),",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "    let result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);",
                  "    ",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(class_bytes1),",
                  "        rhs: Box::new(class_bytes2),",
                  "    };",
                  "    ",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "    ",
                  "    let _ = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(class_bytes1),",
                  "    rhs: Box::new(class_bytes2),",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "    let result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:24\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2553:45\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2554:24\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2554:45\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2555:24\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2579:24\n     |\n2579 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2579:45\n     |\n2579 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(1, 5)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2580:24\n     |\n2580 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2580:45\n     |\n2580 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(3, 7)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2581:24\n     |\n2581 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2581:45\n     |\n2581 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(2, 6)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:21\n     |\n2558 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:17\n     |\n2583 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                "",
                "    let op = ast::ClassSetBinaryOp {",
                "        span: Span::default(),",
                "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                "        lhs: Box::new(class_bytes1),",
                "        rhs: Box::new(class_bytes2),",
                "    };",
                "",
                "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                "",
                "    let _ = translator_i.visit_class_set_binary_op_post(&op);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert_eq!(translator.flags.case_insensitive(), false);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert_eq!(translator.flags.unicode(), false);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(class_bytes1),",
                  "    rhs: Box::new(class_bytes2),",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "    let result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(class_bytes1),",
                  "        rhs: Box::new(class_bytes2),",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "",
                  "    let _ = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert_eq!(translator.flags.case_insensitive(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(class_bytes1),",
                  "        rhs: Box::new(class_bytes2),",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "",
                  "    let _ = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert_eq!(translator.flags.unicode(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "",
                  "    let op = ast::ClassSetBinaryOp {",
                  "        span: Span::default(),",
                  "        kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "        lhs: Box::new(class_bytes1),",
                  "        rhs: Box::new(class_bytes2),",
                  "    };",
                  "",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "",
                  "    let _ = translator_i.visit_class_set_binary_op_post(&op);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
                  "    let op = ast::ClassSetBinaryOp {",
                  "    span: Span::default(),",
                  "    kind: ast::ClassSetBinaryOpKind::Intersection,",
                  "    lhs: Box::new(class_bytes1),",
                  "    rhs: Box::new(class_bytes2),",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test-pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes3));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes1));",
                  "    translator_i.push(HirFrame::ClassBytes(class_bytes2));",
                  "    let result = translator_i.visit_class_set_binary_op_post(&op);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:24\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2553:45\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2554:24\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2554:45\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2555:24\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:21\n     |\n2558 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `case_insensitive` found for struct `std::cell::Cell` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     assert_eq!(translator.flags.case_insensitive(), false);\n     |                                 ^^^^^^^^^^^^^^^^ method not found in `Cell<Flags>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:24\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2553:45\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2554:24\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2554:45\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2555:24\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:21\n     |\n2558 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `unicode` found for struct `std::cell::Cell` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     assert_eq!(translator.flags.unicode(), false);\n     |                                 ^^^^^^^ method not found in `Cell<Flags>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:24\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2553:45\n     |\n2553 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2554:24\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2554:45\n     |\n2554 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2555:24\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2579:24\n     |\n2579 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2579:45\n     |\n2579 |     let class_bytes1 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2580:24\n     |\n2580 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2580:45\n     |\n2580 |     let class_bytes2 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2581:24\n     |\n2581 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytesRange`\n    --> regex-syntax/src/hir/translate.rs:2581:45\n     |\n2581 |     let class_bytes3 = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);\n     |                                             ^^^^^^^^^^^^^^^ use of undeclared type `ClassBytesRange`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:21\n     |\n2558 |         span: Span::default(),\n     |                     ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Span` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2583:17\n     |\n2583 |     span: Span::default(),\n     |                 ^^^^^^^ function or associated item not found in `ast::Span`\n     |\n    ::: regex-syntax/src/ast/mod.rs:333:1\n     |\n333  | pub struct Span {\n     | --------------- function or associated item `default` not found for this struct\n     |\nnote: if you're trying to build a new `ast::Span` consider using one of the following associated functions:\n      ast::Span::new\n      ast::Span::splat\n    --> regex-syntax/src/ast/mod.rs:396:5\n     |\n396  |     pub fn new(start: Position, end: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n401  |     pub fn splat(pos: Position) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}